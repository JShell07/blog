<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Reference: &amp;lt;&amp;gt; (ARM DDI 0406C.c (ID051414))">
<meta name="keywords" content="arm,spec">
<meta property="og:type" content="article">
<meta property="og:title" content="arm arm part B">
<meta property="og:url" content="http://yoursite.com/2019/05/30/arm_arm_part_B/index.html">
<meta property="og:site_name" content="JShell07&#39;s Blog">
<meta property="og:description" content="Reference: &amp;lt;&amp;gt; (ARM DDI 0406C.c (ID051414))">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-07-02T16:02:46.669Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="arm arm part B">
<meta name="twitter:description" content="Reference: &amp;lt;&amp;gt; (ARM DDI 0406C.c (ID051414))">






  <link rel="canonical" href="http://yoursite.com/2019/05/30/arm_arm_part_B/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>arm arm part B | JShell07's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JShell07's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />Tags<span class="badge">31</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories<span class="badge">12</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives<span class="badge">43</span></a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  
    <div class="reading-progress-bar"></div>
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/30/arm_arm_part_B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JShell07">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JShell07's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">arm arm part B
              
            
          </h1>
        

        <div class="post-meta">
	  
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-05-30 13:55:44" itemprop="dateCreated datePublished" datetime="2019-05-30T13:55:44+08:00">2019-05-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-03 00:02:46" itemprop="dateModified" datetime="2019-07-03T00:02:46+08:00">2019-07-03</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/arm/" itemprop="url" rel="index"><span itemprop="name">arm</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Reference: &lt;<arm ®="" architecture="" reference="" manual="" --="" armv7-a="" and="" armv7-r="" edition="">&gt; (ARM DDI 0406C.c (ID051414))<br><a id="more"></a></arm></p>
<h2 id="Part-B-System-Level-Architecture"><a href="#Part-B-System-Level-Architecture" class="headerlink" title="Part B System Level Architecture"></a>Part B System Level Architecture</h2><h3 id="B1-System-Level-Programmers’-Model"><a href="#B1-System-Level-Programmers’-Model" class="headerlink" title="B1 System Level Programmers’ Model"></a>B1 System Level Programmers’ Model</h3><h4 id="B1-1-About-the-System-level-programmers’-model"><a href="#B1-1-About-the-System-level-programmers’-model" class="headerlink" title="B1.1 About the System level programmers’ model"></a>B1.1 About the System level programmers’ model</h4><h4 id="B1-2-System-level-concepts-and-terminology"><a href="#B1-2-System-level-concepts-and-terminology" class="headerlink" title="B1.2 System level concepts and terminology"></a>B1.2 System level concepts and terminology</h4><h5 id="B1-2-1-Mode-state-and-privilege-level"><a href="#B1-2-1-Mode-state-and-privilege-level" class="headerlink" title="B1.2.1 Mode, state, and privilege level"></a>B1.2.1 Mode, state, and privilege level</h5><h6 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h6><p>The ARM architecture A and R profiles provide a set of modes that support normal software execution and handle<br>exceptions. The current mode determines:<br>• the set of registers that are available to the processor<br>• the privilege level of the executing software</p>
<h6 id="State"><a href="#State" class="headerlink" title="State"></a>State</h6><ul>
<li>Instruction set state</li>
</ul>
<blockquote>
<p>one of ARM state, Thumb state, Jazelle state, or ThumbEE state.</p>
</blockquote>
<ul>
<li>Execution state</li>
</ul>
<blockquote>
<p>consists of the instruction set state and some control bits that modify how the<br>instruction stream is decoded. For details, see Execution state registers on page A2-50 and Program<br>Status Registers (PSRs) on page B1-1147.</p>
</blockquote>
<ul>
<li><p>Security state </p>
</li>
<li><p>Debug state</p>
</li>
</ul>
<h6 id="Privilege-level"><a href="#Privilege-level" class="headerlink" title="Privilege level"></a>Privilege level</h6><p><strong>Secure state</strong><br>PL0 Software executed in User mode executes at PL0.<br>PL1 Software executed in any mode other than User mode executes at PL1.</p>
<p><strong>Non-secure state</strong><br>PL0 Software executed in User mode executes at PL0.<br>PL1 Software executed in any mode other than User or Hyp mode executes at PL1.<br>PL2 In an implementation that includes the Virtualization Extensions, software executed in<br>Hyp mode executes at PL2.</p>
<h4 id="B1-3-ARM-processor-modes-and-ARM-core-registers"><a href="#B1-3-ARM-processor-modes-and-ARM-core-registers" class="headerlink" title="B1.3 ARM processor modes and ARM core registers"></a>B1.3 ARM processor modes and ARM core registers</h4><h5 id="B1-3-1-ARM-processor-modes"><a href="#B1-3-1-ARM-processor-modes" class="headerlink" title="B1.3.1 ARM processor modes"></a>B1.3.1 ARM processor modes</h5><p>Fixme [Table B1-1 ARM processor modes] page1139</p>
<h6 id="System-mode"><a href="#System-mode" class="headerlink" title="System mode"></a>System mode</h6><p>Software executing in System mode executes at PL1. System mode has the same registers available<br>as User mode, and is not entered by any exception.</p>
<h6 id="Supervisor-mode"><a href="#Supervisor-mode" class="headerlink" title="Supervisor mode"></a>Supervisor mode</h6><p>Supervisor mode is the default mode to which a Supervisor Call exception is taken.<br>Executing a SVC (Supervisor Call) instruction generates an Supervisor Call exception, that is taken<br>to Supervisor mode.<br><strong>A processor enters Supervisor mode on Reset</strong></p>
<h6 id="Hyp-mode"><a href="#Hyp-mode" class="headerlink" title="Hyp mode"></a>Hyp mode</h6><p>Hyp mode is the Non-secure PL2 mode, implemented as part of the Virtualization Extensions.<br>The Hypervisor Call exception and Hyp Trap exception are exceptions that are implemented as part<br>of the Virtualization Extensions, and that are always taken in Hyp mode.<br>• <strong>In Hyp mode, the only exception return is execution of an ERET instruction, see ERET on page B9-1982</strong><br>• The instructions described in the following sections are UNDEFINED if executed in Hyp mode:<br>    — SRS (Thumb) on page B9-2004<br>    — SRS (ARM) on page B9-2006<br>    — RFE on page B9-2000<br>    — LDM (exception return) on page B9-1986<br>    — LDM (User registers) on page B9-1988<br>    — STM (User registers) on page B9-2008<br>    — SUBS PC, LR and related instructions (ARM) on page B9-2012.<br>    — SUBS PC, LR (Thumb) on page B9-2010, when executed with a nonzero constant.</p>
<p>• In Hyp mode, the CPACR has no effect on the execution of coprocessor, floating-point, or Advanced SIMD<br>instructions. The HCPTR controls execution of these instructions in Hyp mode.</p>
<p>• If software running in Hyp mode executes an SVC instruction, the Supervisor Call exception generated by the<br>instruction is taken to Hyp mode, see SVC (previously SWI) on page A8-720.</p>
<h6 id="Monitor-mode"><a href="#Monitor-mode" class="headerlink" title="Monitor mode"></a>Monitor mode</h6><p>Monitor mode is the mode to which a Secure Monitor Call exception is taken.<br>Monitor mode is a Secure mode, meaning it is always in the Secure state, regardless of the value of<br>the SCR.NS bit. <strong>Monitor mode provides the normal method of changing between the Secure and Non-secure security states.</strong></p>
<p>Fixme [Figure B1-1 Modes, privilege levels, and security states] page1141</p>
<h5 id="B1-3-2-ARM-core-registers"><a href="#B1-3-2-ARM-core-registers" class="headerlink" title="B1.3.2 ARM core registers"></a>B1.3.2 ARM core registers</h5><p>Fixme [Figure B1-2 ARM core registers, PSRs, and ELR_hyp, showing register banking] page1144</p>
<h5 id="B1-3-3-Program-Status-Registers-PSRs"><a href="#B1-3-3-Program-Status-Registers-PSRs" class="headerlink" title="B1.3.3 Program Status Registers (PSRs)"></a>B1.3.3 Program Status Registers (PSRs)</h5><h6 id="The-Current-Program-Status-Register-CPSR"><a href="#The-Current-Program-Status-Register-CPSR" class="headerlink" title="The Current Program Status Register (CPSR)"></a>The Current Program Status Register (CPSR)</h6><p>The Current Program Status Register (CPSR) holds processor status and control information:<br>• the APSR, see The Application Program Status Register (APSR) on page A2-49<br>• the current instruction set state, see Instruction set state register, ISETSTATE on page A2-50<br>• the execution state bits for the Thumb If-Then instruction, see IT block state register, ITSTATE on page A2-51<br>• the current endianness, see Endianness mapping register, ENDIANSTATE on page A2-53<br>• the current processor mode<br>• interrupt and asynchronous abort disable bits.</p>
<h6 id="The-Saved-Program-Status-Registers-SPSRs"><a href="#The-Saved-Program-Status-Registers-SPSRs" class="headerlink" title="The Saved Program Status Registers (SPSRs)"></a>The Saved Program Status Registers (SPSRs)</h6><p>The purpose of an SPSR is to record the pre-exception value of the CPSR. </p>
<p>Fixme [Format of the CPSR and SPSRs] Page1148</p>
<h5 id="B1-3-4-ELR-hyp"><a href="#B1-3-4-ELR-hyp" class="headerlink" title="B1.3.4 ELR_hyp"></a>B1.3.4 ELR_hyp</h5><p>Hyp mode does not provide its own Banked copy of LR. Instead, on taking an exception to Hyp mode, the preferred<br>return address is stored in ELR_hyp, a 32-bit Special register implemented for this purpose.<br>ELR_hyp is implemented only as part of the Virtualization Extensions.</p>
<p>The ERET instruction uses the value in ELR_hyp as the return address for the exception. For more information, see<br>ERET on page B9-1982.</p>
<h4 id="B1-4-Instruction-set-states"><a href="#B1-4-Instruction-set-states" class="headerlink" title="B1.4 Instruction set states"></a>B1.4 Instruction set states</h4><p>If an exception is taken to a PL1 mode, the SCTLR.TE bit for the security state the exception is taken to determines<br>the processor instruction set state that handles the exception, and if necessary, the processor changes to this<br>instruction set state on exception entry.</p>
<p>If the exception is taken to Hyp mode, the HSCTLR.TE bit determines the processor instruction set state that<br>handles the exception, and if necessary, the processor changes to this instruction set state on exception entry.</p>
<h4 id="B1-5-The-Security-Extensions"><a href="#B1-5-The-Security-Extensions" class="headerlink" title="B1.5 The Security Extensions"></a>B1.5 The Security Extensions</h4><h5 id="B1-5-1-Security-states"><a href="#B1-5-1-Security-states" class="headerlink" title="B1.5.1 Security states"></a>B1.5.1 Security states</h5><p>The Security Extensions define two security states, Secure state and Non-secure state.<br>• Each security state operates in its own virtual memory address space, with its own translation regime.<br>— in any implementation that includes the Security Extensions, Monitor mode is available only in Secure<br>state<br>— in an implementation that also includes the Virtualization Extensions, Hyp mode is available only in<br>Non-secure state.</p>
<p>The ARM core registers and the processor status registers are not Banked between the Secure and the Non-secure<br>states. ARM expects that, when switching execution between the Non-secure and Secure states, a kernel running<br>mostly in Monitor mode will switch the values of these registers.<br>The registers LR_mon and SPSR_mon are UNKNOWN when executing in Non-secure state.</p>
<h6 id="Changing-from-Secure-to-Non-secure-state"><a href="#Changing-from-Secure-to-Non-secure-state" class="headerlink" title="Changing from Secure to Non-secure state"></a>Changing from Secure to Non-secure state</h6><p>Except in Monitor mode and Hyp mode, the security state is controlled by the SCR.NS bit. Software executing in a Secure PL1 mode can change the SCR, but ARM strongly recommends that software obeys the following rules for changing SCR.NS:<br>• To avoid security holes, software must not:<br>    — Change from Secure to Non-secure state by using an MSR or CPS instruction to switch from Monitor<br>    mode to some other mode while SCR.NS is 1.<br>    — Use an MCR instruction that writes SCR.NS to change from Secure to Non-secure state. This means<br>    ARM recommends that software does not alter SCR.NS in any mode except Monitor mode. ARM<br>    deprecates changing SCR.NS in any other mode.</p>
<p>• <strong>The usual mechanism for changing from Secure to Non-secure state is an exception return</strong>.To return to<br>Non-secure state, software executing in Monitor mode sets SCR.NS to 1 and then performs the exception<br>return.</p>
<h4 id="B1-6-The-Large-Physical-Address-Extension"><a href="#B1-6-The-Large-Physical-Address-Extension" class="headerlink" title="B1.6 The Large Physical Address Extension"></a>B1.6 The Large Physical Address Extension</h4><p>The Large Physical Address Extension is an OPTIONAL extension to the ARMv7-A architecture profile. Any<br>implementation that includes the Large Physical Address Extension must also include the Multiprocessing<br>Extensions.</p>
<p>The Large Physical Address Extension adds a new translation table format:<br>• the format used in an implementation that does not include the Large Physical Address Extension is now<br>called the Short-descriptor format, see Short-descriptor translation table format on page B3-1324<br>• the format added by the Large Physical Address Extension is the Long-descriptor format, see<br>Long-descriptor translation table format on page B3-1338.</p>
<p><strong>An implementation that includes the Large Physical Address Extension must support both translation table formats.</strong></p>
<h4 id="B1-7-The-Virtualization-Extensions"><a href="#B1-7-The-Virtualization-Extensions" class="headerlink" title="B1.7 The Virtualization Extensions"></a>B1.7 The Virtualization Extensions</h4><p>The Virtualization Extensions are an OPTIONAL extension to the ARMv7-A architecture profile. Any<br>implementation that includes the Virtualization Extensions must include the Security Extensions, the Large Physical<br>Address Extension, and the Multiprocessing Extensions.</p>
<p>The basic model of a virtualized system involves:<br>• a hypervisor, running in Non-secure Hyp mode, that is responsible for switching Guest operating systems<br>• a number of Guest operating systems, each of which runs in the Non-secure PL1 and PL0 modes<br>• for each Guest operating system, applications, that usually run in User mode.</p>
<p><strong>Each virtual machine is identified by a virtual machine identifier (VMID), assigned by the hypervisor.</strong><br>• With the Security Extensions, the Virtualization Extensions control the routing of interrupts and<br>asynchronous Data Abort exceptions to the appropriate one of:<br>— the current Guest OS<br>— a Guest OS that is not currently running<br>— the hypervisor<br>— the Secure monitor.</p>
<p>• When an implementation includes the Virtualization Extensions, it provides independent translation regimes<br>for memory accesses from:<br>    — Secure modes, the Secure PL1&amp;0 translation regime<br>    — Non-secure Hyp mode, the Non-secure PL2 translation regime<br>    — Non-secure PL1 and PL0 modes, the Non-secure PL1&amp;0 translation regime</p>
<p>• In the Non-secure PL1&amp;0 translation regime, address translation occurs in two stages:<br>— Stage 1 maps the Virtual Address (VA) to an Intermediate Physical Address (IPA). Typically, the Guest<br>OS configures and controls this stage, and believes that the IPA is the Physical Address (PA)<br>— Stage 2 maps the IPA to the PA. Typically, the hypervisor controls this stage, and a Guest OS is<br>completely unaware of this translation.</p>
<h5 id="B1-7-1-Impact-of-the-Virtualization-Extensions-on-the-modes-and-exception-model"><a href="#B1-7-1-Impact-of-the-Virtualization-Extensions-on-the-modes-and-exception-model" class="headerlink" title="B1.7.1 Impact of the Virtualization Extensions on the modes and exception model"></a>B1.7.1 Impact of the Virtualization Extensions on the modes and exception model</h5><p>• Implements new exceptions, see:<br>    — Hypervisor Call (HVC) exception on page B1-1212<br>    — Hyp Trap exception on page B1-1209<br>    — Virtual IRQ exception on page B1-1221<br>    — Virtual FIQ exception on page B1-1223<br>    — Virtual Abort exception on page B1-1218.</p>
<p>• Implements a new register that holds the exception vector base address for exceptions taken to Hyp mode,<br>the HVBAR.</p>
<p>• Implements a new exception return instruction, ERET, for return from Hyp mode</p>
<p>• Provide mechanisms to trap processor functions to Hyp mode, using the Hyp Trap exception, see Traps to<br>the hypervisor on page B1-1248.<br>When an operation is trapped to Hyp mode, the hypervisor typically either:<br>    — emulates the required operation, so the application running in the Guest OS is unaware of the trap to<br>    Hyp mode<br>    — returns an error to the Guest OS.</p>
<h4 id="B1-8-Exception-handling"><a href="#B1-8-Exception-handling" class="headerlink" title="B1.8 Exception handling"></a>B1.8 Exception handling</h4><h5 id="B1-8-1-Exception-vectors-and-the-exception-base-address"><a href="#B1-8-1-Exception-vectors-and-the-exception-base-address" class="headerlink" title="B1.8.1 Exception vectors and the exception base address"></a>B1.8.1 Exception vectors and the exception base address</h5><p>When an exception is taken, processor execution is forced to an address that corresponds to the type of exception.<br>This address is called the exception vector for that exception.</p>
<p><strong>A set of exception vectors comprises eight consecutive word-aligned memory addresses</strong>, starting at an exception<br>base address. These eight vectors form a vector table. <strong>For the IRQ and FIQ exceptions only</strong>, when the exceptions<br>are taken to IRQ mode and FIQ mode, software can change the exception vectors from the vector table values by<br>setting the SCTLR.VE bit to 1, see Vectored interrupt support on page B1-1168.</p>
<h6 id="Implementation-that-does-not-include-the-Security-Extensions-1-pair-interrupt-vectors"><a href="#Implementation-that-does-not-include-the-Security-Extensions-1-pair-interrupt-vectors" class="headerlink" title="Implementation that does not include the Security Extensions (1 pair interrupt vectors)"></a>Implementation that does not include the Security Extensions (1 pair interrupt vectors)</h6><p>This section applied to all ARMv7-R implementations.<br>An implementation that does not include the Security Extensions has a single vector table, the base<br>address of which is selected by SCTLR.V, see SCTLR, System Control Register, VMSA on<br>page B4-1707 or SCTLR, System Control Register, PMSA on page B6-1932:<br>    V == 0 Exception base address = 0x00000000. This setting is referred to as normal vectors, or as<br>    low vectors.<br>    V == 1 Exception base address = 0xFFFF0000. This setting is referred to as high vectors, or<br>    Hivecs.</p>
<h6 id="Implementation-that-includes-the-Security-Extensions-3-pair-interrupt-vectors"><a href="#Implementation-that-includes-the-Security-Extensions-3-pair-interrupt-vectors" class="headerlink" title="Implementation that includes the Security Extensions (3 pair interrupt vectors)"></a>Implementation that includes the Security Extensions (3 pair interrupt vectors)</h6><p>Any implementation that includes the Security Extensions has the following vector tables:<br>• One for exceptions taken to Secure Monitor mode. This is the Monitor vector table, and is in<br>the address space of the Secure PL1&amp;0 translation regime.<br>• One for exceptions taken to Secure PL1 modes other than Monitor mode. This is the Secure<br>vector table, and is in the address space of the Secure PL1&amp;0 translation regime.<br>• One for exceptions taken to Non-secure PL1 modes. This is the Non-secure vector table, and<br>is in the address space of the Non-secure PL1&amp;0 translation regime.</p>
<p><strong>For the Monitor vector table, MVBAR holds the exception base address.</strong></p>
<p>For the Secure vector table:<br>• the Secure SCTLR.V bit determines the exception base address:<br>    V == 0 The Secure VBAR holds the exception base address.<br>    V == 1 Exception base address = 0xFFFF0000, the Hivecs setting.</p>
<p>For the Non-secure vector table:<br>• the Non-secure SCTLR.V bit determines the exception base address:<br>    V == 0 The Non-secure VBAR holds the exception base address.<br>    V == 1 Exception base address = 0xFFFF0000, the Hivecs setting.</p>
<h6 id="Implementation-that-includes-the-Virtualization-Extensions-4-pair-interrupt-vectors"><a href="#Implementation-that-includes-the-Virtualization-Extensions-4-pair-interrupt-vectors" class="headerlink" title="Implementation that includes the Virtualization Extensions (4 pair interrupt vectors)"></a>Implementation that includes the Virtualization Extensions (4 pair interrupt vectors)</h6><p>An implementation that includes the Virtualization Extensions must include the Security<br>Extensions, and also includes an additional vector table. Therefore, it has the following vector<br>tables:<br>• One for exceptions taken to Secure Monitor mode. This is the Monitor vector table, and is in<br>the address space of the Secure PL1&amp;0 translation regime.<br>• One for exceptions taken to Secure PL1 modes other than Monitor mode. This is the Secure<br>vector table, and is in the address space of the Secure PL1&amp;0 translation regime.<br>• One for exceptions taken to Hyp mode, the Non-secure PL2 mode. This is the Hyp vector<br>table, and is in the address space of the Non-secure PL2 translation regime.<br>• One for exceptions taken to Non-secure PL1 modes. This is the Non-secure vector table, and<br>is in the address space of the Non-secure PL1&amp;0 translation regime.</p>
<p>The exception base addresses of the Monitor vector table, the Secure vector table, and the<br>Non-secure vector table are determined in the same way as for an implementation that includes the<br>Security extensions but not the Virtualization extensions.</p>
<p><strong>For the Hyp vector table, HVBAR holds the exception base address.</strong></p>
<h6 id="The-vector-tables-and-exception-offsets"><a href="#The-vector-tables-and-exception-offsets" class="headerlink" title="The vector tables and exception offsets"></a>The vector tables and exception offsets</h6><p>Fixme [Table B1-3 The vector tables] page1167</p>
<h5 id="B1-8-4-Processor-mode-for-taking-exceptions"><a href="#B1-8-4-Processor-mode-for-taking-exceptions" class="headerlink" title="B1.8.4 Processor mode for taking exceptions"></a>B1.8.4 Processor mode for taking exceptions</h5><h6 id="Exceptions-taken-to-Hyp-mode"><a href="#Exceptions-taken-to-Hyp-mode" class="headerlink" title="Exceptions taken to Hyp mode"></a>Exceptions taken to Hyp mode</h6><p>• Any exception taken from Hyp mode, that is not routed to Secure Monitor Mode by the controls described<br>in Asynchronous exception routing controls on page B1-1175, is taken to Hyp mode.</p>
<p>• The following exceptions, if taken from Non-secure state, are taken to Hyp mode:<br>    — An abort that Routing of aborts on page B3-1396 identifies as taken to Hyp mode.<br>    — A Hyp Trap exception, see Traps to the hypervisor on page B1-1248.<br>    — A Hypervisor Call exception. This is generated by executing a HVC instruction in a Non-secure mode.<br>    — An asynchronous abort, IRQ exception or FIQ exception that is not routed to Secure Monitor mode<br>    but is explicitly routed to Hyp mode, as described in Asynchronous exception routing controls on<br>    page B1-1175.<br>    — A synchronous external abort, Alignment fault, Undefined Instruction exception, or Supervisor Call<br>    exception taken from the Non-secure PL0 mode and explicitly routed to Hyp mode, as described in<br>    Routing general exceptions to Hyp mode on page B1-1192.<br>    Note<br>    A synchronous external abort can be routed to Hyp mode only if it not routed to Secure Monitor mode.<br>    — A debug exception that is explicitly routed to Hyp mode as described in Routing Debug exceptions to<br>    Hyp mode on page B1-1194.</p>
<h6 id="Asynchronous-exception-routing-controls"><a href="#Asynchronous-exception-routing-controls" class="headerlink" title="Asynchronous exception routing controls"></a>Asynchronous exception routing controls</h6><p>In an implementation that includes the Security Extensions, the following bits in the SCR control the routing of<br>asynchronous exceptions:<br>SCR.EA    When this bit is set to 1, any external abort is taken to Secure Monitor mode<br>SCR.FIQ   When this bit is set to 1, any FIQ exception is taken to Secure Monitor mode.<br>SCR.IRQ   When this bit is set to 1, any IRQ exception is taken to Secure Monitor mode.<br><strong>Only Secure software can change the values of these bits.</strong></p>
<p>In an implementation that includes the Virtualization Extensions, the following bits in the HCR route asynchronous<br>exceptions to Hyp mode:<br>HCR.AMO   If SCR.EA is set to 0, when this bit is set to 1, an asynchronous external abort taken from a<br>          Non-secure PL1 or PL0 mode is taken to Hyp mode, instead of to Non-secure Abort mode.</p>
<p>HCR.FMO   If SCR.FIQ is set to 0, when this bit is set to 1, an FIQ exception taken from a Non-secure PL1 or<br>          PL0 mode is taken to Hyp mode, instead of to Non-secure FIQ mode.</p>
<p>HCR.IMO   If SCR.IRQ is set to 0, when this bit is set to 1, an IRQ exceptions taken from a Non-secure PL1 or<br>          PL0 mode is taken to Hyp mode, instead of to Non-secure IRQ mode.</p>
<p><strong>Only software executing in Hyp mode, or Secure software executing in Monitor mode when SCR.NS is set to 1, can change the values of these bits.</strong></p>
<h5 id="B1-8-5-Processor-state-on-exception-entry"><a href="#B1-8-5-Processor-state-on-exception-entry" class="headerlink" title="B1.8.5 Processor state on exception entry"></a>B1.8.5 Processor state on exception entry</h5><h6 id="Instruction-set-state-on-exception-entry"><a href="#Instruction-set-state-on-exception-entry" class="headerlink" title="Instruction set state on exception entry"></a>Instruction set state on exception entry</h6><p>On exception entry, CPSR.{T, J} are set to the values shown, with the CPSR.T value determined by SCTLR.TE or HSCTLR.TE</p>
<p>Fixme [Table B1-8 CPSR.J and CPSR.T bit values on exception entry] page1182</p>
<h6 id="CPSR-E-bit-value-on-exception-entr"><a href="#CPSR-E-bit-value-on-exception-entr" class="headerlink" title="CPSR.E bit value on exception entr"></a>CPSR.E bit value on exception entr</h6><p>Fixme [Table B1-9 CPSR.E bit value on exception entry] page1182</p>
<h5 id="B1-8-6-Asynchronous-exception-masking"><a href="#B1-8-6-Asynchronous-exception-masking" class="headerlink" title="B1.8.6 Asynchronous exception masking"></a>B1.8.6 Asynchronous exception masking</h5><p>The CPSR.{A, I, F} bits can mask the corresponding exceptions, as follows:<br>• CPSR.A can mask asynchronous aborts<br>• CPSR.I can mask IRQ exceptions<br>• CPSR.F can mask FIQ exceptions.</p>
<p>In an ARMv7 implementation that does not include the Security Extensions, setting one of these bits to 1 masks the<br>corresponding exception, meaning the exception cannot be taken.</p>
<p>In an implementation that includes the Security Extensions, the SCR.{AW, FW} bits provide a mechanism to<br>prevent use of the CPSR.{A, F} mask bits by Non-secure software. In an implementation that includes the<br>Virtualization Extensions:<br>• HCR.{AMO, FMO} modify this mechanism<br>• HCR.IMO can prevent the masking, by CPSR.I, of IRQs taken from Non-secure state.</p>
<p>When an SCR.{AW, FW} bit is set to 0, Non-secure software cannot update the corresponding<br>CPSR bit.</p>
<p>Fixme [Table B1-11 Control of masking by CPSR.A] page1185</p>
<p>Fixme [Table B1-12 Control of masking by CPSR.I] page1185</p>
<p>Fixme [Table B1-13 Control of masking by CPSR.F] page1185</p>
<h5 id="B1-8-7-Summaries-of-asynchronous-exception-behavior"><a href="#B1-8-7-Summaries-of-asynchronous-exception-behavior" class="headerlink" title="B1.8.7 Summaries of asynchronous exception behavior"></a>B1.8.7 Summaries of asynchronous exception behavior</h5><h6 id="Asynchronous-exception-behavior-Security-Extensions-only"><a href="#Asynchronous-exception-behavior-Security-Extensions-only" class="headerlink" title="Asynchronous exception behavior, Security Extensions only"></a>Asynchronous exception behavior, Security Extensions only</h6><p>Fixme [Table B1-14 Behavior of asynchronous aborts, Virtualization Extensions not implemented] page1187</p>
<p>Fixme [Table B1-15 Behavior of IRQ exceptions, Virtualization Extensions not implemented] page1188</p>
<p>Fixme [Table B1-16 Behavior of FIQ exceptions, Virtualization Extensions not implemented] page1188</p>
<h6 id="Asynchronous-exception-behavior-with-the-Virtualization-Extensions"><a href="#Asynchronous-exception-behavior-with-the-Virtualization-Extensions" class="headerlink" title="Asynchronous exception behavior, with the Virtualization Extensions"></a>Asynchronous exception behavior, with the Virtualization Extensions</h6><p>Fixme [Table B1-17 Behavior of asynchronous aborts, Virtualization Extensions implemented] page1189</p>
<p>Fixme [Table B1-18 Behavior of IRQ exceptions, Virtualization Extensions implemented] page1190</p>
<p>Fixme [Table B1-19 Behavior of FIQ exceptions, Virtualization Extensions implemented] page1191</p>
<h5 id="B1-8-8-Routing-general-exceptions-to-Hyp-mode"><a href="#B1-8-8-Routing-general-exceptions-to-Hyp-mode" class="headerlink" title="B1.8.8 Routing general exceptions to Hyp mode"></a>B1.8.8 Routing general exceptions to Hyp mode</h5><p>When HCR.TGE is set to 1, and the processor is in Non-secure User mode, the following exceptions are taken to<br>Hyp mode, instead of to the default Non-secure mode for handling the exception:<br>• Undefined Instruction exceptions.<br>• Supervisor Call exceptions.<br>• Synchronous External aborts.<br>• Any Alignment fault other than an alignment fault caused by the memory type when SCTLR.M is 1.</p>
<h5 id="B1-8-9-Routing-Debug-exceptions-to-Hyp-mode"><a href="#B1-8-9-Routing-Debug-exceptions-to-Hyp-mode" class="headerlink" title="B1.8.9 Routing Debug exceptions to Hyp mode"></a>B1.8.9 Routing Debug exceptions to Hyp mode</h5><p>When HDCR.TDE is set to 1, if the processor is executing in a Non-secure mode other than Hyp mode, any Debug<br>exception is routed to Hyp mode. This means it generates a Hyp Trap exception</p>
<h5 id="B1-8-10-Exception-return"><a href="#B1-8-10-Exception-return" class="headerlink" title="B1.8.10 Exception return"></a>B1.8.10 Exception return</h5><p>On an exception return, the CPSR takes either:<br>• the value loaded by the RFE instruction<br>• if the exception return is not performed by executing an RFE instruction, the value of the current SPSR at the<br>time of the exception return</p>
<h6 id="Return-from-an-exception-taken-to-a-PL1-mode"><a href="#Return-from-an-exception-taken-to-a-PL1-mode" class="headerlink" title="Return from an exception taken to a PL1 mode"></a>Return from an exception taken to a PL1 mode</h6><p>For an exception taken to a PL1 mode, the ARM architecture provides the following exception return instructions:<br>• <strong>Data-processing instructions with the S bit set and the PC as a destination</strong>, see SUBS PC, LR (Thumb) on<br>page B9-2010 and SUBS PC, LR and related instructions (ARM) on page B9-2012.<br>Typically:<br>    — a return where no subtraction is required uses SUBS with an operand of 0, or the equivalent MOVS<br>    instruction<br>    — a return requiring subtraction uses SUBS with a nonzero operand.</p>
<p>• <strong>From ARMv6, the RFE instruction, see RFE</strong> on page B9-2000. If a subtraction is required, typically it is<br>performed before saving the LR value to memory.</p>
<p>• <strong>In ARM state, a form of the LDM instruction</strong>, see LDM (exception return) on page B9-1986. If a subtraction is<br>required, typically it is performed before saving the LR value to memory.</p>
<h6 id="Return-from-an-exception-taken-to-a-PL2-mode"><a href="#Return-from-an-exception-taken-to-a-PL2-mode" class="headerlink" title="Return from an exception taken to a PL2 mode"></a>Return from an exception taken to a PL2 mode</h6><p>For an exception taken to a PL2 mode, the ARM architecture provides the <strong>ERET</strong> instruction, see ERET on<br>page B9-1982. An exception handler executing in a PL2 mode must return using the ERET instruction.<br>Hyp mode is the only PL2 mode. Both Hyp mode and the ERET instruction are implemented only as part of the<br>Virtualization Extensions.</p>
<h5 id="B1-8-11-Virtual-exceptions-in-the-Virtualization-Extensions"><a href="#B1-8-11-Virtual-exceptions-in-the-Virtualization-Extensions" class="headerlink" title="B1.8.11 Virtual exceptions in the Virtualization Extensions"></a>B1.8.11 Virtual exceptions in the Virtualization Extensions</h5><p>Fixme [Table B1-20 HCR bits controlling asynchronous exceptions] page1198</p>
<h5 id="B1-8-12-Low-interrupt-latency-configuration"><a href="#B1-8-12-Low-interrupt-latency-configuration" class="headerlink" title="B1.8.12 Low interrupt latency configuration"></a>B1.8.12 Low interrupt latency configuration</h5><p>Setting SCTLR.FI to 1 enables the low interrupt latency configuration of an implementation. This configuration can<br>reduce the interrupt latency of the processor. The mechanisms implemented to achieve low interrupt latency are<br>IMPLEMENTATION DEFINED. For the description of the SCTLR see either:<br>• SCTLR, System Control Register, VMSA on page B4-1707<br>• SCTLR, System Control Register, PMSA on page B6-1932</p>
<h5 id="B1-8-13-Wait-For-Event-and-Send-Event"><a href="#B1-8-13-Wait-For-Event-and-Send-Event" class="headerlink" title="B1.8.13 Wait For Event and Send Event"></a>B1.8.13 Wait For Event and Send Event</h5><p>ARMv7 and ARMv6K provide a mechanism, the Wait For Event mechanism, that permits a processor in a<br>multiprocessor system to request <strong>entry to a low-power state</strong>, and, if the request succeeds, to remain in that state until<br>it receives an event generated by a Send Event operation on another processor in the system.<br><strong>example using for spin-lock</strong></p>
<p>The Virtualization Extensions provide a bit that traps to Hyp mode any attempt to enter a low-power state from a<br>Non-secure PL1 or PL0 mode.</p>
<h6 id="WFE-wake-up-events"><a href="#WFE-wake-up-events" class="headerlink" title="WFE wake-up events"></a>WFE wake-up events</h6><p>The following events are WFE wake-up events:<br>• the execution of an SEV instruction on any processor in the multiprocessor system<br>• a physical IRQ interrupt, unless masked by the CPSR.I bit<br>• a physical FIQ interrupt, unless masked by the CPSR.F bit<br>• a physical asynchronous abort, unless masked by the CPSR.A bit<br>• in Non-secure state in any mode other than Hyp mode:<br>    — when HCR.IMO is set to 1, a virtual IRQ interrupt, unless masked by the CPSR.I bit<br>    — when HCR.FMO is set to 1, a virtual FIQ interrupt, unless masked by the CPSR.F bit<br>    — when HCR.AMO is set to 1, a virtual asynchronous abort, unless masked by the CPSR.A bit<br>• an asynchronous debug event, if invasive debug is enabled and the debug event is permitted<br>• an event sent by the timer event stream, see Event streams on page B8-1964<br>• an event sent by some IMPLEMENTATION DEFINED mechanism.</p>
<h6 id="The-Event-Register"><a href="#The-Event-Register" class="headerlink" title="The Event Register"></a>The Event Register</h6><p>The Event Register is <strong>a single bit register for each processor</strong>. When set, an event register indicates that an event has<br>occurred, since the register was last cleared</p>
<p>The Event Register is set by:<br>• an SEV instruction<br>• an event sent by some IMPLEMENTATION DEFINED mechanism<br>• a debug event that causes entry into Debug state<br>• an exception return.</p>
<h6 id="The-Send-Event-instruction"><a href="#The-Send-Event-instruction" class="headerlink" title="The Send Event instruction"></a>The Send Event instruction</h6><p><strong>The Send Event instruction, SEV, causes an event to be signaled to all processors in the multiprocessor system.</strong><br><strong>ARM recommends that software includes a DSB instruction before an SEV instruction</strong></p>
<p>Execution of the Send Event instruction sets the Event Register. The Send Event instruction is available at all privilege levels</p>
<h6 id="The-Wait-For-Event-instruction"><a href="#The-Wait-For-Event-instruction" class="headerlink" title="The Wait For Event instruction"></a>The Wait For Event instruction</h6><p>The action of the Wait For Event instruction depends on the state of the Event Register:<br>• If the Event Register is set, the instruction clears the register and completes immediately. Normally, if this<br>happens the software makes another attempt to claim the lock.</p>
<p>• If the Event Register is clear the processor can suspend execution and enter a low-power state. It can remain<br>in that state until the processor detects a WFE wake-up event or a reset. When the processor detects a WFE<br>wake-up event, or earlier if the implementation chooses, the WFE instruction completes.</p>
<p>The Wait For Event instruction, WFE, is available at all privilege levels,</p>
<h5 id="B1-8-14-Wait-For-Interrupt"><a href="#B1-8-14-Wait-For-Interrupt" class="headerlink" title="B1.8.14 Wait For Interrupt"></a>B1.8.14 Wait For Interrupt</h5><p>When a processor issues a WFI instruction it can suspend execution and enter a low-power state.</p>
<p>The Virtualization Extensions provide a bit that traps to Hyp mode any attempt to enter a low-power state from a<br>Non-secure PL1 or PL0 mode.</p>
<p>The processor can remain in the WFI low-power state until it is reset, or it detects one of the following WFI wake-up<br>events:<br>• a physical IRQ interrupt, regardless of the value of the CPSR.I bit<br>• a physical FIQ interrupt, regardless of the value of the CPSR.F bit<br>• a physical asynchronous abort, regardless of the value of the CPSR.A bit<br>• in Non-secure state in any mode other than Hyp mode:<br>    — when HCR.IMO is set to 1, a virtual IRQ interrupt, regardless of the value of the CPSR.I bit<br>    — when HCR.FMO is set to 1, a virtual FIQ interrupt, regardless of the value of the CPSR.F bit<br>    — when HCR.AMO is set to 1, a virtual asynchronous abort, regardless of the value of the CPSR.A bit<br>• an asynchronous debug event, when invasive debug is enabled and the debug event is permitted.</p>
<p><strong>WFI wake-up events cannot be masked by the mask bits in the CPSR.</strong></p>
<p><strong>Using WFI to indicate an idle state on bus interfaces</strong></p>
<p><a href="http://www.wowotech.net/pm_subsystem/cpuidle_overview.html" target="_blank" rel="external">Linux cpuidle framework(1)_概述和软件架构</a></p>
<h4 id="B1-9-Exception-descriptions"><a href="#B1-9-Exception-descriptions" class="headerlink" title="B1.9 Exception descriptions"></a>B1.9 Exception descriptions</h4><p>skip</p>
<h4 id="B1-10-Coprocessors-and-system-control"><a href="#B1-10-Coprocessors-and-system-control" class="headerlink" title="B1.10 Coprocessors and system control"></a>B1.10 Coprocessors and system control</h4><p>The ARM architecture supports sixteen coprocessors, usually referred to as CP0 to CP15.<br>The architecture reserves two of these coprocessors, CP14 and CP15,<br>for configuration and control related to the architecture:<br>• CP14 is reserved for the configuration and control of:<br>    — debug features, see The CP14 debug register interface on page C6-2123<br>    — trace features, see the Embedded Trace Macrocell Architecture Specification and the CoreSight<br>    Program Flow Trace Architecture Specification<br>    — the Thumb Execution Environment, see Thumb Execution Environment on page B1-1240<br>    — direct Java bytecode execution, see Jazelle direct bytecode execution on page B1-1241.<br>• CP15 is called the System Control coprocessor, and is reserved for the control and configuration of the ARM<br>processor system, including architecture and feature identification.</p>
<p>The implementation of the CP15 registers depends heavily on whether the ARMv7 implementation is:<br>• an ARMv7-A implementation with a Virtual Memory System Architecture (VMSA)<br>• an ARMv7-R implementation with a Protected Memory System Architecture (PMSA).<br>The implementation of the CP14 registers is generally similar in ARMv7-A and ARMv7-R implementation.</p>
<p>Most CP14 and CP15 registers are accessible only from PL1 or higher. For possible accesses from PL0:<br>• The register descriptions in Chapter B4 System Control Registers in a VMSA implementation and Chapter B6<br>System Control Registers in a PMSA implementation indicate whether a register is accessible from PL0.<br>• The descriptions of the CP14 interface in Chapter C6 Debug Register Interfaces include the permitted<br>accesses to the debug registers from PL0.<br>• The following sections summarize the permitted accesses to CP15 registers from PL0:<br>    — for a VMSA implementation, PL0 views of the CP15 registers on page B3-1488<br>    — for a PMSA implementation, PL0 views of the CP15 registers on page B5-1797.</p>
<h4 id="B1-11-Advanced-SIMD-and-floating-point-support"><a href="#B1-11-Advanced-SIMD-and-floating-point-support" class="headerlink" title="B1.11 Advanced SIMD and floating-point support"></a>B1.11 Advanced SIMD and floating-point support</h4><p>skip</p>
<h4 id="B1-12-Thumb-Execution-Environment"><a href="#B1-12-Thumb-Execution-Environment" class="headerlink" title="B1.12 Thumb Execution Environment"></a>B1.12 Thumb Execution Environment</h4><p>skip</p>
<h4 id="B1-13-Jazelle-direct-bytecode-execution"><a href="#B1-13-Jazelle-direct-bytecode-execution" class="headerlink" title="B1.13 Jazelle direct bytecode execution"></a>B1.13 Jazelle direct bytecode execution</h4><p>skip</p>
<h4 id="B1-14-Traps-to-the-hypervisor"><a href="#B1-14-Traps-to-the-hypervisor" class="headerlink" title="B1.14 Traps to the hypervisor"></a>B1.14 Traps to the hypervisor</h4><h5 id="B1-14-1-General-information-about-traps-to-the-hypervisor"><a href="#B1-14-1-General-information-about-traps-to-the-hypervisor" class="headerlink" title="B1.14.1 General information about traps to the hypervisor"></a>B1.14.1 General information about traps to the hypervisor</h5><p>The Hyp Trap exception provides the standard mechanism for trapping Guest OS functions to the hypervisor.<br>and enters the exception handler using the vector at<br>offset 0x14 from the Hyp vector base address. For more information see Exception handling on page B1-1165</p>
<p>A Hyp Trap exception can be generated only when all of the following apply:<br>• The processor is both:<br>    — not in Debug state<br>    — in a Non-secure PL1 or PL0 mode.<br>• Traps to Hyp mode never apply in Secure state, regardless of the value of the SCR.NS bit.    </p>
<p>B1.14.2 Trapping ID mechanisms<br>For a small number of frequently-accessed ID registers, the Virtualization Extensions provide read/write aliases of<br>the registers, accessible only from Hyp mode, or from Secure state. A read of the original ID register from a<br>Non-secure PL1 mode actually returns the value of the read/write alias register.</p>
<p>Fixme [Table B1-26 ID register substitution by the Virtualization Extensions] page1251</p>
<p>Fixme [Table B1-27 ID register groups for Hyp Trap exceptions] page1252</p>
<p>B1.14.17 Summary of trap controls</p>
<p>Fixme [Table B1-29 Summary of Hyp trap controls] page1262</p>
<h3 id="B2-Common-Memory-System-Architecture-Features"><a href="#B2-Common-Memory-System-Architecture-Features" class="headerlink" title="B2 Common Memory System Architecture Features"></a>B2 Common Memory System Architecture Features</h3><h4 id="B2-2-Caches-and-branch-predictors"><a href="#B2-2-Caches-and-branch-predictors" class="headerlink" title="B2.2 Caches and branch predictors"></a>B2.2 Caches and branch predictors</h4><h5 id="B2-2-1-Cache-identification"><a href="#B2-2-1-Cache-identification" class="headerlink" title="B2.2.1 Cache identification"></a>B2.2.1 Cache identification</h5><p>The ARMv7 cache identification consists of a set of registers that describe the implemented caches that are under<br>the control of the processor:<br>• A single Cache Type Register defines:<br>    — the <strong>minimum line length of any of the instruction caches</strong><br>    — the <strong>minimum line length of any of the data or unified caches</strong><br>    — the <strong>cache indexing and tagging policy of the Level 1 instruction cache.</strong><br>    For more information, see:<br>    — CTR, Cache Type Register, VMSA on page B4-1556, for a VMSA implementation<br>    — CTR, Cache Type Register, PMSA on page B6-1835, for a PMSA implementation.</p>
<p>• A single Cache Level ID Register defines:<br>    — the <strong>type of cache implemented at a each cache level, up to the maximum of seven levels</strong><br>    — the Level of Coherence (LoC) for the caches<br>    — the Level of Unification (LoU) for the caches.<br>    For more information, see:<br>    — CLIDR, Cache Level ID Register, VMSA on page B4-1530, for a VMSA implementation<br>    — CLIDR, Cache Level ID Register, PMSA on page B6-1816, for a PMSA implementation</p>
<p>• A single Cache Size Selection Register selects the cache level and cache type of the current Cache Size<br>Identification Register, see:<br>    — CSSELR, Cache Size Selection Register, VMSA on page B4-1555, for a VMSA implementation<br>    — CSSELR, Cache Size Selection Register, PMSA on page B6-1834, for a PMSA implementation.    </p>
<p>• For each implemented cache, across all the levels of caching, a Cache Size Identification Register defines:<br>    — <strong>whether the cache supports Write-Through, Write-Back, Read-Allocate and Write-Allocate</strong><br>    — <strong>the number of sets, associativity and line length of the cache</strong><br>    For more information, see:<br>    — CCSIDR, Cache Size ID Registers, VMSA on page B4-1528, for a VMSA implementation<br>    — CCSIDR, Cache Size ID Registers, PMSA on page B6-1814, for a PMSA implementation.</p>
<h6 id="Identifying-the-cache-resources-in-ARMv7"><a href="#Identifying-the-cache-resources-in-ARMv7" class="headerlink" title="Identifying the cache resources in ARMv7"></a>Identifying the cache resources in ARMv7</h6><p>In ARMv7 the architecture defines support for multiple levels of cache, up to a maximum of seven levels.<br>software must:</p>
<ol>
<li><p><strong>Read the Cache Type Register to find the indexing and tagging policy used for the Level 1 instruction cache.</strong><br>This register also provides the size of the smallest cache lines used for the instruction caches, and for the data<br>and unified caches. These values are used in cache maintenance operations.</p>
</li>
<li><p><strong>Read the Cache Level ID Register to find what caches are implemented</strong>. The register includes seven Cache<br>type fields, for cache levels 1 to 7. Scanning these fields, starting from Level 1, identifies the instruction, data<br>or unified caches implemented at each level. This scan ends when it reaches a level at which no caches are<br>defined. The Cache Level ID Register also provides the Level of Unification (LoU) and the Level of<br>Coherence (LoC) for the cache implementation.</p>
</li>
<li><p>For each cache identified at stage 2:<br>• <strong>Write to the Cache Size Selection Register to select the required cache.</strong> A cache is identified by its<br>level, and whether it is:<br> — an instruction cache<br> — a data or unified cache.<br>• Read the Cache Size ID Register to find details of the cache.</p>
</li>
</ol>
<h5 id="B2-2-2-Cache-behavior"><a href="#B2-2-2-Cache-behavior" class="headerlink" title="B2.2.2 Cache behavior"></a>B2.2.2 Cache behavior</h5><h6 id="General-behavior-of-the-caches"><a href="#General-behavior-of-the-caches" class="headerlink" title="General behavior of the caches"></a>General behavior of the caches</h6><p>When a memory location is marked with a Normal Cacheable memory attribute, determining whether a copy of the<br>memory location is held in a cache still depends on many aspects of the implementation. The following<br>non-exhaustive list of factors might be involved:<br>• the size, line length, and associativity of the cache<br>• the cache allocation algorithm<br>• activity by other elements of the system that can access the memory<br>• speculative instruction fetching algorithms<br>• speculative data fetching algorithms<br>• interrupt behaviors.</p>
<p>For the purpose of these principles, a cache entry covers at least 16 bytes and no more than 2KB of contiguous<br>address space, aligned to its size.</p>
<h6 id="Behavior-of-the-caches-at-reset"><a href="#Behavior-of-the-caches-at-reset" class="headerlink" title="Behavior of the caches at reset"></a>Behavior of the caches at reset</h6><p>In ARMv7:<br>• All caches are disabled at reset.<br>• An implementation can require the use of a specific cache initialization routine to invalidate its storage array<br>before it is enabled.</p>
<p>B2.2.3 Cache enabling and disabling<br>Levels of cache on page B2-1265 indicates that:<br>• In ARMv7 the architecture defines the control of multiple levels of cache.<br>• Before ARMv7 the architecture defines the control of only one level of cache.</p>
<p>In ARMv7:<br>• SCTLR.C enables or disables all data and unified caches for data accesses, across all levels of cache visible<br>to the processor. It is IMPLEMENTATION DEFINED whether it also enables or disables the use of unified caches<br>for instruction accesses.<br>• SCTLR.I enables or disables all instruction caches, across all levels of cache visible to the processor.</p>
<pre><code>- SCTLR, System Control Register, VMSA on page B4-1707, for a VMSA implementation
- SCTLR, System Control Register, PMSA on page B6-1932, for a PMSA implementation.
</code></pre><h5 id="B2-2-4-Branch-predictors"><a href="#B2-2-4-Branch-predictors" class="headerlink" title="B2.2.4 Branch predictors"></a>B2.2.4 Branch predictors</h5><p>Branch predictor hardware typically uses a form of cache to hold branch information. The ARM architecture<br>permits this branch predictor hardware to be visible to software, and so the branch predictor is not architecturally<br>invisible. This means that under some circumstances software must perform branch predictor maintenance to avoid<br>incorrect execution caused by out-of-date entries in the branch predictor.</p>
<h6 id="Requirements-for-branch-predictor-maintenance-operations"><a href="#Requirements-for-branch-predictor-maintenance-operations" class="headerlink" title="Requirements for branch predictor maintenance operations"></a>Requirements for branch predictor maintenance operations</h6><p>the instructions at the virtual addresses change:<br>• enabling or disabling the MMU<br>• writing new mappings to the translation tables<br>• any change to the TTBR0, TTBR1, or TTBCR registers, unless accompanied by a change to the ContextID,<br>or a change to the VMID<br>• changes to the VTTBR or VTCR registers, unless accompanied by a change to the VMID.</p>
<p>then branch predictor maintenance operations must be performed to invalidate entries in the branch<br>predictor, to ensure that the change is visible to subsequent execution.</p>
<h5 id="B2-2-6-About-ARMv7-cache-and-branch-predictor-maintenance-functionality"><a href="#B2-2-6-About-ARMv7-cache-and-branch-predictor-maintenance-functionality" class="headerlink" title="B2.2.6 About ARMv7 cache and branch predictor maintenance functionality"></a>B2.2.6 About ARMv7 cache and branch predictor maintenance functionality</h5><h6 id="Terms-used-in-describing-the-maintenance-operations"><a href="#Terms-used-in-describing-the-maintenance-operations" class="headerlink" title="Terms used in describing the maintenance operations"></a>Terms used in describing the maintenance operations</h6><p>• by the address of the memory location to be maintained, referred to as operating by MVA<br>• by a mechanism that describes the location in the hardware of the cache, referred to as operating by set/way.</p>
<h6 id="Terminology-for-operations-by-MVA"><a href="#Terminology-for-operations-by-MVA" class="headerlink" title="Terminology for operations by MVA"></a>Terminology for operations by MVA</h6><p>The term Modified Virtual Address (MVA) relates to the Fast Context Switch Extension (FCSE) mechanism,described in Appendix D10 Fast Context Switch Extension (FCSE). When the FCSE is absent or disabled, the MVA and VA have the same value.</p>
<p>Virtual addresses only exist in systems with a MMU. When no MMU is implemented, or all applicable MMUs are disabled, the MVA and VA are identical to the PA.</p>
<h6 id="Terminology-for-operations-by-set-way"><a href="#Terminology-for-operations-by-set-way" class="headerlink" title="Terminology for operations by set/way"></a>Terminology for operations by set/way</h6><p>Cache maintenance operations by set/way refer to the particular structures in a cache.</p>
<p><strong>Level</strong><br>The cache level of the hierarchy.</p>
<p><strong>Set</strong><br>Each level of a cache is split up into a number of sets. Each set is a set of locations in a cache level to which an address can be assigned.</p>
<p><strong>Way</strong><br>The Associativity of a cache defines the number of locations in a set to which an address can be assigned.</p>
<h5 id="B2-2-7-Cache-and-branch-predictor-maintenance-operations"><a href="#B2-2-7-Cache-and-branch-predictor-maintenance-operations" class="headerlink" title="B2.2.7 Cache and branch predictor maintenance operations"></a>B2.2.7 Cache and branch predictor maintenance operations</h5><p>Cache and branch predictor maintenance operations are performed using accesses to CP15 c7. The following<br>sections define the encodings for these operations:<br>• Cache and branch predictor maintenance operations, VMSA on page B4-1743, for a VMSA implementation<br>• Cache and branch predictor maintenance operations, PMSA on page B6-1943, for a PMSA implementation.</p>
<h6 id="Summary-of-cache-and-branch-predictor-maintenance-operations"><a href="#Summary-of-cache-and-branch-predictor-maintenance-operations" class="headerlink" title="Summary of cache and branch predictor maintenance operations"></a>Summary of cache and branch predictor maintenance operations</h6><p><strong>Data cache and unified cache operations</strong><br>Operations by MVA<br>The data and unified cache operations by MVA are:<br>DCIMVAC   Invalidate, to point of coherency.<br>DCCMVAC   Clean, to point of coherency.<br>DCCMVAU   Clean, to point of unification.<br>DCCIMVAC  Clean and invalidate, to point of coherency.</p>
<p>Operations by set/way<br>The data and unified cache operations by set/way are:<br>DCISW     Invalidate.<br>DCCSW     Clean.<br>DCCISW    Clean and invalidate, to point of coherency.</p>
<p><strong>Instruction cache operations</strong><br>Operation by MVA<br>ICIMVAU     Invalidate, to point of unification.</p>
<p>Operations on all entries<br>The instruction cache operations that operate on all entries are:<br>ICIALLU     Invalidate all, to point of unification.<br>ICIALLUIS     Invalidate all, to point of unification, Inner Shareable.</p>
<p><strong>Branch predictor operations</strong><br>Operation by MVA<br>BPIMVA     Invalidate.</p>
<p>Operations on all entries<br>BPIALL         Invalidate all.<br>BPIALLIS     Invalidate all, Inner Shareable.</p>
<h3 id="B3-Virtual-Memory-System-Architecture-VMSA"><a href="#B3-Virtual-Memory-System-Architecture-VMSA" class="headerlink" title="B3 Virtual Memory System Architecture (VMSA)"></a>B3 Virtual Memory System Architecture (VMSA)</h3><h4 id="B3-1-About-the-VMSA"><a href="#B3-1-About-the-VMSA" class="headerlink" title="B3.1 About the VMSA"></a>B3.1 About the VMSA</h4><p>In VMSAv7, a Memory Management Unit (MMU) controls address translation, access permissions, and memory<br>attribute determination and checking.</p>
<p>Each supported stage of memory system control is provided by an MMU, with its own independent set of controls.<br>Therefore, the Extended VMSAv7 provides the following MMUs:<br>• Secure PL1&amp;0 stage 1 MMU<br>• Non-secure PL2 stage 1 MMU<br>• Non-secure PL1&amp;0 stage 1 MMU<br>• Non-secure PL1&amp;0 stage 2 MMU.</p>
<p>Fixme [Figure B3-1 VMSA translation regimes, and associated MMUs]page1309</p>
<h5 id="B3-1-1-Address-types-used-in-a-VMSA-description"><a href="#B3-1-1-Address-types-used-in-a-VMSA-description" class="headerlink" title="B3.1.1 Address types used in a VMSA description"></a>B3.1.1 Address types used in a VMSA description</h5><h6 id="Virtual-Address-VA"><a href="#Virtual-Address-VA" class="headerlink" title="Virtual Address (VA)"></a>Virtual Address (VA)</h6><p>An address used in an instruction, as a data or instruction address, is a Virtual Address (VA).<br><strong>An address held in the PC, LR, or SP, is a VA.</strong></p>
<h6 id="Modified-Virtual-Address-MVA"><a href="#Modified-Virtual-Address-MVA" class="headerlink" title="Modified Virtual Address (MVA)"></a>Modified Virtual Address (MVA)</h6><p>On an implementation that implements and uses the FCSE(Appendix D10 Fast Context Switch Extension (FCSE)), the FCSE takes a VA and transforms it to an MVA. </p>
<h6 id="Intermediate-Physical-Address-IPA"><a href="#Intermediate-Physical-Address-IPA" class="headerlink" title="Intermediate Physical Address (IPA)"></a>Intermediate Physical Address (IPA)</h6><p>In a translation regime that provides two stages of address translation, the IPA is the address after<br>the stage 1 translation, and is the input address for the stage 2 translation.</p>
<h6 id="Physical-Address-PA"><a href="#Physical-Address-PA" class="headerlink" title="Physical Address (PA)"></a>Physical Address (PA)</h6><h5 id="B3-1-2-Address-spaces-in-a-VMSA-implementation"><a href="#B3-1-2-Address-spaces-in-a-VMSA-implementation" class="headerlink" title="B3.1.2 Address spaces in a VMSA implementation"></a>B3.1.2 Address spaces in a VMSA implementation</h5><p>The ARMv7 architecture supports:<br>• A VA address space of up to 32 bits. The actual width is IMPLEMENTATION DEFINED.<br>• An IPA address space of up to 40 bits. The translation tables and associated system control registers define the width of the implemented address space.</p>
<p>Note:</p>
<blockquote>
<p>The Large Physical Address Extension defines two translation table formats. The Long-descriptor format gives access to the full 40-bit IPA or PA address space at a granularity of 4KB. The Short-descriptor format:<br>• Gives access to a 32-bit PA address space at 4KB granularity.<br>• Optionally, gives access to a 40-bit PA address space, but only at 16MB granularity.</p>
</blockquote>
<p>If an implementation includes the Security Extensions, <strong>the address maps are defined independently for Secure and Non-secure operation, providing two independent 40-bit address spaces</strong>, where:<br>• a VA accessed from Non-secure state can only be translated to the Non-secure address map<br>• a VA accessed from Secure state can be translated to either the Secure or the Non-secure address map.</p>
<h5 id="B3-1-3-About-address-translation"><a href="#B3-1-3-About-address-translation" class="headerlink" title="B3.1.3 About address translation"></a>B3.1.3 About address translation</h5><h5 id="B3-1-3-1-VMSAv7-without-the-Security-Extensions"><a href="#B3-1-3-1-VMSAv7-without-the-Security-Extensions" class="headerlink" title="B3.1.3.1. VMSAv7 without the Security Extensions"></a>B3.1.3.1. VMSAv7 without the Security Extensions</h5><p>Supports only a single PL1&amp;0 stage 1 MMU. Operation of this MMU can be split between two sets of translation tables, defined by TTBR0 and TTBR1, and controlled by TTBCR.</p>
<h5 id="B3-1-3-2-VMSAv7-with-the-Security-Extensions-but-without-the-Virtualization-Extensions"><a href="#B3-1-3-2-VMSAv7-with-the-Security-Extensions-but-without-the-Virtualization-Extensions" class="headerlink" title="B3.1.3.2. VMSAv7 with the Security Extensions but without the Virtualization Extensions"></a>B3.1.3.2. VMSAv7 with the Security Extensions but without the Virtualization Extensions</h5><p>Supports only the Secure PL1&amp;0 stage 1 MMU and the Non-secure PL1&amp;0 stage 1 MMU.</p>
<p>Operation of each of these MMUs can be split between two sets of translation tables, <strong>defined by the Secure and Non-secure copies of TTBR0 and TTBR1, and controlled by the Secure and Non-secure copies of TTBCR.</strong></p>
<p><strong>Note</strong>: Secure and Non-secure has copies of TTBR0 and TTBR1, TTBCR.</p>
<h5 id="B3-1-3-3-VMSAv7-with-Virtualization-Extensions"><a href="#B3-1-3-3-VMSAv7-with-Virtualization-Extensions" class="headerlink" title="B3.1.3.3. VMSAv7 with Virtualization Extensions"></a>B3.1.3.3. VMSAv7 with Virtualization Extensions</h5><p><strong>Secure PL1&amp;0 stage 1 MMU</strong><br>Operation of this MMU can be split between two sets of translation tables, defined by the Secure copies of TTBR0 and TTBR1, and controlled by the Secure copy of TTBCR.</p>
<p><strong>Non-secure PL2 stage 1 MMU</strong><br>The HTTBR defines the translation table for this MMU, controlled by HTCR.</p>
<p><strong>Non-secure PL1&amp;0 stage 1 MMU</strong><br>Operation of this MMU can be split between two sets of translation tables, defined by the Non-secure copies of TTBR0 and TTBR1 and controlled by the Non-secure copy of TTBCR.</p>
<p><strong>Non-secure PL1&amp;0 stage 2 control</strong><br>The VTTBR defines the translation table for this MMU, controlled by VTCR.</p>
<p>Fixme [Figure B3-2 Memory translation summary, with Virtualization Extensions]Page 1312</p>
<p>A full translation table lookup is called a translation table walk.It is performed automatically by hardware.</p>
<p><strong>Translation Lookaside Buffers (TLBs)</strong> reduce the average cost of a memory access by caching the results of translation table walks.</p>
<p>To reduce the software overhead of TLB maintenance, the VMSA distinguishes between Global pages and Process-specific pages. The <strong>Address Space Identifier (ASID)</strong> identifies pages associated with <strong>a specific process</strong> and provides a mechanism for changing process-specific tables without having to maintain the TLB tructures.</p>
<p>If an implementation includes the Virtualization Extensions, the <strong>virtual machine identifier (VMID)</strong> identifies the current virtual machine, with its own independent ASID space.</p>
<h4 id="B3-2-The-effects-of-disabling-MMUs-on-VMSA-behavior"><a href="#B3-2-The-effects-of-disabling-MMUs-on-VMSA-behavior" class="headerlink" title="B3.2 The effects of disabling MMUs on VMSA behavior"></a>B3.2 The effects of disabling MMUs on VMSA behavior</h4><p>About the VMSA on page B3-1308 defines the translation regimes and the associated MMUs. The VMSA includes<br>an enable bit for each MMU, as follows:<br>• SCTLR.M, in the Secure copy of the register, controls Secure PL1&amp;0 stage 1 MMU<br>• SCTLR.M, in the Non-secure copy of the register, controls Non-secure PL1&amp;0 stage 1 MMU<br>• HCR.VM controls Non-secure PL1&amp;0 stage 2 MMU<br>• HSCTLR.M controls Non-secure PL2 stage 1 MMU.</p>
<h5 id="B3-2-1-VMSA-behavior-when-a-stage-1-MMU-is-disabled"><a href="#B3-2-1-VMSA-behavior-when-a-stage-1-MMU-is-disabled" class="headerlink" title="B3.2.1 VMSA behavior when a stage 1 MMU is disabled"></a>B3.2.1 VMSA behavior when a stage 1 MMU is disabled</h5><h6 id="Non-secure-PL1-and-PL0-accesses-when-HCR-DC-is-set-to-1-Virtualization-Extensions"><a href="#Non-secure-PL1-and-PL0-accesses-when-HCR-DC-is-set-to-1-Virtualization-Extensions" class="headerlink" title="Non-secure PL1 and PL0 accesses when HCR.DC is set to 1, Virtualization Extensions"></a>Non-secure PL1 and PL0 accesses when HCR.DC is set to 1, Virtualization Extensions</h6><p>In an implementation that includes the Virtualization Extensions, for an access from a Non-secure PL1 or PL0 mode when HCR.DC is set to 1, the stage 1 translation assigns the Normal Non-shareable, Inner Write-Back Write-Allocate, Outer Write-Back Write-Allocate memory attributes.</p>
<h6 id="All-other-accesses"><a href="#All-other-accesses" class="headerlink" title="All other accesses"></a>All other accesses</h6><p><strong>Data access</strong><br>The stage 1 translation assigns the Strongly-Ordered memory type.</p>
<p>Note<br>This means the access is Non-cacheable. Unexpected data cache hit behavior is IMPLEMENTATION DEFINED.</p>
<p><strong>Instruction access</strong><br>The stage 1 translation assigns Normal memory attribute, with the cacheability and<br>shareability attributes determined by the value of:<br>• the Secure copy of SCTLR.I for the Secure PL1&amp;0 translation regime<br>• the Non-secure copy of SCTLR.I for the Non-secure PL1&amp;0 translation regime<br>• HSCTLR.I for the Non-secure PL2 translation regime.</p>
<h5 id="B3-2-2-VMSA-behavior-when-the-stage-2-MMU-is-disabled"><a href="#B3-2-2-VMSA-behavior-when-the-stage-2-MMU-is-disabled" class="headerlink" title="B3.2.2 VMSA behavior when the stage 2 MMU is disabled"></a>B3.2.2 VMSA behavior when the stage 2 MMU is disabled</h5><p>When the stage 2 MMU is disabled:<br>• the IPA output from the stage 1 translation maps <strong>flat to the PA</strong><br>• the memory attributes and permissions from the stage 1 translation apply to the PA.</p>
<p>If the stage 1 MMU and the stage 2 MMU are both disabled, see Behavior of instruction fetches when all associated<br>MMUs are disabled.</p>
<h4 id="B3-3-Translation-tables"><a href="#B3-3-Translation-tables" class="headerlink" title="B3.3 Translation tables"></a>B3.3 Translation tables</h4><p>VMSAv7 defines two alternative translation table formats:</p>
<p><strong>Short-descriptor format</strong><br>This is the original format defined in issue A of this Architecture Reference Manual, and is the only format supported on implementations that do not include the Large Physical Address Extension. It uses 32-bit descriptor entries in the translation tables, and provides:<br>• <strong>Up to two levels of address lookup.</strong><br>• <strong>32-bit input addresses.</strong><br>• <strong>Output addresses of up to 40 bits.</strong><br>• Support for PAs of more than 32 bits by use of supersections, with 16MB granularity.<br>• Support for No access, Client, and Manager domains.<br>• <strong>32-bit table entries.</strong></p>
<p><strong>Long-descriptor format</strong><br>The Large Physical Address Extension adds support for this format. It uses 64-bit descriptor entries in the translation tables, and provides:<br>• <strong>Up to three levels of address lookup.</strong><br>• <strong>Input addresses of up to 40 bits, when used for stage 2 translations.</strong><br>• <strong>Output addresses of up to 40 bits.</strong><br>• 4KB assignment granularity across the entire PA range.<br>• No support for domains, all memory regions are treated as in a Client domain.<br>• <strong>64-bit table entries.</strong><br>• Fixed 4KB table size, unless truncated by the size of the input address space.</p>
<p>The Large Physical Address Extension is an OPTIONAL extension, but an implementation that includes the Virtualization Extensions must also include the Large Physical Address Extension.</p>
<h5 id="B3-3-1-Translation-table-walks"><a href="#B3-3-1-Translation-table-walks" class="headerlink" title="B3.3.1 Translation table walks"></a>B3.3.1 Translation table walks</h5><p>A translation table walk occurs as the result of a TLB miss, and starts with a read of the appropriate starting-level<br>translation table.</p>
<p>The physical address of the base of the starting-level translation table is determined from the appropriate Translation<br>table base register (TTBR).</p>
<h5 id="B3-3-2-Information-returned-by-a-translation-table-lookup"><a href="#B3-3-2-Information-returned-by-a-translation-table-lookup" class="headerlink" title="B3.3.2 Information returned by a translation table lookup"></a>B3.3.2 Information returned by a translation table lookup</h5><p>If the required translation table descriptor is not held in a TLB, a translation table walk is performed to obtain the descriptor. A lookup, whether from the TLB or as the result of a translation table walk, returns both:<br>• an output address that corresponds to the input address for the lookup<br>• a set of properties that correspond to that output address.</p>
<p>The returned properties are classified as providing <strong>address map control, access controls, or region attributes.</strong></p>
<h5 id="B3-3-3-Determining-the-translation-table-base-address"><a href="#B3-3-3-Determining-the-translation-table-base-address" class="headerlink" title="B3.3.3 Determining the translation table base address"></a>B3.3.3 Determining the translation table base address</h5><p>Fixme[Figure B3-2 Memory translation summary, with Virtualization Extensions]page1312</p>
<h5 id="B3-3-4-Security-Extensions-control-of-translation-table-walks"><a href="#B3-3-4-Security-Extensions-control-of-translation-table-walks" class="headerlink" title="B3.3.4 Security Extensions control of translation table walks"></a>B3.3.4 Security Extensions control of translation table walks</h5><p>When an implementation includes the Security Extensions, two bits in the TTBCR for the current security state<br>control whether a translation table walk is performed on a TLB miss. These two bits are the:<br>• PD0 and PD1 bits, on a processor using the Short-descriptor translation table format<br>• EPD0 and EPD1 bits, on a processor using the Long-descriptor translation table format.</p>
<p>The effect of these bits is:<br>{E}PDx == 0 If a TLB miss occurs based on TTBRx, a translation table walk is performed. The current security<br>state determines whether the memory access is Secure or Non-secure.<br>{E}PDx == 1 If a TLB miss occurs based on TTBRx, a First level Translation fault is returned, and no translation<br>table walk is performed.</p>
<h5 id="B3-3-5-Access-to-the-Secure-or-Non-secure-physical-address-map"><a href="#B3-3-5-Access-to-the-Secure-or-Non-secure-physical-address-map" class="headerlink" title="B3.3.5 Access to the Secure or Non-secure physical address map"></a>B3.3.5 Access to the Secure or Non-secure physical address map</h5><p>As stated in Address spaces in a VMSA implementation on page B3-1311, a processor that implements the Security<br>Extensions implements independent Secure and Non-secure address maps. These are defined by the translation<br>tables identified by the Secure TTBR0 and TTBR1. In both translation table formats:<br>• In the Secure translation tables, the NS bit in a descriptor indicates whether the descriptor refers to the Secure<br>or the Non-secure address map:<br>NS == 0 Access the Secure physical address space.<br>NS == 1 Access the Non-secure physical address space.</p>
<h4 id="B3-5-Short-descriptor-translation-table-format"><a href="#B3-5-Short-descriptor-translation-table-format" class="headerlink" title="B3.5 Short-descriptor translation table format"></a>B3.5 Short-descriptor translation table format</h4><p>The Short-descriptor translation table format supports a memory map based on memory sections or pages:<br><strong>Supersections</strong><br>Consist of 16MB blocks of memory. Support for Supersections is optional, except that an<br>implementation that includes the Large Physical Address Extension and supports more that 32 bits<br>of Physical Address must also support Supersections to provide access to the entire Physical<br>Address space.</p>
<p><strong>Sections</strong><br>Consist of 1MB blocks of memory.</p>
<p><strong>Large pages</strong><br>Consist of 64KB blocks of memory.</p>
<p><strong>Small pages</strong><br>Consist of 4KB blocks of memory.</p>
<p>When using the Short-descriptor translation table format, two levels of translation tables are held in memory: </p>
<ul>
<li>First-level table  </li>
<li>Second-level tables  </li>
</ul>
<p>In the translation tables, in general, a descriptor is one of:<br>• an invalid or fault entry<br>• a page table entry, that points to a next-level translation table<br>• a page or section entry, that defines the memory properties for the access<br>• a reserved format.<br>Bits[1:0] of the descriptor give the primary indication of the descriptor type.</p>
<p>Fixme[Figure B3-3 General view of address translation using Short-descriptor format translation tables] Page 1325</p>
<h5 id="B3-5-1-Short-descriptor-translation-table-format-descriptors"><a href="#B3-5-1-Short-descriptor-translation-table-format-descriptors" class="headerlink" title="B3.5.1 Short-descriptor translation table format descriptors"></a>B3.5.1 Short-descriptor translation table format descriptors</h5><h6 id="Short-descriptor-translation-table-first-level-descriptor-formats"><a href="#Short-descriptor-translation-table-first-level-descriptor-formats" class="headerlink" title="Short-descriptor translation table first-level descriptor formats"></a>Short-descriptor translation table first-level descriptor formats</h6><p>Fixme [Figure B3-4 Short-descriptor first-level descriptor formats] Page1326</p>
<p>Descriptor bits[1:0] identify the descriptor type.</p>
<h6 id="Short-descriptor-translation-table-second-level-descriptor-formats"><a href="#Short-descriptor-translation-table-second-level-descriptor-formats" class="headerlink" title="Short-descriptor translation table second-level descriptor formats"></a>Short-descriptor translation table second-level descriptor formats</h6><p>Fixme [Figure B3-5 Short-descriptor second-level descriptor formats] Page1327</p>
<h5 id="B3-5-2-Memory-attributes-in-the-Short-descriptor-translation-table-format-descriptors"><a href="#B3-5-2-Memory-attributes-in-the-Short-descriptor-translation-table-format-descriptors" class="headerlink" title="B3.5.2 Memory attributes in the Short-descriptor translation table format descriptors"></a>B3.5.2 Memory attributes in the Short-descriptor translation table format descriptors</h5><p><strong>TEX[2:0], C, B</strong><br>Memory region attribute bits, see Memory region attributes on page B3-1366.<br>These bits are not present in a Page table entry</p>
<p><strong>XN bit</strong><br>The Execute-never bit. Determines whether the processor can execute software from the addressed<br>region, see Execute-never restrictions on instruction fetching on page B3-1359.<br>This bit is not present in a Page table entry.</p>
<p><strong>PXN bit, when supported</strong><br>The Privileged execute-never bit:<br>• On an implementation that does not include the Large Physical Address Extension, support<br>for the PXN bit in the Short-descriptor translation table format is OPTIONAL.<br>• On an implementation that includes the Large Physical Address Extension, the<br>Short-descriptor translation table format must include the PXN bit.</p>
<p><strong>NS bit</strong><br>Non-secure bit. If an implementation includes the Security Extensions, for memory accesses from<br>Secure state, this bit specifies whether the translated PA is in the Secure or Non-secure address map</p>
<p><strong>Domain</strong><br>Domain field, see Domains, Short-descriptor format only on page B3-1362.<br>Page table descriptor applies to all entries in the corresponding second-level translation table.</p>
<p><strong>AP[2], AP[1:0]</strong><br>Access Permissions bits, see Memory access control on page B3-1356</p>
<p><strong>S bit</strong><br>The Shareable bit.</p>
<p><strong>nG bit</strong><br>The not global bit. Determines how the translation is marked in the TLB, see Global and<br>process-specific translation table entries on page B3-1378.</p>
<h5 id="B3-5-4-Selecting-between-TTBR0-and-TTBR1-Short-descriptor-translation-table-format"><a href="#B3-5-4-Selecting-between-TTBR0-and-TTBR1-Short-descriptor-translation-table-format" class="headerlink" title="B3.5.4 Selecting between TTBR0 and TTBR1, Short-descriptor translation table format"></a>B3.5.4 Selecting between TTBR0 and TTBR1, Short-descriptor translation table format</h5><p>the value of TTBCR.N indicates the number of most significant bits of the input VA that determine whether TTBR0 or TTBR1 :<br>• If N == 0 then use TTBR0. Setting TTBCR.N to zero disables use of a second set of translation tables.<br>• if N &gt; 0 then:<br>    — if bits[31:32-N] of the input VA are all zero then use TTBR0<br>    — otherwise use TTBR1.</p>
<p>Fixme [Table B3-1 Effect of TTBCR.N on address translation, Short-descriptor format] page1330<br>Whenever TTBCR.N is nonzero, the size of the translation table addressed by TTBR1 is 16KB.</p>
<p>Fixme [Figure B3-6 How TTBCR.N controls the boundary between the TTBRs, Short-descriptor format] page1331</p>
<h5 id="B3-5-5-Translation-table-walks-when-using-the-Short-descriptor-translation-table-format"><a href="#B3-5-5-Translation-table-walks-when-using-the-Short-descriptor-translation-table-format" class="headerlink" title="B3.5.5 Translation table walks, when using the Short-descriptor translation table format"></a>B3.5.5 Translation table walks, when using the Short-descriptor translation table format</h5><h6 id="Reading-a-first-level-translation-table"><a href="#Reading-a-first-level-translation-table" class="headerlink" title="Reading a first-level translation table"></a>Reading a first-level translation table</h6><p>Fixme [Figure B3-7 Accessing first-level translation table based on TTBR0, Short-descriptor format] page1332</p>
<h6 id="The-full-translation-flow-for-Sections-Supersections-Small-pages-and-Large-pages"><a href="#The-full-translation-flow-for-Sections-Supersections-Small-pages-and-Large-pages" class="headerlink" title="The full translation flow for Sections, Supersections, Small pages and Large pages"></a>The full translation flow for Sections, Supersections, Small pages and Large pages</h6><p>Fixme [Figure B3-11 Small page address translation] page1337</p>
<h4 id="B3-6-Long-descriptor-translation-table-format"><a href="#B3-6-Long-descriptor-translation-table-format" class="headerlink" title="B3.6 Long-descriptor translation table format"></a>B3.6 Long-descriptor translation table format</h4><p>Fixme [Figure B3-12 General view of stage 1 address translation using Long-descriptor format]page1338</p>
<h5 id="B3-6-1-Long-descriptor-translation-table-format-descriptors"><a href="#B3-6-1-Long-descriptor-translation-table-format-descriptors" class="headerlink" title="B3.6.1 Long-descriptor translation table format descriptors"></a>B3.6.1 Long-descriptor translation table format descriptors</h5><p>In general, a descriptor is one of:<br>• an invalid or fault entry<br>• a table entry, that points to the next-level translation table<br>• a block entry, that defines the memory properties for the access<br>• a reserved format.</p>
<h6 id="Long-descriptor-translation-table-first-level-and-second-level-descriptor-formats"><a href="#Long-descriptor-translation-table-first-level-and-second-level-descriptor-formats" class="headerlink" title="Long-descriptor translation table first-level and second-level descriptor formats"></a>Long-descriptor translation table first-level and second-level descriptor formats</h6><p>Fixme [Figure B3-14 Long-descriptor first-level and second-level descriptor formats]page1340</p>
<h6 id="Long-descriptor-translation-table-third-level-descriptor-formats"><a href="#Long-descriptor-translation-table-third-level-descriptor-formats" class="headerlink" title="Long-descriptor translation table third-level descriptor formats"></a>Long-descriptor translation table third-level descriptor formats</h6><p>Fixme [Figure B3-15 Long-descriptor third-level descriptor formats]page1341</p>
<h5 id="B3-6-3-Control-of-Secure-or-Non-secure-memory-access-Long-descriptor-format"><a href="#B3-6-3-Control-of-Secure-or-Non-secure-memory-access-Long-descriptor-format" class="headerlink" title="B3.6.3 Control of Secure or Non-secure memory access, Long-descriptor format"></a>B3.6.3 Control of Secure or Non-secure memory access, Long-descriptor format</h5><p>In the Long-descriptor format:<br>• the NS bit relates only to the memory block or page at the output address defined by the descriptor<br>• the descriptors also include an NSTable bit, see Hierarchical control of Secure or Non-secure memory<br>accesses, Long-descriptor format.</p>
<p>NSTable == 0 The defined table address is in the Secure physical address space.<br>NSTable == 1 The defined table address is in the Non-secure physical address space.</p>
<h5 id="B3-6-4-Selecting-between-TTBR0-and-TTBR1-Long-descriptor-translation-table-format"><a href="#B3-6-4-Selecting-between-TTBR0-and-TTBR1-Long-descriptor-translation-table-format" class="headerlink" title="B3.6.4 Selecting between TTBR0 and TTBR1, Long-descriptor translation table format"></a>B3.6.4 Selecting between TTBR0 and TTBR1, Long-descriptor translation table format</h5><p>The TTBCR.T0SZ and TTBCR.T1SZ size fields control the use of TTBR0 and TTBR1,</p>
<p>Fixme [Table B3-2 Use of TTBR0 and TTBR1, Long-descriptor format]page1345</p>
<p>Fixme [Figure B3-18 Control of TTBR boundary, when TTBCR.T1SZ is zero]page1346</p>
<h5 id="B3-6-5-Long-descriptor-translation-table-format-address-lookup-levels"><a href="#B3-6-5-Long-descriptor-translation-table-format-address-lookup-levels" class="headerlink" title="B3.6.5 Long-descriptor translation table format address lookup levels"></a>B3.6.5 Long-descriptor translation table format address lookup levels</h5><p>Fixme [Table B3-3 Properties of the three levels of address lookup with Long-descriptor translation tables]page1348</p>
<h5 id="B3-6-6-Translation-table-walks-when-using-the-Long-descriptor-translation-table-format"><a href="#B3-6-6-Translation-table-walks-when-using-the-Long-descriptor-translation-table-format" class="headerlink" title="B3.6.6 Translation table walks, when using the Long-descriptor translation table format"></a>B3.6.6 Translation table walks, when using the Long-descriptor translation table format</h5><p>Example Full translation flow, starting at second-level lookup<br>Fixme [Figure B3-22 Complete Long-descriptor format stage 1 translation, starting at second level]page1355</p>
<h3 id="B3-7-Memory-access-control"><a href="#B3-7-Memory-access-control" class="headerlink" title="B3.7 Memory access control"></a>B3.7 Memory access control</h3><p>In addition to an output address, a translation table entry that refers to page or region of memory includes fields that<br>define properties of the target memory region.</p>
<h5 id="B3-7-1-Access-permissions"><a href="#B3-7-1-Access-permissions" class="headerlink" title="B3.7.1 Access permissions"></a>B3.7.1 Access permissions</h5><p>Access permission bits in a translation table descriptor control access to the corresponding memory region. The<br>Short-descriptor translation table format supports two options for defining the access permissions:<br>• three bits, AP[2:0], define the access permissions<br>• two bits, AP[2:1], define the access permissions, and AP[0] can be used as an Access flag.</p>
<p>SCTLR.AFE selects the access permissions option. Setting this bit to 1, to enable the Access flag, also selects use<br>of AP[2:1] to define access permissions</p>
<p>The Long-descriptor translation table format uses only AP[2:1] to control the access permissions, and provides an<br>AF bit for use as an Access flag</p>
<h6 id="AP-2-1-access-permissions-model"><a href="#AP-2-1-access-permissions-model" class="headerlink" title="AP[2:1] access permissions model"></a>AP[2:1] access permissions model</h6><p>Fixme [Table B3-6 VMSAv7 AP[2:1] access permissions model]page1357</p>
<h6 id="AP-2-0-access-permissions-control-Short-descriptor-format-only"><a href="#AP-2-0-access-permissions-control-Short-descriptor-format-only" class="headerlink" title="AP[2:0] access permissions control, Short-descriptor format only"></a>AP[2:0] access permissions control, Short-descriptor format only</h6><p>Fixme [Table B3-8 VMSAv7 MMU access permissions]page1358</p>
<h5 id="B3-7-2-Execute-never-restrictions-on-instruction-fetching"><a href="#B3-7-2-Execute-never-restrictions-on-instruction-fetching" class="headerlink" title="B3.7.2 Execute-never restrictions on instruction fetching"></a>B3.7.2 Execute-never restrictions on instruction fetching</h5><p>Execute-never (XN) controls provide an additional level of control on memory accesses permitted by the access<br>permissions settings. </p>
<p><strong>XN, Execute-never</strong><br>When the XN bit is 1, a Permission fault is generated if the processor attempts to execute an<br>instruction fetched from the corresponding memory region. </p>
<p><strong>PXN, Privileged execute-never</strong><br>When the PXN bit is 1, a Permission fault is generated if the processor is executing at PL1 and<br>attempts to execute an instruction fetched from the corresponding memory region. </p>
<h5 id="B3-7-3-Domains-Short-descriptor-format-only"><a href="#B3-7-3-Domains-Short-descriptor-format-only" class="headerlink" title="B3.7.3 Domains, Short-descriptor format only"></a>B3.7.3 Domains, Short-descriptor format only</h5><p>A domain is a collection of memory regions. The Short-descriptor translation table format supports 16 domains, and<br>requires the software that defines a translation table to assign each VMSA memory region to a domain. </p>
<h5 id="B3-7-4-The-Access-flag"><a href="#B3-7-4-The-Access-flag" class="headerlink" title="B3.7.4 The Access flag"></a>B3.7.4 The Access flag</h5><p>The Access flag indicates when a page or section of memory is accessed for the first time since the Access flag in<br>the corresponding translation table descriptor was set to 0</p>
<h5 id="B3-7-5-PL2-control-of-Non-secure-access-permissions"><a href="#B3-7-5-PL2-control-of-Non-secure-access-permissions" class="headerlink" title="B3.7.5 PL2 control of Non-secure access permissions"></a>B3.7.5 PL2 control of Non-secure access permissions</h5><p>Non-secure software executing at PL2 controls two sets of translation tables, both of which use the Long-descriptor<br>translation table format:<br>• The translation tables that control the Non-secure PL2 stage 1 translations. These map VAs to PAs, for<br>memory accesses made when executing in Non-secure state at PL2, and are indicated and controlled by the<br>HTTBR and HTCR.</p>
<p>The HAP[2:1] field in the stage 2 descriptors define the stage 2 access permissions<br>Fixme [Table B3-9 Stage 2 control of access permissions]page1365</p>
<h4 id="B3-8-Memory-region-attributes"><a href="#B3-8-Memory-region-attributes" class="headerlink" title="B3.8 Memory region attributes"></a>B3.8 Memory region attributes</h4><h5 id="B3-8-1-Overview-of-memory-region-attributes-for-stage-1-translations"><a href="#B3-8-1-Overview-of-memory-region-attributes-for-stage-1-translations" class="headerlink" title="B3.8.1 Overview of memory region attributes for stage 1 translations"></a>B3.8.1 Overview of memory region attributes for stage 1 translations</h5><p><strong>Memory type and attributes</strong><br>These are described either:<br>• Directly, by bits in the translation table descriptor.<br>• Indirectly, by registers referenced by bits in the table descriptor. This is described as<br>remapping the memory type and attribute description.</p>
<p>The Short-descriptor translation table format can use either of these approaches, selected by the<br>SCTLR.TRE bit:<br>TRE == 0 Remap disabled. The TEX[2:0], C, and B bits in the translation table descriptor define<br>the memory region attributes. </p>
<p>TRE == 1 Remap enabled. The TEX[0], C, and B bits in the translation table descriptor are index<br>bits to the MMU remap registers, that define the memory region attributes:<br>• the Primary Region Remap Register, PRRR<br>• the Normal Memory Remap Register, NMRR</p>
<p>The Long-descriptor translation table format always uses remapping. </p>
<p><strong>Shareability</strong><br>In the Short-descriptor translation table format, the S bit in the translation table descriptor encodes<br>whether the region is shareable. </p>
<h5 id="B3-8-2-Short-descriptor-format-memory-region-attributes-without-TEX-remap"><a href="#B3-8-2-Short-descriptor-format-memory-region-attributes-without-TEX-remap" class="headerlink" title="B3.8.2 Short-descriptor format memory region attributes, without TEX remap"></a>B3.8.2 Short-descriptor format memory region attributes, without TEX remap</h5><p>Fixme [Table B3-10 TEX, C, and B encodings when TRE == 0]page1367</p>
<p>Cacheable memory attributes, without TEX remap<br>When TEX[2] == 1, the translation table entry describes Cacheable memory, and the rest of the encoding defines<br>the Inner and Outer cache attributes:<br>TEX[1:0] Define the Outer cache attribute.<br>C, B Define the Inner cache attribute.</p>
<p>Fixme [Table B3-11 Inner and Outer cache attribute encoding]page1368</p>
<h5 id="B3-8-3-Short-descriptor-format-memory-region-attributes-with-TEX-remap"><a href="#B3-8-3-Short-descriptor-format-memory-region-attributes-with-TEX-remap" class="headerlink" title="B3.8.3 Short-descriptor format memory region attributes, with TEX remap"></a>B3.8.3 Short-descriptor format memory region attributes, with TEX remap</h5><p>• The software that defines the translation tables must program the PRRR and NMRR to define seven possible<br>memory region attributes.<br>• The TEX[0], C, and B bits of the translation table descriptors define the memory region attributes, by<br>indexing PRRR and NMRR.</p>
<p>Fixme [Table B3-12 TEX, C, and B encodings when TRE == 1]page1369</p>
<h5 id="B3-8-4-Long-descriptor-format-memory-region-attributes"><a href="#B3-8-4-Long-descriptor-format-memory-region-attributes" class="headerlink" title="B3.8.4 Long-descriptor format memory region attributes"></a>B3.8.4 Long-descriptor format memory region attributes</h5><p>the AttrIndx[2:0] field in a block or page translation table descriptor for a stage 1 translation indicates the 8-bit field in the appropriate MAIR, that specifies<br>the attributes for the corresponding memory region:<br>• AttrIndx[2] indicates the value of n in MAIRn:<br>AttrIndx[2] == 0 Use MAIR0.<br>AttrIndx[2] == 1 Use MAIR1</p>
<p>• AttrIndx[2:0] indicates the required Attr field, Attrn, where n = AttrIndx[2:0].<br>Each AttrIndx field defines, for the corresponding memory region:<br>• The memory type, Strongly-ordered, Device, or Normal.<br>• For Normal memory<br>    — the inner and outer cacheability, Non-cacheable, Write-Through, or Write-Back<br>    — for Write-Through Cacheable and Write-Back Cacheable regions, the Read-Allocate and<br>    Write-Allocate policy hints, each of which is Allocate or Do not allocate</p>
<h6 id="Shareability-Long-descriptor-format"><a href="#Shareability-Long-descriptor-format" class="headerlink" title="Shareability, Long-descriptor format"></a>Shareability, Long-descriptor format</h6><p>Fixme [Table B3-14 SH[1:0] field encoding for Normal memory, Long-descriptor format]page1373</p>
<p>For a Device or Strongly-ordered memory region, the value of the SH[1:0] field of the translation table descriptor<br>is ignored.</p>
<h4 id="B3-9-Translation-Lookaside-Buffers-TLBs"><a href="#B3-9-Translation-Lookaside-Buffers-TLBs" class="headerlink" title="B3.9 Translation Lookaside Buffers (TLBs)"></a>B3.9 Translation Lookaside Buffers (TLBs)</h4><p>Translation Lookaside Buffers (TLBs) are an implementation technique that caches translations or translation table entries.<br>TLBs avoid the requirement for every memory access to perform a translation table walk in memory. </p>
<h5 id="B3-9-1-Global-and-process-specific-translation-table-entries"><a href="#B3-9-1-Global-and-process-specific-translation-table-entries" class="headerlink" title="B3.9.1  Global and process-specific translation table entries"></a>B3.9.1  Global and process-specific translation table entries</h5><p>In a VMSA implementation, system software can divide a virtual memory map used by memory accesses at PL1 and PL0 into global and non-global regions, indicated by the nG bit in the translation table descriptors:<br>nG == 0<br>The translation is global, meaning the region is available for all processes.</p>
<p>nG == 1<br>The translation is non-global, or process-specific, meaning it relates to the current ASID, as defined by the CONTEXTIDR.</p>
<h5 id="B3-9-2-TLB-matching"><a href="#B3-9-2-TLB-matching" class="headerlink" title="B3.9.2  TLB matching"></a>B3.9.2  TLB matching</h5><h5 id="B3-9-3-TLB-behavior-at-reset"><a href="#B3-9-3-TLB-behavior-at-reset" class="headerlink" title="B3.9.3  TLB behavior at reset"></a>B3.9.3  TLB behavior at reset</h5><p>The ARMv7 architecture does not require a reset to invalidate the TLB. All TLBs are disabled from reset. All MMUs are disabled from reset, and the contents of the TLBs have no effect on address translation.</p>
<h5 id="B3-9-5-TLB-conflict-aborts"><a href="#B3-9-5-TLB-conflict-aborts" class="headerlink" title="B3.9.5  TLB conflict aborts"></a>B3.9.5  TLB conflict aborts</h5><p>The Large Physical Address Extension introduces the concept of a TLB conflict abort, and adds fault status encodings for such an abort.</p>
<p>An implementation can generate a TLB conflict abort if it detects that the address being looked up in the TLB hits multiple entries.<br>In some implementations, multiple hits in the TLB can generate a synchronous Data Abort or Prefetch Abort exception.</p>
<h4 id="B3-10-TLB-maintenance-requirements"><a href="#B3-10-TLB-maintenance-requirements" class="headerlink" title="B3.10 TLB maintenance requirements"></a>B3.10 TLB maintenance requirements</h4><h5 id="B3-10-1-General-TLB-maintenance-requirements"><a href="#B3-10-1-General-TLB-maintenance-requirements" class="headerlink" title="B3.10.1  General TLB maintenance requirements"></a>B3.10.1  General TLB maintenance requirements</h5><p><strong>The architecture defines CP15 c8 functions for TLB maintenance operations</strong>, and supports the following operations:  </p>
<ul>
<li>invalidate all unlocked entries in the TLB  </li>
<li>invalidate a single TLB entry, by MVA, or MVA and ASID for a non-global entry  </li>
<li>invalidate all TLB entries that match a specified ASID. </li>
</ul>
<p>The Multiprocessing Extensions add the following operations:<br>• invalidate all TLB entries that match a specified MVA, regardless of the ASID</p>
<h6 id="Using-break-before-make-when-updating-translation-table-entries"><a href="#Using-break-before-make-when-updating-translation-table-entries" class="headerlink" title="Using break-before-make when updating translation table entries"></a>Using break-before-make when updating translation table entries</h6><p>ARM strongly recommends the use of a break-before-make when changing translation table entries whenever multiple threads of execution can use the same translation tables and the change to the translation entries involves any of:<br>• A change of the memory type.<br>• A change of the cacheability attributes.<br>• A change of the output address (OA), if the OA of at least one of the old translation table entry and the new<br>translation table entry is writable.</p>
<p><strong>break-before-make</strong></p>
<ol>
<li>Replace the old translation table entry, and execute DSB instruction.  </li>
<li>Invalidate the translation table entry with a broadcast TLB invalidation instruction, and execute a DSB instruction  </li>
<li>Write the new translation table entry, and execute a DSB instruction   </li>
</ol>
<h5 id="B3-10-2-Maintenance-requirements-on-changing-system-control-register-values"><a href="#B3-10-2-Maintenance-requirements-on-changing-system-control-register-values" class="headerlink" title="B3.10.2 Maintenance requirements on changing system control register values"></a>B3.10.2 Maintenance requirements on changing system control register values</h5><p>The TLB contents can be influenced by control bits in a number of system control registers. </p>
<p>The system control register changes that this applies to are:<br>• any change to the NMRR, PRRR, MAIRn, or HMAIRn registers<br>• any change to the SCTLR.AFE bit, see Changing the Access flag enable<br>• any change to the SCTLR.TRE bit<br>• any change to the translation table base address in TTBR0<br>• any change to the translation table base address in TTBR1<br>• in an implementation that includes the Virtualization Extensions:<br>    — any change to the SCTLR.{WXN, UWXN} bits<br>    — any change to the SCR.SIF bit<br>    — any change to the HCR.VM bit<br>    — any change to HCR.PTW bit, see Changing HCR.PTW<br>    — any change to the HTTBR.BADDR field<br>    — any change to the VTTBR.BADDR field<br>• in an implementation that includes the Large Physical Address Extension, changing TTBCR.EAE, see<br>Changing the current Translation table format on page B3-1386<br>• when using the Short-descriptor translation table format:<br>    — any change to the RGN, IRGN, S, or NOS fields in TTBR0 or TTBR1<br>    — any change to the PD0 or PD1 fields in TTBCR<br>• when using the Long-descriptor translation table format:<br>    — any change to the TnSZ, ORGNn, IRGNn, SHn, or EPDn fields in the TTBCR, where n is 0 or 1<br>    — any change to the T0SZ, ORGN0, IRGN0, or SH0 fields in the HTCR<br>    — any change to the T0SZ, ORGN0, IRGN0, or SH0 fields in the VTCR.</p>
<h5 id="B3-10-3-Atomicity-of-register-changes-on-changing-virtual-machine"><a href="#B3-10-3-Atomicity-of-register-changes-on-changing-virtual-machine" class="headerlink" title="B3.10.3 Atomicity of register changes on changing virtual machine"></a>B3.10.3 Atomicity of register changes on changing virtual machine</h5><p>From the viewpoint of software executing in a Non-secure PL1 or PL0 mode, when there is a switch from one virtual<br>machine to another, the registers that control or affect address translation must be changed atomically. </p>
<p>This applies to the registers for:<br>• Non-secure PL1&amp;0 stage 1 address translations. This means that all of the following registers must change  atomically:<br>    — PRRR and NMRR, if using the Short-descriptor translation table format<br>    — MAIR0 and MAIR1, if using the Long-descriptor translation table format<br>    — TTBR0, TTBR1, TTBCR, DACR, and CONTEXTIDR<br>    — the SCTLR.</p>
<p><strong>These registers apply to execution in Non-secure PL1&amp;0 modes. However, when updated as part of a switch of virtual machines they are updated by software executing in Hyp mode.</strong></p>
<p>• Non-secure PL1&amp;0 stage 2 address translations. This means that all of the following registers and register<br>fields must change atomically:<br>    — VTTBR and VTCR<br>    — HMAIR0 and HMAIR1<br>    — the HSCTLR.</p>
<h5 id="B3-11-Caches-in-a-VMSA-implementation"><a href="#B3-11-Caches-in-a-VMSA-implementation" class="headerlink" title="B3.11 Caches in a VMSA implementation"></a>B3.11 Caches in a VMSA implementation</h5><p>B3.11.1 Data and unified caches<br><strong>The behavior of accesses from the same observer to different VAs, that are translated to the same PA with the same memory attributes, is fully coherent.</strong> This means these accesses behave as follows, regardless of<br>which VA is accessed:<br>• two writes to the same PA occur in program order<br>• a read of a PA returns the value of the last successful write to that PA<br>• a write to a PA that occurs, in program order, after a read of that PA, has no effect on the value returned by<br>that read.<br>The memory system behaves in this way without any requirement to use barrier or cache maintenance operations.</p>
<h4 id="B3-11-2-Instruction-caches"><a href="#B3-11-2-Instruction-caches" class="headerlink" title="B3.11.2 Instruction caches"></a>B3.11.2 Instruction caches</h4><p>In the ARM architecture, an instruction cache is a cache that is accessed only as a result of an instruction fetch.<br>Therefore, <strong>an instruction cache is never written to by any load or store instruction executed by the processor.</strong></p>
<p>The ARMv7 architecture supports three different behaviors for instruction caches:<br>• Physically-indexed, physically-tagged(PIPT) instruction caches<br>• Virtually-indexed, physically-tagged (VIPT) instruction caches<br>• ASID and VMID tagged Virtually-indexed, virtually-tagged (VIVT) instruction caches.</p>
<h5 id="B3-11-2-1-PIPT-instruction-caches-amp-VIPT-instruction-caches"><a href="#B3-11-2-1-PIPT-instruction-caches-amp-VIPT-instruction-caches" class="headerlink" title="B3.11.2.1 PIPT instruction caches &amp; VIPT instruction caches"></a>B3.11.2.1 PIPT instruction caches &amp; VIPT instruction caches</h5><p>For PIPT instruction caches, the use of memory address translation is entirely transparent to all instruction fetches<br>that are not UNPREDICTABLE.</p>
<p>An implementation that provides PIPT/VIPT instruction caches implements the IVIPT extension, see IVIPT architecture<br>extension </p>
<h5 id="B3-11-2-2-IVIPT-architecture-extension"><a href="#B3-11-2-2-IVIPT-architecture-extension" class="headerlink" title="B3.11.2.2 IVIPT architecture extension"></a>B3.11.2.2 IVIPT architecture extension</h5><p>It reduces the instruction cache maintenance requirement to the following condition:<br>• instruction cache maintenance is required only after writing new data to a physical address that holds an<br>instruction.</p>
<h5 id="B3-11-2-3-ASID-and-VMID-tagged-VIVT-instruction-caches"><a href="#B3-11-2-3-ASID-and-VMID-tagged-VIVT-instruction-caches" class="headerlink" title="B3.11.2.3 ASID and VMID tagged VIVT instruction caches"></a>B3.11.2.3 ASID and VMID tagged VIVT instruction caches</h5><p>Instruction maintenance can also be required as a result of any of the following situations:<br>• enabling or disabling the MMU<br>• writing new mappings to the translation tables<br>• any change to the TTBR0, TTBR1, or TTBCR registers, unless accompanied by a change to the ContextID,<br>or a change to the VMID<br>• changes to the VTTBR or VTCR registers, unless accompanied by a change to the VMID</p>
<h4 id="B3-12-VMSA-memory-aborts"><a href="#B3-12-VMSA-memory-aborts" class="headerlink" title="B3.12 VMSA memory aborts"></a>B3.12 VMSA memory aborts</h4><p>In a VMSAv7 implementation, the following mechanisms cause a processor to take an exception on a failed memory<br>access:<br><strong>Debug exception</strong><br>An exception caused by the debug configuration, see About debug exceptions on<br>page C4-2090.</p>
<p><strong>Alignment fault</strong><br>An Alignment fault is generated if the address used for a memory access does not have the<br>required alignment for the operation. For more information see Unaligned data access on<br>page A3-108 and Alignment faults on page B3-1402.</p>
<p><strong>MMU fault</strong><br>An MMU fault is a fault generated by the fault checking sequence for the current translation<br>regime.</p>
<p><strong>External abort</strong><br>Any memory system fault other than a Debug exception, an Alignment fault, or an MMU<br>fault</p>
<h5 id="B3-12-1-Routing-of-aborts"><a href="#B3-12-1-Routing-of-aborts" class="headerlink" title="B3.12.1 Routing of aborts"></a>B3.12.1 Routing of aborts</h5><p>A memory abort is either a Data Abort exception or a Prefetch Abort exception. The mode to which a memory abort<br>is taken depends on the reason for the exception, the mode the processor is in when it takes the exception:</p>
<p><strong>Memory aborts taken to Monitor mode</strong><br>If an implementation includes the Security Extensions, when SCR.EA is set to 1, all External aborts<br>are taken to Monitor mode. This applies to aborts taken from Secure modes and from Non-secure<br>modes. </p>
<p><strong>Memory aborts taken to Secure Abort mode</strong><br>If an implementation includes the Security Extensions, when the processor is executing in Secure<br>state, all memory aborts that are not routed to Monitor mode are taken to Secure Abort mode.</p>
<p><strong>Memory aborts taken to Hyp mode</strong><br>大致都发生在Hyp mode，Non-secure 时至少也是在stage 2 发生的错误（stage 1 VA -&gt; IPA; stage2 IPA-&gt; PA. 虚拟地址-&gt;中间地址-&gt;物理地址）</p>
<p>includes the Virtualization Extensions, the processor is executing in Non-secure state<br>• Alignment faults taken:<br>    — When the processor is in Hyp mode.<br>    — When the processor is in a PL1 or PL0 mode and the exception is generated because<br>    the Non-secure PL1&amp;0 stage 2 translation identifies the target of an unaligned access<br>    as Device or Strongly-ordered memory.<br>    — When the processor is in the PL0 mode and HCR.TGE is set to 1. For more<br>    information see Synchronous external abort, when HCR.TGE is set to 1 on<br>    page B1-1193.</p>
<p>• When the processor is using the Non-secure PL1&amp;0 translation regime:<br>    — MMU faults from stage 2 translations, for which the stage 1 translation did not cause<br>    an MMU fault.<br>    — Any abort taken during the stage 2 translation of an address accessed in a stage 1<br>    translation table walk that is not routed to Secure Monitor mode<br>• When the processor is using the Non-secure PL2 translation regime, MMU faults from<br>stage 1 translations.</p>
<p>• External aborts, if SCR.EA is set to 0 and any of the following applies:<br>    — The processor was executing in Hyp mode when it took the exception.<br>    — The processor was executing in a Non-secure PL0 or PL1 mode when it took the<br>    exception, the abort is asynchronous, and HCR.AMO is set to 1.<br>    — The processor was executing in the Non-secure PL0 mode when it took the exception,<br>    the abort is synchronous, and HCR.TGE is set to 1. For more information see<br>    Synchronous external abort, when HCR.TGE is set to 1 on page B1-1193.<br>    — The abort occurred on a stage 2 translation table walk.</p>
<p>• Debug exceptions, if HDCR.TDE is set to 1.</p>
<p><strong>Memory aborts taken to Non-secure Abort mode</strong><br>In an implementation that does not include the Security Extensions, all memory aborts are taken to<br>Abort mode.<br>Otherwise, when the processor is executing in Non-secure state, the following aborts are taken to<br>Non-secure Abort mode:<br>• When the processor is in a Non-secure PL1 or PL0 mode, Alignment faults taken for any of<br>the following reasons:<br>    — SCTLR.A is set to 1.<br>    — An instruction that does not support unaligned accesses is committed for execution,<br>    and the instruction accesses an unaligned address.<br>    — The implementation includes the Virtualization Extensions, and the PL1&amp;0 stage 1<br>    translation identifies the target of an unaligned access as Device or Strongly-ordered<br>    memory.<br>• When the processor is using the Non-secure PL1&amp;0 translation regime, MMU faults from<br>stage 1 translations.<br>• External aborts, if all of the following apply:<br>    — the abort is not on a stage 2 translation table walk<br>    — the processor is not in Hyp mode<br>    — SCR.EA is set to 0<br>    — the abort is asynchronous, and HCR.AMO is set to 0<br>    — the abort is synchronous, and HCR.TGE is set to 0• When the processor is using the Non-secure PL1&amp;0 translation regime, MMU faults from<br>stage 1 translations.<br>• External aborts, if all of the following apply:<br>    — the abort is not on a stage 2 translation table walk<br>    — the processor is not in Hyp mode<br>    — SCR.EA is set to 0<br>    — the abort is asynchronous, and HCR.AMO is set to 0<br>    — the abort is synchronous, and HCR.TGE is set to 0</p>
<h5 id="B3-12-3-The-MMU-fault-checking-sequence"><a href="#B3-12-3-The-MMU-fault-checking-sequence" class="headerlink" title="B3.12.3 The MMU fault-checking sequence"></a>B3.12.3 The MMU fault-checking sequence</h5><p>In a VMSA implementation, all memory accesses require VA to PA translation. Therefore, when a corresponding<br>MMU is enabled, each access requires a lookup of the translation table descriptor for the accessed VA. </p>
<p>When using the Short-descriptor format<br>• There are one or two levels of lookup.<br>• Lookup always starts at the first level.<br>• The final level of lookup checks the Domain field of the descriptor and:<br>    — faults if there is no access to the Domain<br>    — checks the access permissions only for Client domains.<br>When using the Long-descriptor format<br>• There are one, two, or three levels of lookup.<br>• Lookup starts at either the first level or the second level.<br>• Domains are not supported. All accesses are treated as Client domain accesses.</p>
<p>Fixme [Figure B3-23 Fetching the descriptor in a translation table walk]Page1400</p>
<p>Fixme [Figure B3-24 VMSA fault checking sequence]Page1401</p>
<p><strong>Stage 2 fault on a stage 1 translation table walk, Virtualization Extensions</strong><br>When an implementation that includes the Virtualization Extensions is operating in a Non-secure PL1 or PL0 mode,<br>any memory access goes through two stages of translation:<br>• stage 1, from VA to IPA<br>• stage 2, from IPA to PA</p>
<h5 id="B3-12-4-Alignment-faults"><a href="#B3-12-4-Alignment-faults" class="headerlink" title="B3.12.4 Alignment faults"></a>B3.12.4 Alignment faults</h5><p>The ARMv7 memory architecture requires support for strict alignment checking. This checking is controlled by<br>SCTLR.A.</p>
<p>An Alignment fault can occur on an access for which the MMU is disabled.</p>
<p><strong>In an implementation that includes the Virtualization Extensions, any unaligned access to memory region with the Device or Strongly-ordered memory type attribute generates an Alignment fault.</strong></p>
<h5 id="B3-12-5-MMU-faults"><a href="#B3-12-5-MMU-faults" class="headerlink" title="B3.12.5 MMU faults"></a>B3.12.5 MMU faults</h5><p>This section describes the faults that might be detected during one of the fault-checking sequences described in The<br>MMU fault-checking sequence.</p>
<p>The following subsections describe the MMU faults that might be detected during a fault checking sequence:<br>• External abort on a translation table walk<br>• Translation fault<br>• Access flag fault on page B3-1404<br>• Domain fault, Short-descriptor format translation tables only on page B3-1404<br>• Permission fault on page B3-1405.</p>
<p><strong>Translation fault</strong><br>A Translation fault can be generated at any level of lookup, and the reported fault code identifies the lookup level.<br>A Translation fault is generated if bits[1:0] of a translation table descriptor identify the descriptor as either a Fault<br>encoding or a reserved encoding.</p>
<p>In addition, if an implementation includes the Virtualization Extensions, then a Translation fault is generated if the<br>input address for a translation either does not map on to an address range of a Translation Table Base Register, or<br>the Translation Table Base Register range that it maps on to is disabled. </p>
<p>The architecture guarantees that any translation table entry that causes a Translation fault is not cached,</p>
<p><strong>Access flag fault</strong><br>An Access flag fault can be generated at any level of lookup,<br>• The translation tables support an Access flag bit:<br>    — the Short-descriptor format supports an Access flag only when SCTLR.AFE is set to 1<br>    — the Long-descriptor format always supports an Access flag.</p>
<p>The architecture guarantees that any translation table entry that causes an Access flag fault is not cached, meaning<br>the TLB never holds such an entry.</p>
<p><strong>Domain fault, Short-descriptor format translation tables only</strong><br>When using the Short-descriptor translation table format, a Domain fault can be generated at the first level or second<br>level of lookup.</p>
<p>When a first-level/second-level descriptor fetch returns a valid Section first-level descriptor, the domain field of<br>that descriptor is checked against the DACR. A first-level Domain fault is generated if this check<br>fails.</p>
<p>A TLB might hold a translation table entry that cause a Domain fault.</p>
<p><strong>Permission fault</strong><br>A Permission fault can be generated at any level of lookup, and the reported fault code identifies the lookup level.</p>
<p>A TLB might hold a translation table entry that cause a Permission fault. Therefore, if the handling of a Permission<br>fault results in an update to the associated translation tables, the software that updates the translation tables must<br>invalidate the appropriate TLB entry.</p>
<p>B3.12.6 External aborts<br>The ARM architecture defines external aborts as errors that occur in the memory system, other than those that are<br>detected by the MMU or Debug hardware.An external abort is one of:<br>• synchronous<br>• precise asynchronous<br>• imprecise asynchronous.</p>
<p>The ARM architecture does not provide any method to distinguish between precise asynchronous and imprecise<br>asynchronous aborts.</p>
<p>Normally, external aborts are rare. An imprecise asynchronous external abort is likely to be fatal to the process that<br>is running. </p>
<h5 id="B3-12-7-Prioritization-of-aborts"><a href="#B3-12-7-Prioritization-of-aborts" class="headerlink" title="B3.12.7 Prioritization of aborts"></a>B3.12.7 Prioritization of aborts</h5><p>prioritization decreasing in next order:</p>
<ol>
<li>Alignment fault</li>
<li>an MMU fault, on either the stage 1 translation or the stage 2 translation</li>
<li>a Watchpoint debug event.</li>
<li>an external abort</li>
</ol>
<h4 id="B3-13-Exception-reporting-in-a-VMSA-implementation"><a href="#B3-13-Exception-reporting-in-a-VMSA-implementation" class="headerlink" title="B3.13 Exception reporting in a VMSA implementation"></a>B3.13 Exception reporting in a VMSA implementation</h4><h5 id="B3-13-1-About-exception-reporting"><a href="#B3-13-1-About-exception-reporting" class="headerlink" title="B3.13.1 About exception reporting"></a>B3.13.1 About exception reporting</h5><p>In an implementation that includes the Virtualization Extensions, exceptions can be taken to:<br>• a Secure or Non-secure PL1 mode<br>• the Non-secure PL2 mode, Hyp mode.</p>
<h5 id="B3-13-2-Reporting-exceptions-taken-to-PL1-modes"><a href="#B3-13-2-Reporting-exceptions-taken-to-PL1-modes" class="headerlink" title="B3.13.2 Reporting exceptions taken to PL1 modes"></a>B3.13.2 Reporting exceptions taken to PL1 modes</h5><p><strong>Registers used for reporting exceptions taken to a PL1 mode</strong><br>ARMv7 defines the following registers, and register encodings, for exceptions taken to PL1 modes:<br>• the DFSR holds information about a Data Abort exception<br>• the DFAR holds the faulting address for some synchronous Data Abort exceptions<br>• the IFSR holds information about a Prefetch Abort exception<br>• the IFAR holds the faulting address of a Prefetch Abort exception<br>• on a Watchpoint debug exception, the DBGWFAR can hold fault information.</p>
<p><strong>Auxiliary Fault Status Registers</strong><br>The ARMv7 architecture defines the following Auxiliary Fault Status Registers:<br>• the Auxiliary Data Fault Status Register, ADFSR<br>• the Auxiliary Instruction Fault Status Register, AIFSR.</p>
<h5 id="B3-13-3-Fault-reporting-in-PL1-modes"><a href="#B3-13-3-Fault-reporting-in-PL1-modes" class="headerlink" title="B3.13.3 Fault reporting in PL1 modes"></a>B3.13.3 Fault reporting in PL1 modes</h5><p>Fixme [Table B3-23 Short-descriptor format FSR encodings] Page 1415</p>
<p>Fixme [Table B3-24 Long-descriptor format FSR encodings] Page 1416</p>
<h5 id="B3-13-5-Reporting-exceptions-taken-to-the-Non-secure-PL2-mode"><a href="#B3-13-5-Reporting-exceptions-taken-to-the-Non-secure-PL2-mode" class="headerlink" title="B3.13.5 Reporting exceptions taken to the Non-secure PL2 mode"></a>B3.13.5 Reporting exceptions taken to the Non-secure PL2 mode</h5><p><strong>Registers used for reporting exceptions taken to Hyp mode</strong><br>The Virtualization Extensions define the following registers for exceptions taken to Hyp mode:<br>• the HSR holds syndrome information for the exception<br>• the HDFAR holds the VA associated with a Data Abort exception<br>• the HIFAR holds the VA associated with a Prefetch Abort exception<br>• the HPFAR holds bits[39:12] of the IPA associated with some aborts on stage 2 address translations.</p>
<p><strong>Hyp Auxiliary Fault Syndrome Registers</strong><br>The Virtualization Extensions define the following Hyp Auxiliary Fault Syndrome Registers:<br>• the Hyp Auxiliary Data Fault Syndrome Register, HADFSR<br>• the Hyp Auxiliary Instruction Fault Syndrome Register, HAIFSR.</p>
<p>Fixme [Table B3-28 HSR.EC encodings for aborts taken to Hyp mode] Page 1422</p>
<h5 id="B3-13-6-Use-of-the-HSR"><a href="#B3-13-6-Use-of-the-HSR" class="headerlink" title="B3.13.6 Use of the HSR"></a>B3.13.6 Use of the HSR</h5><p>The HSR holds syndrome information for any synchronous exception taken to Hyp mode. Compared with the<br>reporting of exceptions taken to PL1 modes, the HSR:<br>• Always provides details of the fault. The DFSR and IFSR are not used.<br>• Provides more extensive information, for a wider range of exceptions.</p>
<p>Fixme [Figure B3-25 Format of the HSR, with subdivision of the ISS field for specified EC encodings] Page 1425</p>
<p>Fixme [Table B3-29 HSR.EC field encoding] Page 1425</p>
<p>More detail ISS encoding see arm-arm pdf</p>
<h4 id="B3-14-Virtual-Address-to-Physical-Address-translation-operation"><a href="#B3-14-Virtual-Address-to-Physical-Address-translation-operation" class="headerlink" title="B3.14 Virtual Address to Physical Address translation operation"></a>B3.14 Virtual Address to Physical Address translation operation</h4><p><strong>CP15 c7 includes operations for Virtual Address (VA) to Physical Address (PA) translation.</strong></p>
<h5 id="B3-14-1-Naming-of-the-address-translation-operations-and-operation-summary"><a href="#B3-14-1-Naming-of-the-address-translation-operations-and-operation-summary" class="headerlink" title="B3.14.1 Naming of the address translation operations, and operation summary"></a>B3.14.1 Naming of the address translation operations, and operation summary</h5><p>Fixme [Table B3-31 Naming of address translation operations] Page 1438</p>
<p>In the stage 1 current state and stages 1 and 2 Non-secure state only operations, the meanings of the last two letters<br>of the names are:</p>
<ul>
<li>PR PL1 mode, read operation.  </li>
<li>PW PL1 mode, write operation.  </li>
<li>UR PL0 mode, read operation.  </li>
<li>UW PL0 mode, write operation.</li>
</ul>
<h5 id="B3-14-2-Encoding-and-availability-of-the-address-translation-operations"><a href="#B3-14-2-Encoding-and-availability-of-the-address-translation-operations" class="headerlink" title="B3.14.2 Encoding and availability of the address translation operations"></a>B3.14.2 Encoding and availability of the address translation operations</h5><p>Software executing at PL0 never has any visibility of the address translation operations, but software executing at<br>PL1 or higher can use the unprivileged address translation operations to find the address translations used for<br>memory accesses by software executing at PL0 and PL1.</p>
<p>Fixme [Table B3-32 CP15 c7 address translation operations] Page 1440</p>
<p>The result of an operation is always returned in the PAR. The PAR is a RW register and:<br>• in all implementations, the 32-bit format PAR is accessed using an MCR or MRC instruction with CRn set to c7,<br>CRm set to c4, and opc1 and opc2 both set to 0<br>• in an implementation that includes the Large Physical Address Extension, the 64-bit format PAR is accessed<br>using an MCRR or MRRC instruction with CRm set to c7, and opc1 set to 0.</p>
<h5 id="B3-14-3-Determining-the-PAR-format-Large-Physical-Address-Extension"><a href="#B3-14-3-Determining-the-PAR-format-Large-Physical-Address-Extension" class="headerlink" title="B3.14.3 Determining the PAR format, Large Physical Address Extension"></a>B3.14.3 Determining the PAR format, Large Physical Address Extension</h5><p>The Large Physical Address Extension extends the PAR to become a 64-bit register, and supports both 32-bit and<br>64-bit PAR formats</p>
<h4 id="B3-15-About-the-system-control-registers-for-VMSA"><a href="#B3-15-About-the-system-control-registers-for-VMSA" class="headerlink" title="B3.15 About the system control registers for VMSA"></a>B3.15 About the system control registers for VMSA</h4><p>On an ARMv7-A or ARMv7-R implementation, the system control registers comprise:<br>• the registers accessed using the System Control Coprocessor, CP15<br>• registers accessed using the CP14 coprocessor, including:<br>    — debug registers<br>    — trace registers<br>    — execution environment registers.</p>
<h5 id="B3-15-3-Classification-of-system-control-registers"><a href="#B3-15-3-Classification-of-system-control-registers" class="headerlink" title="B3.15.3 Classification of system control registers"></a>B3.15.3 Classification of system control registers</h5><p><strong>Banked system control registers</strong><br>Fixme [Table B3-33 Banked CP15 registers] Page 1452</p>
<p><strong>Restricted access system control registers</strong><br>Fixme [Table B3-34 Restricted access CP15 registers] Page 1453</p>
<p><strong>PL2-mode system control registers</strong><br>Fixme [Table B3-35 Banked PL2-mode CP15 read/write registers] Page 1455</p>
<p>Fixme [Table B3-37 Banked PL2-mode CP15 write-only operations] Page 1457</p>
<p><strong>Common system control registers</strong><br>Some system control registers and operations are common to the Secure and Non-secure security states.<br>Fixme [Table B3-38 Common CP15 registers] Page 1457</p>
<h4 id="B3-16-Organization-of-the-CP14-registers-in-a-VMSA-implementation"><a href="#B3-16-Organization-of-the-CP14-registers-in-a-VMSA-implementation" class="headerlink" title="B3.16 Organization of the CP14 registers in a VMSA implementation"></a>B3.16 Organization of the CP14 registers in a VMSA implementation</h4><p>The CP14 registers provide a number of distinct control functions, covering:<br>• Debug<br>• Trace<br>• Execution environment control, for the Jazelle and ThumbEE execution environments.</p>
<p>The CP14 register encodings are classified by the {CRn, opc1, CRm, opc2} values required to access them using<br>an MCR or an MRC instruction. The opc1 value determines the primary allocation of these registers, as follows:<br>opc1==0 Debug registers.<br>opc1==1 Trace registers.<br>opc1==6 ThumbEE registers.<br>opc1==7 Jazelle registers. Can include Jazelle SUBARCHITECTURE DEFINED registers</p>
<h4 id="B3-17-Organization-of-the-CP15-registers-in-a-VMSA-implementation"><a href="#B3-17-Organization-of-the-CP15-registers-in-a-VMSA-implementation" class="headerlink" title="B3.17 Organization of the CP15 registers in a VMSA implementation"></a>B3.17 Organization of the CP15 registers in a VMSA implementation</h4><p>More precisely, the ordered set of values {CRn, opc1, CRm, opc2} determined the register order.</p>
<h5 id="B3-17-1-CP15-register-summary-by-coprocessor-register-number"><a href="#B3-17-1-CP15-register-summary-by-coprocessor-register-number" class="headerlink" title="B3.17.1 CP15 register summary by coprocessor register number"></a>B3.17.1 CP15 register summary by coprocessor register number</h5><p>Fixme [Figure B3-26 CP15 register grouping by primary coprocessor register, CRn, VMSA implementation] Page 1470</p>
<p><strong>VMSA CP15 c0 register summary, identification registers</strong><br>Fixme [Figure B3-27 CP15 c0 registers in a VMSA implementation] Page 1471</p>
<p><strong>VMSA CP15 c1 register summary, system control registers</strong><br>Fixme [Figure B3-28 CP15 c1 registers in a VMSA implementation] Page 1472</p>
<p><strong>VMSA CP15 c2 and c3 register summary, Memory protection and control registers</strong><br>Fixme [Figure B3-29 CP15 32-bit c2 and c3 registers] Page 1473</p>
<p>Fixme [Figure B3-30 CP15 64-bit c2 registers] Page 1473</p>
<p><strong>VMSA CP15 c5 and c6 register summary, Memory system fault registers</strong><br>Fixme [Figure B3-31 CP15 c5 and c6 registers in a VMSA implementation] Page 1474</p>
<p><strong>VMSA CP15 c7 register summary, Cache maintenance, address translation, and other functions</strong><br>Fixme [Figure B3-32 CP15 32-bit c7 registers in a VMSA implementation] Page 1475</p>
<p><strong>VMSA CP15 c8 register summary, TLB maintenance operations</strong><br>Fixme [Figure B3-34 CP15 c8 registers in a VMSA implementation] Page 1476</p>
<p><strong>VMSA CP15 c9 register summary, reserved for cache and TCM control and performance monitors</strong><br>Fixme [Figure B3-35 Reserved CP15 c9 encodings] Page 1477</p>
<p><strong>VMSA CP15 c10 register summary, memory remapping and TLB control registers</strong><br>Fixme [Figure B3-36 CP15 c10 registers in a VMSA implementation] Page 1478</p>
<p><strong>VMSA CP15 c11 register summary, reserved for TCM DMA registers</strong><br>Fixme [Figure B3-37 Reserved CP15 c11 encodings] Page 1478</p>
<p><strong>VMSA CP15 c12 register summary, Security Extensions registers</strong><br>Fixme [Figure B3-38 Security Extensions CP15 c12 registers] Page 1479</p>
<p><strong>VMSA CP15 c13 register summary, Process, context and thread ID registers</strong><br>On an ARMv7-A implementation, the CP15 c13 registers provide:<br>• an FCSE Process ID Register, that indicates whether the implementation includes the FCSE<br>• a Context ID Register<br>• Software Thread ID Registers.<br>Fixme [Figure B3-39 CP15 c13 registers in a VMSA implementation] Page 1479</p>
<p><strong>VMSA CP15 c14, reserved for Generic Timer Extension</strong><br>Fixme [Figure B3-40 CP15 32-bit c14 registers in a VMSA implementation that includes the Generic Timer Extension] Page 1480<br>Fixme [Figure B3-41 CP15 64-bit c14 registers in a VMSA implementation that includes the Generic Timer Extension] Page 1480</p>
<p><strong>VMSA CP15 c15 register summary, IMPLEMENTATION DEFINED registers</strong></p>
<h5 id="B3-17-2-Full-list-of-VMSA-CP15-registers-by-coprocessor-register-number"><a href="#B3-17-2-Full-list-of-VMSA-CP15-registers-by-coprocessor-register-number" class="headerlink" title="B3.17.2 Full list of VMSA CP15 registers, by coprocessor register number"></a>B3.17.2 Full list of VMSA CP15 registers, by coprocessor register number</h5><p>Fixme [Table B3-42 Summary of VMSA CP15 register descriptions, in coprocessor register number order] Page 1481</p>
<h4 id="B3-18-Functional-grouping-of-VMSAv7-system-control-registers"><a href="#B3-18-Functional-grouping-of-VMSAv7-system-control-registers" class="headerlink" title="B3.18 Functional grouping of VMSAv7 system control registers"></a>B3.18 Functional grouping of VMSAv7 system control registers</h4><h5 id="B3-18-1-Identification-registers-functional-group"><a href="#B3-18-1-Identification-registers-functional-group" class="headerlink" title="B3.18.1 Identification registers, functional group"></a>B3.18.1 Identification registers, functional group</h5><p>Fixme [Table B3-44 Identification registers, VMSA] Page 1492</p>
<h5 id="B3-18-2-Virtual-memory-control-registers-functional-group"><a href="#B3-18-2-Virtual-memory-control-registers-functional-group" class="headerlink" title="B3.18.2 Virtual memory control registers, functional group"></a>B3.18.2 Virtual memory control registers, functional group</h5><p>Fixme [Table B3-45 Virtual memory control registers, VMSA only] Page 1493</p>
<h5 id="B3-18-3-PL1-Fault-handling-registers-functional-group"><a href="#B3-18-3-PL1-Fault-handling-registers-functional-group" class="headerlink" title="B3.18.3 PL1 Fault handling registers, functional group"></a>B3.18.3 PL1 Fault handling registers, functional group</h5><p>Fixme [Table B3-46 Fault handling registers, VMSA] Page 1494</p>
<h5 id="B3-18-4-Other-system-control-registers-functional-group"><a href="#B3-18-4-Other-system-control-registers-functional-group" class="headerlink" title="B3.18.4 Other system control registers, functional group"></a>B3.18.4 Other system control registers, functional group</h5><p>Fixme [Table B3-47 Other system control registers, VMSA] Page 1494</p>
<h5 id="B3-18-5-Lockdown-DMA-and-TCM-features-functional-group-VMSA"><a href="#B3-18-5-Lockdown-DMA-and-TCM-features-functional-group-VMSA" class="headerlink" title="B3.18.5 Lockdown, DMA, and TCM features, functional group, VMSA"></a>B3.18.5 Lockdown, DMA, and TCM features, functional group, VMSA</h5><p>Fixme [Table B3-48 Lockdown, DMA, and TCM features, VMSA] Page 1495</p>
<h5 id="B3-18-6-Cache-maintenance-operations-functional-group-VMSA"><a href="#B3-18-6-Cache-maintenance-operations-functional-group-VMSA" class="headerlink" title="B3.18.6 Cache maintenance operations, functional group, VMSA"></a>B3.18.6 Cache maintenance operations, functional group, VMSA</h5><p>Fixme [Table B3-49 Cache and branch predictor maintenance operations, VMSA] Page 1496</p>
<h5 id="B3-18-7-TLB-maintenance-operations-functional-group"><a href="#B3-18-7-TLB-maintenance-operations-functional-group" class="headerlink" title="B3.18.7 TLB maintenance operations, functional group"></a>B3.18.7 TLB maintenance operations, functional group</h5><p>Fixme [Table B3-50 TLB maintenance operations, VMSA only] Page 1497</p>
<h5 id="B3-18-8-Address-translation-operations-functional-group"><a href="#B3-18-8-Address-translation-operations-functional-group" class="headerlink" title="B3.18.8 Address translation operations, functional group"></a>B3.18.8 Address translation operations, functional group</h5><p>Fixme [Table B3-51 Address translation operations, VMSA only] Page 1498</p>
<h5 id="B3-18-9-Miscellaneous-operations-functional-group"><a href="#B3-18-9-Miscellaneous-operations-functional-group" class="headerlink" title="B3.18.9 Miscellaneous operations, functional group"></a>B3.18.9 Miscellaneous operations, functional group</h5><p>Fixme [Table B3-52 Miscellaneous system control operations, VMSA only] Page 1499</p>
<h5 id="B3-18-10-Performance-Monitors-functional-group"><a href="#B3-18-10-Performance-Monitors-functional-group" class="headerlink" title="B3.18.10 Performance Monitors, functional group"></a>B3.18.10 Performance Monitors, functional group</h5><p>Fixme [Table B3-53 Performance monitors, VMSA] Page 1500</p>
<h5 id="B3-18-11-Security-Extensions-registers-functional-group"><a href="#B3-18-11-Security-Extensions-registers-functional-group" class="headerlink" title="B3.18.11 Security Extensions registers, functional group"></a>B3.18.11 Security Extensions registers, functional group</h5><p>Fixme [Table B3-54 Security Extensions registers, VMSA only] Page 1500</p>
<h5 id="B3-18-12-Virtualization-Extensions-registers-functional-group"><a href="#B3-18-12-Virtualization-Extensions-registers-functional-group" class="headerlink" title="B3.18.12 Virtualization Extensions registers, functional group"></a>B3.18.12 Virtualization Extensions registers, functional group</h5><p>Fixme [Table B3-55 Virtualization Extensions registers, VMSA with Virtualization Extensions only] Page 1501</p>
<p>Fixme [Table B3-56 Hyp mode TLB maintenance operations, VMSA with Virtualization Extensions only] Page 1502</p>
<h5 id="B3-18-13-Generic-Timer-Extension-registers"><a href="#B3-18-13-Generic-Timer-Extension-registers" class="headerlink" title="B3.18.13 Generic Timer Extension registers"></a>B3.18.13 Generic Timer Extension registers</h5><h5 id="B3-18-14-IMPLEMENTATION-DEFINED-registers-functional-group"><a href="#B3-18-14-IMPLEMENTATION-DEFINED-registers-functional-group" class="headerlink" title="B3.18.14 IMPLEMENTATION DEFINED registers, functional group"></a>B3.18.14 IMPLEMENTATION DEFINED registers, functional group</h5><p>Typically, an implementation uses CP15 c15 to provide test features, and any required configuration options that<br>are not covered by this manual.</p>
<h3 id="B4-System-Control-Registers-in-a-VMSA-implementation"><a href="#B4-System-Control-Registers-in-a-VMSA-implementation" class="headerlink" title="B4 System Control Registers in a VMSA implementation"></a>B4 System Control Registers in a VMSA implementation</h3><p>Skip</p>
<h3 id="B5-Protected-Memory-System-Architecture-PMSA"><a href="#B5-Protected-Memory-System-Architecture-PMSA" class="headerlink" title="B5 Protected Memory System Architecture (PMSA)"></a>B5 Protected Memory System Architecture (PMSA)</h3><p>Skip</p>
<h3 id="B6-System-Control-Registers-in-a-PMSA-implementation"><a href="#B6-System-Control-Registers-in-a-PMSA-implementation" class="headerlink" title="B6 System Control Registers in a PMSA implementation"></a>B6 System Control Registers in a PMSA implementation</h3><p>Skip</p>
<h3 id="B7-The-CPUID-Identification-Scheme"><a href="#B7-The-CPUID-Identification-Scheme" class="headerlink" title="B7 The CPUID Identification Scheme"></a>B7 The CPUID Identification Scheme</h3><h4 id="B7-1-Introduction-to-the-CPUID-scheme"><a href="#B7-1-Introduction-to-the-CPUID-scheme" class="headerlink" title="B7.1 Introduction to the CPUID scheme"></a>B7.1 Introduction to the CPUID scheme</h4><p>Before ARMv7, using Main ID Register:<br>• MIDR, Main ID Register, VMSA on page B4-1649<br>• MIDR, Main ID Register, PMSA on page B6-1894.</p>
<p>The ARMv7 architecture implements an extended processor, using a number of registers in CP15 c0.<br><strong>ARMv7 requires the use of this scheme, and use of the scheme is indicated by a value of 0xF in the Architecture field of the Main ID Register.</strong></p>
<p>The CPUID scheme provides information about the implemented:<br>• processor features<br>• debug features<br>• auxiliary features, in particular IMPLEMENTATION DEFINED features<br>• memory model features<br>• instruction set features.</p>
<h4 id="B7-2-The-CPUID-registers"><a href="#B7-2-The-CPUID-registers" class="headerlink" title="B7.2 The CPUID registers"></a>B7.2 The CPUID registers</h4><h5 id="B7-2-1-Organization-of-the-CPUID-registers"><a href="#B7-2-1-Organization-of-the-CPUID-registers" class="headerlink" title="B7.2.1 Organization of the CPUID registers"></a>B7.2.1 Organization of the CPUID registers</h5><p>Fixme[Figure B7-1 CPUID register encodings] Page 1951</p>
<p>Fixme[Table B7-1 CPUID register summary] Page 1952</p>
<h5 id="B7-2-2-About-the-Instruction-Set-Attribute-registers"><a href="#B7-2-2-About-the-Instruction-Set-Attribute-registers" class="headerlink" title="B7.2.2 About the Instruction Set Attribute registers"></a>B7.2.2 About the Instruction Set Attribute registers</h5><p>Fixme[Table B7-2 Alphabetic list of Instruction Set Attribute registers attribute fields] Page 1954</p>
<h3 id="B8-The-Generic-Timer"><a href="#B8-The-Generic-Timer" class="headerlink" title="B8. The Generic Timer"></a>B8. The Generic Timer</h3><h4 id="B8-1-About-the-Generic-Timer"><a href="#B8-1-About-the-Generic-Timer" class="headerlink" title="B8.1 About the Generic Timer"></a>B8.1 About the Generic Timer</h4><p>Fixme[Figure B8-1 Generic Timer example] page1960</p>
<h5 id="8-1-1-System-counter"><a href="#8-1-1-System-counter" class="headerlink" title="8.1.1 System counter"></a>8.1.1 System counter</h5><p>The Generic Timer provides a system counter with the following specification:<br><strong>Width</strong><br>At least 56 bits wide.<br>The value returned by any 64-bit read of the counter is zero-extended to 64 bits.</p>
<p><strong>Frequency</strong><br>Increments at a fixed frequency, typically in the range 1-50MHz.<br>Can support one or more alternative operating modes in which it increments by larger amounts at a<br>lower frequency, typically for power-saving.<br>Roll-over Roll-over time of not less than 40 years.</p>
<p><strong>Accuracy</strong><br>ARM does not specify a required accuracy, but recommends that the counter does not gain or lose<br>more than ten seconds in a 24-hour period.<br>Use of lower-frequency modes must not affect the implemented accuracy.</p>
<p><strong>Start-up</strong><br>Starts operating from zero.</p>
<p>The system counter must be implemented in an always-on power domain.</p>
<h6 id="Initializing-and-reading-the-system-counter-frequency"><a href="#Initializing-and-reading-the-system-counter-frequency" class="headerlink" title="Initializing and reading the system counter frequency"></a>Initializing and reading the system counter frequency</h6><p>Typically, the system drives the system counter at a fixed frequency and the CNTFRQ register must be programmed<br>to this value during the system boot process. </p>
<p>In an implementation that supports the ARM Security Extensions, only<br>software executing in a Secure PL1 mode can write to CNTFRQ.</p>
<p>Software can read the CNTFRQ register, to determine the current system counter frequency, in the following states<br>and modes:<br>• Non-secure PL2 mode.<br>• Secure and Non-secure PL1 modes.<br>• When CNTKCTL.PL0PCTEN is set to 1, Secure and Non-secure PL0 modes.</p>
<h5 id="8-1-2-The-physical-counter"><a href="#8-1-2-The-physical-counter" class="headerlink" title="8.1.2 The physical counter"></a>8.1.2 The physical counter</h5><p>The processor provides a physical counter that contains the count value of the system counter. The CNTPCT register<br>holds the current physical counter value.</p>
<p>In an implementation that includes the Virtualization Extensions, CNTPCT:<br>• Is always accessible from Secure PL1 modes, and from Non-secure Hyp mode.<br>• Is accessible from Non-secure PL1 modes only when CNTHCTL.PL1PCTEN is set to 1. When<br>CNTHCTL.PL1PCTEN is set to 0, any attempt to access CNTPCT from a Non-secure PL1 mode generates<br>a Hyp Trap exception, see Hyp Trap exception on page B1-1209.</p>
<h5 id="8-1-3-The-virtual-counter"><a href="#8-1-3-The-virtual-counter" class="headerlink" title="8.1.3 The virtual counter"></a>8.1.3 The virtual counter</h5><p>An implementation of the Generic Timer always includes a virtual counter, that indicates virtual time:<br>• In a processor implementation that does not include the Virtualization Extensions, virtual time is identical to<br>physical time, and the virtual counter contains the same value as the physical counter.<br>• In a processor implementation that includes the Virtualization Extensions, the virtual counter contains the<br>value of the physical counter minus a 64-bit virtual offset. When execu</p>
<p>CNTVCT is always accessible from Secure PL1 modes, and from Non-secure PL1 and PL2 modes</p>
<h5 id="8-1-5-Timers"><a href="#8-1-5-Timers" class="headerlink" title="8.1.5 Timers"></a>8.1.5 Timers</h5><p>The number of timers provided by an implementation of the Generic Timer depends on whether the implementation<br>includes the Security Extensions and the Virtualization Extensions, as follows:</p>
<p><strong>Security Extensions not implemented</strong><br>The implementation provides a physical timer and a virtual timer.</p>
<p><strong>Security Extensions implemented, Virtualization Extensions not implemented</strong><br>The implementation provides:  </p>
<ul>
<li>A Non-secure physical timer.  </li>
<li>A Secure physical timer.  </li>
<li>A virtual timer.</li>
</ul>
<p><strong>Virtualization Extensions implemented</strong><br>The implementation provides:</p>
<ul>
<li>A Non-secure PL1 physical timer.  </li>
<li>A Secure PL1 physical timer.  </li>
<li>A Non-secure PL2 physical timer.  </li>
<li>A virtual timer</li>
</ul>
<p>Each timer is implemented as three registers:  </p>
<ul>
<li>A 64-bit CompareValue register, that provides a 64-bit unsigned upcounter.  </li>
<li>A 32-bit TimerValue register, that provides a 32-bit signed downcounter.  </li>
<li>A 32-bit Control register.</li>
</ul>
<p>Fixme[Table B8-1 Timer registers summary for the Generic Timer] page1965</p>
<h4 id="8-2-Generic-Timer-registers-summary"><a href="#8-2-Generic-Timer-registers-summary" class="headerlink" title="8.2 Generic Timer registers summary"></a>8.2 Generic Timer registers summary</h4><p>Fixme[Table B8-2 Generic Timer registers] page1969</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/arm/" rel="tag"># arm</a>
          
            <a href="/tags/spec/" rel="tag"># spec</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/28/arm_arm/" rel="next" title="arm arm">
                <i class="fa fa-chevron-left"></i> arm arm
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/03/2019-6-8/" rel="prev" title="程序员40岁后该如何发展">
                程序员40岁后该如何发展 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="JShell07" />
            
              <p class="site-author-name" itemprop="name">JShell07</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">43</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">31</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/JShell07" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:jshell07@163.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-B-System-Level-Architecture"><span class="nav-text">Part B System Level Architecture</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#B1-System-Level-Programmers’-Model"><span class="nav-text">B1 System Level Programmers’ Model</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B1-1-About-the-System-level-programmers’-model"><span class="nav-text">B1.1 About the System level programmers’ model</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B1-2-System-level-concepts-and-terminology"><span class="nav-text">B1.2 System level concepts and terminology</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B1-2-1-Mode-state-and-privilege-level"><span class="nav-text">B1.2.1 Mode, state, and privilege level</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Mode"><span class="nav-text">Mode</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#State"><span class="nav-text">State</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Privilege-level"><span class="nav-text">Privilege level</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B1-3-ARM-processor-modes-and-ARM-core-registers"><span class="nav-text">B1.3 ARM processor modes and ARM core registers</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B1-3-1-ARM-processor-modes"><span class="nav-text">B1.3.1 ARM processor modes</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#System-mode"><span class="nav-text">System mode</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Supervisor-mode"><span class="nav-text">Supervisor mode</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Hyp-mode"><span class="nav-text">Hyp mode</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Monitor-mode"><span class="nav-text">Monitor mode</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B1-3-2-ARM-core-registers"><span class="nav-text">B1.3.2 ARM core registers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B1-3-3-Program-Status-Registers-PSRs"><span class="nav-text">B1.3.3 Program Status Registers (PSRs)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#The-Current-Program-Status-Register-CPSR"><span class="nav-text">The Current Program Status Register (CPSR)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#The-Saved-Program-Status-Registers-SPSRs"><span class="nav-text">The Saved Program Status Registers (SPSRs)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B1-3-4-ELR-hyp"><span class="nav-text">B1.3.4 ELR_hyp</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B1-4-Instruction-set-states"><span class="nav-text">B1.4 Instruction set states</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B1-5-The-Security-Extensions"><span class="nav-text">B1.5 The Security Extensions</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B1-5-1-Security-states"><span class="nav-text">B1.5.1 Security states</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Changing-from-Secure-to-Non-secure-state"><span class="nav-text">Changing from Secure to Non-secure state</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B1-6-The-Large-Physical-Address-Extension"><span class="nav-text">B1.6 The Large Physical Address Extension</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B1-7-The-Virtualization-Extensions"><span class="nav-text">B1.7 The Virtualization Extensions</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B1-7-1-Impact-of-the-Virtualization-Extensions-on-the-modes-and-exception-model"><span class="nav-text">B1.7.1 Impact of the Virtualization Extensions on the modes and exception model</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B1-8-Exception-handling"><span class="nav-text">B1.8 Exception handling</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B1-8-1-Exception-vectors-and-the-exception-base-address"><span class="nav-text">B1.8.1 Exception vectors and the exception base address</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Implementation-that-does-not-include-the-Security-Extensions-1-pair-interrupt-vectors"><span class="nav-text">Implementation that does not include the Security Extensions (1 pair interrupt vectors)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Implementation-that-includes-the-Security-Extensions-3-pair-interrupt-vectors"><span class="nav-text">Implementation that includes the Security Extensions (3 pair interrupt vectors)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Implementation-that-includes-the-Virtualization-Extensions-4-pair-interrupt-vectors"><span class="nav-text">Implementation that includes the Virtualization Extensions (4 pair interrupt vectors)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#The-vector-tables-and-exception-offsets"><span class="nav-text">The vector tables and exception offsets</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B1-8-4-Processor-mode-for-taking-exceptions"><span class="nav-text">B1.8.4 Processor mode for taking exceptions</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Exceptions-taken-to-Hyp-mode"><span class="nav-text">Exceptions taken to Hyp mode</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Asynchronous-exception-routing-controls"><span class="nav-text">Asynchronous exception routing controls</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B1-8-5-Processor-state-on-exception-entry"><span class="nav-text">B1.8.5 Processor state on exception entry</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Instruction-set-state-on-exception-entry"><span class="nav-text">Instruction set state on exception entry</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#CPSR-E-bit-value-on-exception-entr"><span class="nav-text">CPSR.E bit value on exception entr</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B1-8-6-Asynchronous-exception-masking"><span class="nav-text">B1.8.6 Asynchronous exception masking</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B1-8-7-Summaries-of-asynchronous-exception-behavior"><span class="nav-text">B1.8.7 Summaries of asynchronous exception behavior</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Asynchronous-exception-behavior-Security-Extensions-only"><span class="nav-text">Asynchronous exception behavior, Security Extensions only</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Asynchronous-exception-behavior-with-the-Virtualization-Extensions"><span class="nav-text">Asynchronous exception behavior, with the Virtualization Extensions</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B1-8-8-Routing-general-exceptions-to-Hyp-mode"><span class="nav-text">B1.8.8 Routing general exceptions to Hyp mode</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B1-8-9-Routing-Debug-exceptions-to-Hyp-mode"><span class="nav-text">B1.8.9 Routing Debug exceptions to Hyp mode</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B1-8-10-Exception-return"><span class="nav-text">B1.8.10 Exception return</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Return-from-an-exception-taken-to-a-PL1-mode"><span class="nav-text">Return from an exception taken to a PL1 mode</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Return-from-an-exception-taken-to-a-PL2-mode"><span class="nav-text">Return from an exception taken to a PL2 mode</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B1-8-11-Virtual-exceptions-in-the-Virtualization-Extensions"><span class="nav-text">B1.8.11 Virtual exceptions in the Virtualization Extensions</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B1-8-12-Low-interrupt-latency-configuration"><span class="nav-text">B1.8.12 Low interrupt latency configuration</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B1-8-13-Wait-For-Event-and-Send-Event"><span class="nav-text">B1.8.13 Wait For Event and Send Event</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#WFE-wake-up-events"><span class="nav-text">WFE wake-up events</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#The-Event-Register"><span class="nav-text">The Event Register</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#The-Send-Event-instruction"><span class="nav-text">The Send Event instruction</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#The-Wait-For-Event-instruction"><span class="nav-text">The Wait For Event instruction</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B1-8-14-Wait-For-Interrupt"><span class="nav-text">B1.8.14 Wait For Interrupt</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B1-9-Exception-descriptions"><span class="nav-text">B1.9 Exception descriptions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B1-10-Coprocessors-and-system-control"><span class="nav-text">B1.10 Coprocessors and system control</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B1-11-Advanced-SIMD-and-floating-point-support"><span class="nav-text">B1.11 Advanced SIMD and floating-point support</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B1-12-Thumb-Execution-Environment"><span class="nav-text">B1.12 Thumb Execution Environment</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B1-13-Jazelle-direct-bytecode-execution"><span class="nav-text">B1.13 Jazelle direct bytecode execution</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B1-14-Traps-to-the-hypervisor"><span class="nav-text">B1.14 Traps to the hypervisor</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B1-14-1-General-information-about-traps-to-the-hypervisor"><span class="nav-text">B1.14.1 General information about traps to the hypervisor</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B2-Common-Memory-System-Architecture-Features"><span class="nav-text">B2 Common Memory System Architecture Features</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B2-2-Caches-and-branch-predictors"><span class="nav-text">B2.2 Caches and branch predictors</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B2-2-1-Cache-identification"><span class="nav-text">B2.2.1 Cache identification</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Identifying-the-cache-resources-in-ARMv7"><span class="nav-text">Identifying the cache resources in ARMv7</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B2-2-2-Cache-behavior"><span class="nav-text">B2.2.2 Cache behavior</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#General-behavior-of-the-caches"><span class="nav-text">General behavior of the caches</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Behavior-of-the-caches-at-reset"><span class="nav-text">Behavior of the caches at reset</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B2-2-4-Branch-predictors"><span class="nav-text">B2.2.4 Branch predictors</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Requirements-for-branch-predictor-maintenance-operations"><span class="nav-text">Requirements for branch predictor maintenance operations</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B2-2-6-About-ARMv7-cache-and-branch-predictor-maintenance-functionality"><span class="nav-text">B2.2.6 About ARMv7 cache and branch predictor maintenance functionality</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Terms-used-in-describing-the-maintenance-operations"><span class="nav-text">Terms used in describing the maintenance operations</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Terminology-for-operations-by-MVA"><span class="nav-text">Terminology for operations by MVA</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Terminology-for-operations-by-set-way"><span class="nav-text">Terminology for operations by set/way</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B2-2-7-Cache-and-branch-predictor-maintenance-operations"><span class="nav-text">B2.2.7 Cache and branch predictor maintenance operations</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Summary-of-cache-and-branch-predictor-maintenance-operations"><span class="nav-text">Summary of cache and branch predictor maintenance operations</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B3-Virtual-Memory-System-Architecture-VMSA"><span class="nav-text">B3 Virtual Memory System Architecture (VMSA)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B3-1-About-the-VMSA"><span class="nav-text">B3.1 About the VMSA</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-1-1-Address-types-used-in-a-VMSA-description"><span class="nav-text">B3.1.1 Address types used in a VMSA description</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Virtual-Address-VA"><span class="nav-text">Virtual Address (VA)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Modified-Virtual-Address-MVA"><span class="nav-text">Modified Virtual Address (MVA)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Intermediate-Physical-Address-IPA"><span class="nav-text">Intermediate Physical Address (IPA)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Physical-Address-PA"><span class="nav-text">Physical Address (PA)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-1-2-Address-spaces-in-a-VMSA-implementation"><span class="nav-text">B3.1.2 Address spaces in a VMSA implementation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-1-3-About-address-translation"><span class="nav-text">B3.1.3 About address translation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-1-3-1-VMSAv7-without-the-Security-Extensions"><span class="nav-text">B3.1.3.1. VMSAv7 without the Security Extensions</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-1-3-2-VMSAv7-with-the-Security-Extensions-but-without-the-Virtualization-Extensions"><span class="nav-text">B3.1.3.2. VMSAv7 with the Security Extensions but without the Virtualization Extensions</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-1-3-3-VMSAv7-with-Virtualization-Extensions"><span class="nav-text">B3.1.3.3. VMSAv7 with Virtualization Extensions</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B3-2-The-effects-of-disabling-MMUs-on-VMSA-behavior"><span class="nav-text">B3.2 The effects of disabling MMUs on VMSA behavior</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-2-1-VMSA-behavior-when-a-stage-1-MMU-is-disabled"><span class="nav-text">B3.2.1 VMSA behavior when a stage 1 MMU is disabled</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Non-secure-PL1-and-PL0-accesses-when-HCR-DC-is-set-to-1-Virtualization-Extensions"><span class="nav-text">Non-secure PL1 and PL0 accesses when HCR.DC is set to 1, Virtualization Extensions</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#All-other-accesses"><span class="nav-text">All other accesses</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-2-2-VMSA-behavior-when-the-stage-2-MMU-is-disabled"><span class="nav-text">B3.2.2 VMSA behavior when the stage 2 MMU is disabled</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B3-3-Translation-tables"><span class="nav-text">B3.3 Translation tables</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-3-1-Translation-table-walks"><span class="nav-text">B3.3.1 Translation table walks</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-3-2-Information-returned-by-a-translation-table-lookup"><span class="nav-text">B3.3.2 Information returned by a translation table lookup</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-3-3-Determining-the-translation-table-base-address"><span class="nav-text">B3.3.3 Determining the translation table base address</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-3-4-Security-Extensions-control-of-translation-table-walks"><span class="nav-text">B3.3.4 Security Extensions control of translation table walks</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-3-5-Access-to-the-Secure-or-Non-secure-physical-address-map"><span class="nav-text">B3.3.5 Access to the Secure or Non-secure physical address map</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B3-5-Short-descriptor-translation-table-format"><span class="nav-text">B3.5 Short-descriptor translation table format</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-5-1-Short-descriptor-translation-table-format-descriptors"><span class="nav-text">B3.5.1 Short-descriptor translation table format descriptors</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Short-descriptor-translation-table-first-level-descriptor-formats"><span class="nav-text">Short-descriptor translation table first-level descriptor formats</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Short-descriptor-translation-table-second-level-descriptor-formats"><span class="nav-text">Short-descriptor translation table second-level descriptor formats</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-5-2-Memory-attributes-in-the-Short-descriptor-translation-table-format-descriptors"><span class="nav-text">B3.5.2 Memory attributes in the Short-descriptor translation table format descriptors</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-5-4-Selecting-between-TTBR0-and-TTBR1-Short-descriptor-translation-table-format"><span class="nav-text">B3.5.4 Selecting between TTBR0 and TTBR1, Short-descriptor translation table format</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-5-5-Translation-table-walks-when-using-the-Short-descriptor-translation-table-format"><span class="nav-text">B3.5.5 Translation table walks, when using the Short-descriptor translation table format</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Reading-a-first-level-translation-table"><span class="nav-text">Reading a first-level translation table</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#The-full-translation-flow-for-Sections-Supersections-Small-pages-and-Large-pages"><span class="nav-text">The full translation flow for Sections, Supersections, Small pages and Large pages</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B3-6-Long-descriptor-translation-table-format"><span class="nav-text">B3.6 Long-descriptor translation table format</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-6-1-Long-descriptor-translation-table-format-descriptors"><span class="nav-text">B3.6.1 Long-descriptor translation table format descriptors</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Long-descriptor-translation-table-first-level-and-second-level-descriptor-formats"><span class="nav-text">Long-descriptor translation table first-level and second-level descriptor formats</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Long-descriptor-translation-table-third-level-descriptor-formats"><span class="nav-text">Long-descriptor translation table third-level descriptor formats</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-6-3-Control-of-Secure-or-Non-secure-memory-access-Long-descriptor-format"><span class="nav-text">B3.6.3 Control of Secure or Non-secure memory access, Long-descriptor format</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-6-4-Selecting-between-TTBR0-and-TTBR1-Long-descriptor-translation-table-format"><span class="nav-text">B3.6.4 Selecting between TTBR0 and TTBR1, Long-descriptor translation table format</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-6-5-Long-descriptor-translation-table-format-address-lookup-levels"><span class="nav-text">B3.6.5 Long-descriptor translation table format address lookup levels</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-6-6-Translation-table-walks-when-using-the-Long-descriptor-translation-table-format"><span class="nav-text">B3.6.6 Translation table walks, when using the Long-descriptor translation table format</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B3-7-Memory-access-control"><span class="nav-text">B3.7 Memory access control</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-7-1-Access-permissions"><span class="nav-text">B3.7.1 Access permissions</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#AP-2-1-access-permissions-model"><span class="nav-text">AP[2:1] access permissions model</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#AP-2-0-access-permissions-control-Short-descriptor-format-only"><span class="nav-text">AP[2:0] access permissions control, Short-descriptor format only</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-7-2-Execute-never-restrictions-on-instruction-fetching"><span class="nav-text">B3.7.2 Execute-never restrictions on instruction fetching</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-7-3-Domains-Short-descriptor-format-only"><span class="nav-text">B3.7.3 Domains, Short-descriptor format only</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-7-4-The-Access-flag"><span class="nav-text">B3.7.4 The Access flag</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-7-5-PL2-control-of-Non-secure-access-permissions"><span class="nav-text">B3.7.5 PL2 control of Non-secure access permissions</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B3-8-Memory-region-attributes"><span class="nav-text">B3.8 Memory region attributes</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-8-1-Overview-of-memory-region-attributes-for-stage-1-translations"><span class="nav-text">B3.8.1 Overview of memory region attributes for stage 1 translations</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-8-2-Short-descriptor-format-memory-region-attributes-without-TEX-remap"><span class="nav-text">B3.8.2 Short-descriptor format memory region attributes, without TEX remap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-8-3-Short-descriptor-format-memory-region-attributes-with-TEX-remap"><span class="nav-text">B3.8.3 Short-descriptor format memory region attributes, with TEX remap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-8-4-Long-descriptor-format-memory-region-attributes"><span class="nav-text">B3.8.4 Long-descriptor format memory region attributes</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Shareability-Long-descriptor-format"><span class="nav-text">Shareability, Long-descriptor format</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B3-9-Translation-Lookaside-Buffers-TLBs"><span class="nav-text">B3.9 Translation Lookaside Buffers (TLBs)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-9-1-Global-and-process-specific-translation-table-entries"><span class="nav-text">B3.9.1  Global and process-specific translation table entries</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-9-2-TLB-matching"><span class="nav-text">B3.9.2  TLB matching</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-9-3-TLB-behavior-at-reset"><span class="nav-text">B3.9.3  TLB behavior at reset</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-9-5-TLB-conflict-aborts"><span class="nav-text">B3.9.5  TLB conflict aborts</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B3-10-TLB-maintenance-requirements"><span class="nav-text">B3.10 TLB maintenance requirements</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-10-1-General-TLB-maintenance-requirements"><span class="nav-text">B3.10.1  General TLB maintenance requirements</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Using-break-before-make-when-updating-translation-table-entries"><span class="nav-text">Using break-before-make when updating translation table entries</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-10-2-Maintenance-requirements-on-changing-system-control-register-values"><span class="nav-text">B3.10.2 Maintenance requirements on changing system control register values</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-10-3-Atomicity-of-register-changes-on-changing-virtual-machine"><span class="nav-text">B3.10.3 Atomicity of register changes on changing virtual machine</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-11-Caches-in-a-VMSA-implementation"><span class="nav-text">B3.11 Caches in a VMSA implementation</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B3-11-2-Instruction-caches"><span class="nav-text">B3.11.2 Instruction caches</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-11-2-1-PIPT-instruction-caches-amp-VIPT-instruction-caches"><span class="nav-text">B3.11.2.1 PIPT instruction caches & VIPT instruction caches</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-11-2-2-IVIPT-architecture-extension"><span class="nav-text">B3.11.2.2 IVIPT architecture extension</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-11-2-3-ASID-and-VMID-tagged-VIVT-instruction-caches"><span class="nav-text">B3.11.2.3 ASID and VMID tagged VIVT instruction caches</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B3-12-VMSA-memory-aborts"><span class="nav-text">B3.12 VMSA memory aborts</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-12-1-Routing-of-aborts"><span class="nav-text">B3.12.1 Routing of aborts</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-12-3-The-MMU-fault-checking-sequence"><span class="nav-text">B3.12.3 The MMU fault-checking sequence</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-12-4-Alignment-faults"><span class="nav-text">B3.12.4 Alignment faults</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-12-5-MMU-faults"><span class="nav-text">B3.12.5 MMU faults</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-12-7-Prioritization-of-aborts"><span class="nav-text">B3.12.7 Prioritization of aborts</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B3-13-Exception-reporting-in-a-VMSA-implementation"><span class="nav-text">B3.13 Exception reporting in a VMSA implementation</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-13-1-About-exception-reporting"><span class="nav-text">B3.13.1 About exception reporting</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-13-2-Reporting-exceptions-taken-to-PL1-modes"><span class="nav-text">B3.13.2 Reporting exceptions taken to PL1 modes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-13-3-Fault-reporting-in-PL1-modes"><span class="nav-text">B3.13.3 Fault reporting in PL1 modes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-13-5-Reporting-exceptions-taken-to-the-Non-secure-PL2-mode"><span class="nav-text">B3.13.5 Reporting exceptions taken to the Non-secure PL2 mode</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-13-6-Use-of-the-HSR"><span class="nav-text">B3.13.6 Use of the HSR</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B3-14-Virtual-Address-to-Physical-Address-translation-operation"><span class="nav-text">B3.14 Virtual Address to Physical Address translation operation</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-14-1-Naming-of-the-address-translation-operations-and-operation-summary"><span class="nav-text">B3.14.1 Naming of the address translation operations, and operation summary</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-14-2-Encoding-and-availability-of-the-address-translation-operations"><span class="nav-text">B3.14.2 Encoding and availability of the address translation operations</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-14-3-Determining-the-PAR-format-Large-Physical-Address-Extension"><span class="nav-text">B3.14.3 Determining the PAR format, Large Physical Address Extension</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B3-15-About-the-system-control-registers-for-VMSA"><span class="nav-text">B3.15 About the system control registers for VMSA</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-15-3-Classification-of-system-control-registers"><span class="nav-text">B3.15.3 Classification of system control registers</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B3-16-Organization-of-the-CP14-registers-in-a-VMSA-implementation"><span class="nav-text">B3.16 Organization of the CP14 registers in a VMSA implementation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B3-17-Organization-of-the-CP15-registers-in-a-VMSA-implementation"><span class="nav-text">B3.17 Organization of the CP15 registers in a VMSA implementation</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-17-1-CP15-register-summary-by-coprocessor-register-number"><span class="nav-text">B3.17.1 CP15 register summary by coprocessor register number</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-17-2-Full-list-of-VMSA-CP15-registers-by-coprocessor-register-number"><span class="nav-text">B3.17.2 Full list of VMSA CP15 registers, by coprocessor register number</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B3-18-Functional-grouping-of-VMSAv7-system-control-registers"><span class="nav-text">B3.18 Functional grouping of VMSAv7 system control registers</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-18-1-Identification-registers-functional-group"><span class="nav-text">B3.18.1 Identification registers, functional group</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-18-2-Virtual-memory-control-registers-functional-group"><span class="nav-text">B3.18.2 Virtual memory control registers, functional group</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-18-3-PL1-Fault-handling-registers-functional-group"><span class="nav-text">B3.18.3 PL1 Fault handling registers, functional group</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-18-4-Other-system-control-registers-functional-group"><span class="nav-text">B3.18.4 Other system control registers, functional group</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-18-5-Lockdown-DMA-and-TCM-features-functional-group-VMSA"><span class="nav-text">B3.18.5 Lockdown, DMA, and TCM features, functional group, VMSA</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-18-6-Cache-maintenance-operations-functional-group-VMSA"><span class="nav-text">B3.18.6 Cache maintenance operations, functional group, VMSA</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-18-7-TLB-maintenance-operations-functional-group"><span class="nav-text">B3.18.7 TLB maintenance operations, functional group</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-18-8-Address-translation-operations-functional-group"><span class="nav-text">B3.18.8 Address translation operations, functional group</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-18-9-Miscellaneous-operations-functional-group"><span class="nav-text">B3.18.9 Miscellaneous operations, functional group</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-18-10-Performance-Monitors-functional-group"><span class="nav-text">B3.18.10 Performance Monitors, functional group</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-18-11-Security-Extensions-registers-functional-group"><span class="nav-text">B3.18.11 Security Extensions registers, functional group</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-18-12-Virtualization-Extensions-registers-functional-group"><span class="nav-text">B3.18.12 Virtualization Extensions registers, functional group</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-18-13-Generic-Timer-Extension-registers"><span class="nav-text">B3.18.13 Generic Timer Extension registers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B3-18-14-IMPLEMENTATION-DEFINED-registers-functional-group"><span class="nav-text">B3.18.14 IMPLEMENTATION DEFINED registers, functional group</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B4-System-Control-Registers-in-a-VMSA-implementation"><span class="nav-text">B4 System Control Registers in a VMSA implementation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B5-Protected-Memory-System-Architecture-PMSA"><span class="nav-text">B5 Protected Memory System Architecture (PMSA)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B6-System-Control-Registers-in-a-PMSA-implementation"><span class="nav-text">B6 System Control Registers in a PMSA implementation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B7-The-CPUID-Identification-Scheme"><span class="nav-text">B7 The CPUID Identification Scheme</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B7-1-Introduction-to-the-CPUID-scheme"><span class="nav-text">B7.1 Introduction to the CPUID scheme</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B7-2-The-CPUID-registers"><span class="nav-text">B7.2 The CPUID registers</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B7-2-1-Organization-of-the-CPUID-registers"><span class="nav-text">B7.2.1 Organization of the CPUID registers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B7-2-2-About-the-Instruction-Set-Attribute-registers"><span class="nav-text">B7.2.2 About the Instruction Set Attribute registers</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B8-The-Generic-Timer"><span class="nav-text">B8. The Generic Timer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B8-1-About-the-Generic-Timer"><span class="nav-text">B8.1 About the Generic Timer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#8-1-1-System-counter"><span class="nav-text">8.1.1 System counter</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Initializing-and-reading-the-system-counter-frequency"><span class="nav-text">Initializing and reading the system counter frequency</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-1-2-The-physical-counter"><span class="nav-text">8.1.2 The physical counter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-1-3-The-virtual-counter"><span class="nav-text">8.1.3 The virtual counter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-1-5-Timers"><span class="nav-text">8.1.5 Timers</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-Generic-Timer-registers-summary"><span class="nav-text">8.2 Generic Timer registers summary</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JShell07</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.3.8</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  





  
  







  



  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/reading_progress/reading_progress.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
