<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="GICv2">
<meta name="keywords" content="arm,spec,GICv2">
<meta property="og:type" content="article">
<meta property="og:title" content="arm gicv2">
<meta property="og:url" content="http://yoursite.com/2019/04/20/arm_gic/index.html">
<meta property="og:site_name" content="JShell07&#39;s Blog">
<meta property="og:description" content="GICv2">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-07-03T03:43:37.414Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="arm gicv2">
<meta name="twitter:description" content="GICv2">






  <link rel="canonical" href="http://yoursite.com/2019/04/20/arm_gic/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>arm gicv2 | JShell07's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JShell07's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />Tags<span class="badge">38</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories<span class="badge">17</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives<span class="badge">46</span></a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />Search</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  
    <div class="reading-progress-bar"></div>
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/20/arm_gic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JShell07">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JShell07's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">arm gicv2
              
            
          </h1>
        

        <div class="post-meta">
	  
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-20 13:55:44" itemprop="dateCreated datePublished" datetime="2019-04-20T13:55:44+08:00">2019-04-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-03 11:43:37" itemprop="dateModified" datetime="2019-07-03T11:43:37+08:00">2019-07-03</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/arm/" itemprop="url" rel="index"><span itemprop="name">arm</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>GICv2<br><a id="more"></a></p>
<p>##1. Introduction<br>About the Generic Interrupt Controller architecture<br>The Generic Interrupt Controller (GIC) architecture defines:<br>• the architectural requirements for handling all interrupt sources for any processor connected to a GIC<br>• a common interrupt controller programming interface applicable to uniprocessor or multiprocessor systems</p>
<p>The architecture describes a GIC designed for use with one or more processors that comply with the ARM A and R<br>architecture profiles.</p>
<p>The GIC is a centralized resource for supporting and managing interrupts in a system that includes at least one<br>processor. It provides:<br>• registers for managing interrupt sources, interrupt behavior, and interrupt routing to one or more processors<br>• support for:<br>    — the ARM architecture Security Extensions<br>    — the ARM architecture Virtualization Extensions<br>    — enabling, disabling, and generating processor interrupts from hardware (peripheral) interrupt sources<br>    — Software-generated Interrupts (SGIs)<br>    — interrupt masking and prioritization<br>    — uniprocessor and multiprocessor environments<br>    — wakeup events in power-management environments.</p>
<p>The GIC includes interrupt grouping functionality that supports:<br>• configuring each interrupt as either Group 0 or Group 1<br>• signaling Group 0 interrupts to the target processor using either the IRQ or the FIQ exception request<br>• signaling Group 1 interrupts to the target processor using the IRQ exception request only<br>• a unified scheme for handling the priority of Group 0 and Group 1 interrupts<br>• optional lockdown of the configuration of some Group 0 interrupts.</p>
<p>fiq 优先级比 irq 高<br>fiq 模式下寄存器 比 irq 模式多（R8 ~ R12）<br><a href="http://blog.chinaunix.net/attachment/201302/21/28458801_1361445566H9Z3.png" target="_blank" rel="noopener">http://blog.chinaunix.net/attachment/201302/21/28458801_1361445566H9Z3.png</a></p>
<h3 id="1-2-Security-Extensions-support"><a href="#1-2-Security-Extensions-support" class="headerlink" title="1.2. Security Extensions support"></a>1.2. Security Extensions support</h3><p>The ARM processor Security Extensions are an optional extension to the ARMv7-A architecture profile.</p>
<p>ARM Security Extensions facilitate the development of secure applications by:<br>• integrating hardware security features into the architecture<br>• providing Secure virtual memory space that is accessed by memory accesses in the Secure state<br>• providing Non-secure virtual memory space that is accessed by memory accesses in the Non-secure state.</p>
<p>When a GIC that implements the GIC Security Extensions is connected to a processor that implements the ARM<br>Security Extensions:<br>• Group 0(IRQ/FIQ) interrupts are Secure interrupts, and Group 1(IRQ) interrupts are Non-secure interrupts.</p>
<p>Processor security state and Secure and Non-secure GIC accesses：<br>• a processor in Non-secure state can make only Non-secure accesses to a GIC<br>• a processor in Secure state can make both Secure and Non-secure accesses to a GIC</p>
<h3 id="1-3-Virtualization-support"><a href="#1-3-Virtualization-support" class="headerlink" title="1.3. Virtualization support"></a>1.3. Virtualization support</h3><p>The ARM processor Virtualization Extensions are optional extensions to the ARMv7-A architecture profile. The GIC Virtualization Extensions provide mechanisms to minimize the hypervisor overhead of routing interrupts to virtual machines.</p>
<p>The processor Virtualization Extensions provide hardware support for virtualizing the Non-secure state of an<br>VMSAv7 implementation. The extensions support system use of a virtual machine monitor, known as the<br>hypervisor, to switch guest operating systems.</p>
<p>Whether implemented in a uniprocessor or in a multiprocessor system, the processor Virtualization Extensions<br>support running multiple virtual machines on a single processor.</p>
<p>The hypervisor can either handle a physical interrupt itself, or generate a corresponding virtual interrupt that is signaled to a virtual machine. It is also possible for the hypervisor to generate virtual interrupts that do not correspond to physical interrupts.</p>
<p>1) physical interrupt =&gt; virtual machine =&gt; virtual interrupt （产生与硬件相应的虚拟中断）<br>2) virtual machine =&gt; virtual interrupt （也可以产生与硬件中断没有关的虚拟中断）</p>
<h3 id="1-4-Terminology-（专用名词）"><a href="#1-4-Terminology-（专用名词）" class="headerlink" title="1.4. Terminology （专用名词）"></a>1.4. Terminology （专用名词）</h3><h4 id="1-4-1-Interrupt-states"><a href="#1-4-1-Interrupt-states" class="headerlink" title="1.4.1. Interrupt states"></a>1.4.1. Interrupt states</h4><p>Inactive            An interrupt that is not active or pending.</p>
<p>Pending             An interrupt from a source to the GIC that is recognized as asserted in hardware, or<br>                    generated by software, and is waiting to be serviced by a target processor.</p>
<p>Active                 An interrupt from a source to the GIC that has been acknowledged by a processor, and is<br>                    being serviced but has not completed.</p>
<p>Active and pending     A processor is servicing the interrupt and the GIC has a pending interrupt from the same<br>source.</p>
<h4 id="1-4-2-Interrupt-types"><a href="#1-4-2-Interrupt-types" class="headerlink" title="1.4.2. Interrupt types"></a>1.4.2. Interrupt types</h4><p>Peripheral interrupt</p>
<pre><code>Private Peripheral Interrupt (PPI)
This is a peripheral interrupt that is specific to a single processor.

Shared Peripheral Interrupt (SPI)
This is a peripheral interrupt that the Distributor can route to any of a specified
combination of processors.

Each peripheral interrupt is either:
Edge-triggered
    This is an interrupt that is asserted on detection of a rising edge of an interrupt
    signal and then, regardless of the state of the signal, remains asserted until it is
    cleared by the conditions defined by this specification.

Level-sensitive
    This is an interrupt that is asserted whenever the interrupt signal level is active,
    and deasserted whenever the level is not active.
</code></pre><p>Software-generated interrupt (SGI)<br>        This is an interrupt generated by software writing to a GICD_SGIR register in the GIC.The<br>        system uses SGIs for interprocessor communication.</p>
<pre><code>When an SGI occurs in a multiprocessor implementation, the CPUID field in the Interrupt
Acknowledge Register, GICC_IAR, or the Aliased Interrupt Acknowledge Register,
GICC_AIAR, identifies the processor that requested the interrupt.

__An SGI has edge-triggered properties__. （边缘触发）

In an implementation that includes the GIC Virtualization Extensions:
• when an SGI occurs, management registers in the GIC virtualization Extensions
enable the requesting processor to be reported to the Guest OS, as required by the
GIC specifications
• by writing to the management registers in the GIC Virtualization Extensions, a
hypervisor can generate a virtual interrupt that appears to a virtual machine as an SGI.
</code></pre><p>Virtual interrupt<br>    In a GIC that implements the GIC Virtualization Extensions, an interrupt that targets a<br>    virtual machine running on a processor, and is typically signaled to the processor by the<br>    connected virtual CPU interface.        </p>
<p>Maintenance interrupt<br>    In a GIC that implements the GIC Virtualization Extensions, a level-sensitive interrupt that<br>    is used to signal key events, such as a particular group of interrupts becoming enabled or<br>    disabled. See Maintenance interrupts on page 5-164 for more information.    </p>
<h4 id="1-4-3-Models-for-handling-interrupts"><a href="#1-4-3-Models-for-handling-interrupts" class="headerlink" title="1.4.3. Models for handling interrupts"></a>1.4.3. Models for handling interrupts</h4><p>1-N model 常规硬件中断，单个的SPI， PPI<br>    Only one processor handles this interrupt. The system must implement a mechanism to determine<br>    which processor handles an interrupt that is programmed to target more than one processor.</p>
<p>N-N model 主要SGI， SPI可能会出现<br>    All processors receive the interrupt independently. When a processor acknowledges the interrupt,<br>    the interrupt pending state is cleared only for that processor. The interrupt remains pending for the<br>    other processors.</p>
<h4 id="1-4-4-Spurious-interrupts-（假的中断）"><a href="#1-4-4-Spurious-interrupts-（假的中断）" class="headerlink" title="1.4.4. Spurious interrupts （假的中断）"></a>1.4.4. Spurious interrupts （假的中断）</h4><p>It is possible that an interrupt that the GIC has signaled to a processor is no longer required.If this happens, when<br>the processor acknowledges the interrupt, the GIC returns a special Interrupt ID(1020 ~ 1023) that identifies the interrupt as a<br>spurious interrupt.</p>
<p>Example reasons for spurious interrupts are:<br>• prior to the processor acknowledging an interrupt:<br>— software changes the priority of the interrupt<br>— software disables the interrupt<br>— software changes the processor that the interrupt targets<br>• for a 1-N interrupt, another target processor has previously acknowledged that interrupt.</p>
<h2 id="2-GIC-Partitioning"><a href="#2-GIC-Partitioning" class="headerlink" title="2. GIC Partitioning"></a>2. GIC Partitioning</h2><h3 id="2-1-About-GIC-partitioning"><a href="#2-1-About-GIC-partitioning" class="headerlink" title="2.1 About GIC partitioning"></a>2.1 About GIC partitioning</h3><p>The GIC architecture splits logically into a Distributor block and one or more CPU interface blocks. The GIC<br>Virtualization Extensions add one or more virtual CPU interfaces to the GIC.</p>
<p>GIC 架构有1个GIC Distributor, 一个或多个CPU Interface， 一个或多个virtual CPU interface（GIC Virtualization Extensions support）</p>
<p>Distributor<br>    The Distributor block performs interrupt prioritization and distribution to the CPU interface<br>    blocks that connect to the processors in the system.<br>    The Distributor block registers are identified by the GICD_ prefix.</p>
<p>CPU interfaces<br>    Each CPU interface block performs priority masking and preemption handling for a<br>    connected processor in the system.</p>
<pre><code>When describing a GIC that includes the GIC Virtualization Extensions, a CPU interface is
sometimes called a physical CPU interface, to avoid possible confusion with a virtual CPU
interface.

CPU interface block registers are identified by the GICC_ prefix.
</code></pre><p>Virtual CPU interfaces<br>    Each virtual CPU interface is partitioned into the following blocks:</p>
<pre><code>Virtual interface control
    The main component of the virtual interface control block is the GIC virtual
    interface control registers, that include a list of active and pending virtual
    interrupts for the current virtual machine on the connected processor. 

    Typically, these registers are managed by the hypervisor that is running on that processor.

    Virtual interface control block registers are identified by the GICH_ prefix.

Virtual CPU interface
    Each virtual CPU interface block provides physical signaling of virtual
    interrupts to the connected processor. The ARM processor Virtualization
    Extensions signal these interrupts to the current virtual machine on that
    processor. 

    The GIC virtual CPU interface registers, accessed by the virtual
    machine, provide interrupt control and status information for the virtual
    interrupts. The format of these registers is similar to the format of the physical
    CPU interface registers.

    Virtual CPU interface block registers are identified by the GICV_ prefix.
</code></pre><p> Note: The virtual CPU interface does not support the power management functionality described</p>
<p> A GIC can implement up to eight CPU interfaces, numbered from 0-7.<br> In a GIC that implements the GIC Virtualization Extensions, virtual CPU interface numbering corresponds to the CPU interface numbering, so that<br>CPU interface 0 and virtual CPU interface 0 connect to the same processor.</p>
<p>一个GIC 最多支持8个CPU， 而 physical CPU interface 与virtual CPU interface 个数对应一样多。</p>
<p>FixMe： 补上GIC logical partitioning</p>
<h3 id="2-2-The-Distributor"><a href="#2-2-The-Distributor" class="headerlink" title="2.2. The Distributor"></a>2.2. The Distributor</h3><p>The Distributor provides a programming interface for:<br>    • Globally enabling the forwarding of interrupts to the CPU interfaces.<br>    • Enabling or disabling each interrupt.<br>    • Setting the priority level of each interrupt.<br>    • Setting the target processor list of each interrupt.<br>    • Setting each peripheral interrupt to be level-sensitive or edge-triggered.<br>    • Setting each interrupt as either Group 0 or Group 1.<br>    • Forwarding an SGI to one or more target processors.<br>In addition, the Distributor provides:<br>    • visibility of the state of each interrupt<br>    • a mechanism for software to set or clear the pending state of a peripheral interrupt.</p>
<h4 id="2-2-1-Interrupt-IDs"><a href="#2-2-1-Interrupt-IDs" class="headerlink" title="2.2.1 Interrupt IDs"></a>2.2.1 Interrupt IDs</h4><p>GICv2 - The GIC assigns interrupt ID numbers ID0-ID1019 as follows:<br>    具有唯一标示<br>    SPI: 32 ~ 1019 </p>
<pre><code>banked interrupt 可重入或重复的中断， 每个CPU 的中断号可相同
PPI: 16 ~ 31
SGI: 0 ~ 15
</code></pre><p>In any system that implements the ARM Security Extensions, to support a consistent model for message passing<br>between processors, ARM strongly recommends that all processors reserve:<br>    • ID0-ID7 for Non-secure interrupts<br>    • ID8-ID15 for Secure interrupts.</p>
<p>Interrupt numbers ID1020-ID1023    are reserved for special purposes,</p>
<h3 id="2-3-CPU-interfaces"><a href="#2-3-CPU-interfaces" class="headerlink" title="2.3. CPU interfaces"></a>2.3. CPU interfaces</h3><p>Each CPU interface block provides the interface for a processor that is connected to the GIC.<br>    • enabling the signaling of interrupt requests to the processor<br>    • acknowledging an interrupt<br>    • indicating completion of the processing of an interrupt<br>    • setting an interrupt priority mask for the processor<br>    • defining the preemption policy for the processor<br>    • determining the highest priority pending interrupt for the processor.</p>
<p>GCI CPU interfaces是否拉起中断信号给处理器流程<br>Signal interrupt request flow:<br>    take the highest priorty pending interrupt(read GICC_HPPIR) -&gt; check interrupt priority mask and the preemption settings -&gt;<br>    signal or ignore interrupt request</p>
<p>CPU获取中断ID<br>The processor acknowledges the interrupt request by reading the CPU interface Interrupt Acknowledge Register.<br>This read returns one of:<br>    • The ID number of the highest priority pending interrupt, if that interrupt is of sufficient priority for it to be<br>    signaled to the processor. This is the normal response to an interrupt acknowledge.<br>    • Exceptionally, an ID number that indicates a spurious interrupt(1020 ~ 1023)</p>
<p>中断处理完成后<br>There are two stages to interrupt completion:<br>    • priority drop, meaning the priority of the processed interrupt can no longer prevent the signaling of another<br>    interrupt to the processor<br>    • interrupt deactivation, meaning the Distributor removes the active state of the interrupt.</p>
<p>In a GICv1 implementation, these two stages always happen together, when the processor writes to the CPU<br>interface End of Interrupt register.</p>
<p>In a GICv2 implementation, the GICC_CTLR.EOImode bit determines whether:<br>    • the two stages happen together, when the processor writes to the CPU interface End of Interrupt register<br>    • the two stages are separated, so that:<br>        — priority drop happens when the processor writes to the CPU interface End of Interrupt register<br>        — interrupt deactivation happens later, when the processor writes to the CPU interface Deactivate<br>        Interrupt register.    </p>
<h4 id="2-3-1-Interrupt-signal-bypass-and-GICv2-bypass-disable"><a href="#2-3-1-Interrupt-signal-bypass-and-GICv2-bypass-disable" class="headerlink" title="2.3.1 Interrupt signal bypass, and GICv2 bypass disable"></a>2.3.1 Interrupt signal bypass, and GICv2 bypass disable</h4><p>In all GIC implementations, a CPU interface optionally includes interrupt signal bypass, so that, when the signaling<br>of an interrupt by the interface is disabled, a system legacy interrupt signal is passed to the interrupt request input<br>on the processor, bypassing the GIC functionality.<br>中断信号旁路，主要支援legacy interrupt 不会受到CPU interface disable的影响，GICv2 must also provide disable bits for the interrupt<br>signal bypass operation.</p>
<p>FixMe 增加Interrupt signal bypass, GICv1 without Security Extensions 图片</p>
<h4 id="2-3-2-Power-management-GIC-v2"><a href="#2-3-2-Power-management-GIC-v2" class="headerlink" title="2.3.2 Power management, GIC v2"></a>2.3.2 Power management, GIC v2</h4><p>The GICv2 architecture supports wakeup events in implementations that require power management.<br>These signals are available even when both interrupt signaling by the GIC, and interrupt bypass, are disabled.</p>
<p>为软件提供预留或回复状态寄存器<br>the GICC_APRn registers provide support for preserving and restoring state in power-management<br>applications<br>However, to ensure that Non-secure accesses do not interfere with Secure operation, Secure and<br>Non-secure copies of these registers are provided.</p>
<h3 id="3-Interrupt-Handling-and-Prioritization"><a href="#3-Interrupt-Handling-and-Prioritization" class="headerlink" title="3 Interrupt Handling and Prioritization"></a>3 Interrupt Handling and Prioritization</h3><h4 id="3-1-About-interrupt-handling-and-prioritization"><a href="#3-1-About-interrupt-handling-and-prioritization" class="headerlink" title="3.1 About interrupt handling and prioritization"></a>3.1 About interrupt handling and prioritization</h4><p>Interrupt handling describes:<br>    • how the GIC recognizes interrupts<br>    • how software can program the GIC to configure and control interrupts<br>    • the state machine the GIC maintains for each interrupt on each CPU interface<br>    • how the exception model of a processor interacts with the GIC.</p>
<p>Prioritization describes:<br>    • the configuration and control of interrupt priority<br>    • the order of execution of pending interrupts<br>    • the determination of when interrupts are visible to a target processor, including:<br>        — interrupt priority masking<br>        — priority grouping<br>        — preemption of an active interrupt.</p>
<p>all implementations of the GIC architecture support interrupt grouping. With interrupt grouping:<br>    • by default, all interrupts are Group 0 interrupts, and are signaled to a connected processor using the IRQ<br>    interrupt request<br>    • each interrupt can be configured as Group 1 interrupt, or as a Group 0 interrupt<br>    • a CPU interface can be configured to signal Group 0 interrupts to a connected processor using the FIQ<br>    interrupt request.    </p>
<h5 id="3-1-1-About-interrupt-handling-and-prioritization"><a href="#3-1-1-About-interrupt-handling-and-prioritization" class="headerlink" title="3.1.1 About interrupt handling and prioritization"></a>3.1.1 About interrupt handling and prioritization</h5><p>可以参看 1.4.2. Interrupt types节<br>中断类型主要有四种：<br>物理中断：SPI，PPI （可边缘，电平触发）<br>软中断：SGI<br>虚拟中断：virtual interrupt<br>维护中断：maintenance interrupt (电平触发)，用于发送key events(具备virtualization extensions GIC)</p>
<p>参看 1.4.3. Models for handling interrupts 节<br>SGI 使用GIC N-N模型<br>物理中断 SPI，PPI 使用GIC 1-N 模型</p>
<h5 id="3-1-2-Identifying-the-supported-interrupts"><a href="#3-1-2-Identifying-the-supported-interrupts" class="headerlink" title="3.1.2 Identifying the supported interrupts"></a>3.1.2 Identifying the supported interrupts</h5><p>中断号的分段参看2.2.1 Interrupt IDs节</p>
<p>软件获知enable 中断<br>Software can use the GICD_ISENABLERns to discover what interrupt IDs are supported by the GIC。</p>
<p>GICD_ISENABLER0 provides the Set-enable bits for both:<br>    • SGIs, using interrupt IDs 15-0, corresponding to register bits [15:0]<br>    • PPIs, using interrupt IDs 31-16, corresponding to register bits [31:16].</p>
<p>The remaining GICD_ISENABLERns, from GICD_ISENABLER1, provide the Set-enable bits for the SPIs,<br>starting at interrupt ID 32.</p>
<p>Software discovers the interrupts that are supported by:</p>
<ol>
<li>Reading the GICD_TYPER. The GICD_TYPER.ITLinesNumber field identifies the number of implemented<br>GICD_ISENABLERns, and therefore the maximum number of SPIs that might be supported. （获取supported interrupt 总数）</li>
<li>Writing to the GICD_CTLR to disable forwarding of interrupts from the distributor to the CPU interfaces.<br>For more information, see Enabling and disabling the Distributor and CPU interfaces on page 4-77.</li>
<li>For each implemented GICD_ISENABLERn, starting with GICD_ISENABLER0:<br> • Writing 0xFFFFFFFF to the GICD_ISENABLERn.<br> • Reading the value of the GICD_ISENABLERn. Bits that read as 1 correspond to supported interrupt IDs.    </li>
</ol>
<p>永久使能中断<br>Software uses the GICD_ICENABLERns to discover the interrupts that are permanently enabled. For each<br>implemented GICD_ICENABLERn, starting with GICD_ICENABLER0, software:</p>
<ol>
<li>Writes 0xFFFFFFFF to the GICD_ICENABLERn. This disables all interrupts that can be disabled.</li>
<li>Reads the value of the GICD_ICENABLERn. Bits that read as 1 correspond to interrupts that are<br>permanently enabled.</li>
<li>Writes 1 to any GICD_ISENABLERn bits corresponding to interrupts that must be re-enabled.    </li>
</ol>
<p>The GIC implements the same number of GICD_ISENABLERns and GICD_ICENABLERns.</p>
<h4 id="3-2-General-handling-of-interrupts"><a href="#3-2-General-handling-of-interrupts" class="headerlink" title="3.2 General handling of interrupts"></a>3.2 General handling of interrupts</h4><p>中断状态分为：(detail see 3.2.4 Interrupt handling state machine)</p>
<ul>
<li>inactive</li>
<li>pending</li>
<li>active</li>
<li>active and pending</li>
</ul>
<p>Group, security extension 中断参看 3.4 The effect of interrupt grouping on interrupt handling<br>virtualization extension 中断处理参看 5 GIC Support for Virtualization.</p>
<p>通用中断处理流程：<br>When the GIC recognizes an interrupt request, it marks its state as pending. Regenerating a pending interrupt does<br>not affect the state of the interrupt.</p>
<p>The GIC interrupt handling sequence is:</p>
<ol>
<li>The GIC determines the interrupts that are enabled.</li>
<li>For each pending interrupt, the GIC determines the targeted processor or processors.</li>
<li>For each CPU interface, the Distributor forwards the highest priority pending interrupt that targets that<br>interface.</li>
<li>Each CPU interface determines whether to signal an interrupt request to its processor, and if required, does so.</li>
<li>The processor acknowledges the interrupt, and the GIC returns the interrupt ID and updates the interrupt<br>state.</li>
<li>After processing the interrupt, the processor signals End of Interrupt (EOI) to the GIC.</li>
</ol>
<p>In more detail, these steps are as follows:</p>
<ol>
<li><p>The GIC determines whether each interrupt is enabled. An interrupt that is not enabled has no effect on the GIC.</p>
</li>
<li><p>For each enabled interrupt that is pending, the Distributor determines the targeted processor or processors.</p>
</li>
<li><p>For each processor, the Distributor determines the highest priority pending interrupt, based on the priority information it holds for each interrupt, and forwards the interrupt to the targeted CPU interfaces.</p>
</li>
<li><p>If the distributor is forwarding an interrupt request to a CPU interface, the CPU interface determines whether the interrupt has Sufficient priority to be signaled to the processor. If the interrupt has sufficient priority, the GIC signals an interrupt request to the processor.</p>
</li>
<li><p>When a processor takes the interrupt exception, it reads the GICC_IAR of its CPU interface to acknowledge the interrupt. This read returns an Interrupt ID, and for an SGI, the source processor ID, that the processor uses to select the correct interrupt handler. When it recognizes this read, the GIC changes the state of the interrupt as follows:<br> • if the pending state of the interrupt persists when the interrupt becomes active, or if the interrupt is generated again, from pending to active and pending.<br> • otherwise, from pending to active</p>
<pre><code>Note:
• A level-sensitive peripheral interrupt persists when it is acknowledged by the processor, because the
interrupt signal to the GIC remains asserted until the Interrupt Service Routine (ISR) running on the
processor accesses the peripheral asserting the signal.
• In a multiprocessor implementation, the GIC handles:
    — PPIs and SGIs using the GIC N-N model, where the acknowledgement of an interrupt by one
    processor has no effect on the state of the interrupt on other CPU interfaces
    — SPIs using the GIC 1-N model, where the acknowledgement of an interrupt by one processor
    removes the pending status of the interrupt on any other targeted processors, see Implications
    of the 1-N model on page 3-41.
• In GICv2, when using a software model with the GICC_CTLR.AckCtl bit set to 0, separate registers
are used to manage Group 0 and Group 1 interrupts, as follows:
    — GICC_IAR, GICC_EOIR, and GICC_HPPIR for Group 0 interrupts
    — GICC_AIAR, GICC_AEOIR, and GICC_AHPPIR for Group 1 interrupts.
ARM deprecates the use of GICC_CTLR.AckCtl, and strongly recommends using a software model
where GICC_CTLR.AckCtl is set to 0, see [3.4.3 The effect of interrupt grouping on interrupt acknowledgement]
</code></pre></li>
<li><p>When the processor has completed handling the interrupt, it must signal this completion to the GIC. As<br>described in [3.2.1 Priority drop and interrupt deactivation], this: (通知GIC， EOI 并改写状态到inactive)<br> • always requires a valid write to an end of interrupt register (EOIR)<br> • might also require a subsequent write to the deactivate interrupt register, GICC_DIR.    </p>
</li>
</ol>
<p>写向EOIR 的值是从GICC_IAR 或 GICC_AIAR得到的最近处理的中断号<br>For each CPU interface, the GIC architecture requires the order of the valid writes to an EOIR to be the<br>reverse of the order of the reads from the GICC_IAR or GICC_AIAR, so that each valid EOIR write refers<br>to the most recent interrupt acknowledge.</p>
<p>A CPU interface never signals to the connected processor any interrupt that is active and pending. It only<br>signals interrupts that are pending and have sufficient priority:<br>    • For PPIs and SGIs, the active status of particular interrupt ID is banked between CPU interfaces. This<br>    means that if a particular interrupt ID is active or active and pending on a CPU interface, then no<br>    interrupt with that same ID is signaled on that CPU interface.<br>    • For SPIs, the active status of an interrupt is common to all CPU interfaces. This means that if an<br>    interrupt is active or active and pending on one CPU interface then it is not signaled on any CPU<br>    interface.</p>
<h4 id="3-2-1-Priority-drop-and-interrupt-deactivation"><a href="#3-2-1-Priority-drop-and-interrupt-deactivation" class="headerlink" title="3.2.1 Priority drop and interrupt deactivation"></a>3.2.1 Priority drop and interrupt deactivation</h4><p>When a processor completes the processing of an interrupt, it must signal this completion to the GIC. Interrupt<br>completion requires the following changes to the GIC state:</p>
<p>Priority drop<br>Priority drop is the drop in the Running priority that occurs on a valid write to an EOIR, either the<br>GICC_EOIR or the GICC_AEOIR.</p>
<p>Interrupt deactivation<br>Interrupt deactivation is the change of the state of an interrupt, either:<br>    • from active and pending, to pending<br>    • from active, to idle</p>
<p>在GICv1 中Priority drop  与    Interrupt deactivation 是同时的。在GICv2 中可以设定setting GICC_CTLR.EOImode to 1 separates the priority drop and interrupt deactivation operations， and interrupt handling software must:</p>
<pre><code>1. Perform a valid EOIR write, to cause priority drop on the GIC CPU interface.
2. Subsequently, write to the GICC_DIR, to deactivate the interrupt.
</code></pre><p>The GIC architecture specification requires that valid EOIR writes are ordered, so that:<br>• a valid GICC_EOIR write corresponds to the most recently acknowledged interrupt<br>• a valid GICC_AEOIR write corresponds to the most recently acknowledged Group 1 interrupt.<br>• whether a GICC_EOIR write affects Group 0 or Group 1 interrupts depends on both:<br>    — the value of the GICC_CTLR. AckCtl bit<br>    — if the GIC implements the GIC Security Extensions, whether the write is Secure or Non-secure.</p>
<p>Note：<br>In a GICv2 implementation that includes the Security Extensions:<br>• GICC_AEOIR is an alias of the Non-secure copy of GICC_EOIR<br>• GICC_AIAR is an alias of the Non-secure copy of GICC_IAR<br>• GICC_AIAR and GICC_AEOIR are Secure registers, meaning they are accessible only by Secure accesses.</p>
<h4 id="3-2-2-Interrupt-controls-in-the-GIC"><a href="#3-2-2-Interrupt-controls-in-the-GIC" class="headerlink" title="3.2.2 Interrupt controls in the GIC"></a>3.2.2 Interrupt controls in the GIC</h4><p><strong>Interrupt enables</strong><br>For peripheral interrupts, a processor:<br>• enables an interrupt by writing to the appropriate GICD_ISENABLERn bit<br>• disables an interrupt by writing to the appropriate GICD_ICENABLERn bit.</p>
<p><strong>Setting and clearing pending state of an interrupt</strong><br>For peripheral interrupts, a processor can:<br>• set the pending state by writing to the appropriate GICD_ISPENDRn bit<br>• clear the pending state by writing to the appropriate GICD_ICPENDRn bit.</p>
<p>For a level-sensitive interrupt:<br>• If the hardware signal of an interrupt is asserted when a processor writes to the corresponding<br>GICD_ICPENDRn bit then the write to the register has no effect on the pending state of the interrupt.<br>• If a processor writes a 1 to an GICD_ISPENDRn bit then the corresponding interrupt becomes pending<br>regardless of the state of the hardware<br>more detail see [Control of the pending status of level-sensitive interrupts]</p>
<p>For SGIs, the GIC ignores writes to the corresponding GICD_ISPENDRn and GICD_ICPENDRn bits. A processor<br>cannot change the state of a software-generated interrupt by writing to these registers.<br>Typically, an SGI is made pending by writing to the GICD_SGIR. In GICv2, the pending state of SGIs can also be modified directly using the<br>GICD_SPENDSGIRn and GICD_CPENDSGIRn bits.</p>
<p><strong>Finding the active or pending state of an interrupt</strong><br>A processor can find:<br>• the pending state of an interrupt by reading the corresponding GICD_ISPENDRn or GICD_ICPENDRn bit<br>• the active state of an interrupt by reading the corresponding GICD_ISACTIVERn or GICD_ICACTIVERn<br>bit.</p>
<p>In GICv2, the processor that issues the SGI can also be determined by reading the<br>corresponding GICD_SPENDSGIRn or GICD_CPENDSGIRn bits.</p>
<p><strong>Generating an SGI</strong><br>A processor generates an SGI by writing to an GICD_SGIR.<br>The GICD_SGIR includes optimization for:<br>• interrupting only the processor that writes to the GICD_SGIR<br>• interrupting all processors other than the one that writes to the GICD_SGIR.</p>
<p>GICD_SGIR 大致包含:<br>• interrupt ID<br>• source processor<br>• target processor.</p>
<p>SGIs from different processors use the same interrupt IDs. Therefore, any target processor can receive SGIs with<br>the same interrupt ID from different processors.</p>
<p>Only one interrupt with a specific interrupt ID can be active on a CPU interface at any time. This means that a CPU<br>interface cannot have two SGIs with the same interrupt ID active at the same time, even if different processors have<br>signaled SGIs with the same interrupt ID to that processor.</p>
<p>On the CPU interface of the target processor, reading the GICC_IAR for an SGI returns both the interrupt ID and<br>the CPU ID of the processor that generated the interrupt, the source processor for the interrupt.The combination of<br>interrupt ID and source CPU ID uniquely identifies the interrupt to the target processor.</p>
<p>In a multiprocessor implementation, the interrupt priority of each SGI interrupt ID is defined independently for each<br>target processor。<br><strong>For each CPU interface, all SGIs with a particular interrupt ID that are pending on that interface have the same priority and must be handled serially.</strong></p>
<h5 id="3-2-3-Implications-of-the-1-N-model"><a href="#3-2-3-Implications-of-the-1-N-model" class="headerlink" title="3.2.3 Implications of the 1-N model"></a>3.2.3 Implications of the 1-N model</h5><p><strong>when the GIC recognizes an interrupt acknowledge from one of the target processors it clears the pending state of the interrupt on all the other targeted processors.</strong> A GIC implementation must ensure that any interrupt being handled using the 1-N model is only acknowledged by one CPU interface, and that all other interfaces return a spurious<br>interrupt ID.</p>
<p>When multiple target processors attempt to acknowledge the interrupt, the following can occur:<br>• A processor reads the GICC_IAR and obtains the interrupt ID of the interrupt to be serviced.<br>    Note:  (在多核情况下，通过share memory, lock形式，确保只有一个core 处理中断)<br>    In GICv1, more than one target processor might have obtained this interrupt ID, if the processors read their<br>    GICC_IAR registers at very similar times. The system might require software on the target processors to<br>    ensure that only one processor runs its interrupt service routine. A typical mechanism to achieve this is<br>    implementing, in shared memory, a lock on the interrupt service routine (ISR).</p>
<p>• <strong>A processor reads the GICC_IAR and obtains the interrupt ID 1023, indicating a spurious interrupt. The processor can return from its interrupt service routine without writing to its GICC_EOIR.</strong><br><strong>The spurious interrupt ID indicates that the original interrupt is no longer pending, typically because another target processor is handling it.</strong></p>
<p>Note<br>    • A GICv1 implementation might ensure that only one processor can make a 1-N interrupt active, removing<br>    the requirement for a lock on the ISR. This is not required by the architecture, and generic GIC code must<br>    not rely on this behavior.（GICv1 不要求在ISR 中lock）<br>    • For any processor, if an interrupt is active and pending, the GIC does not signal an interrupt exception request<br>    for the interrupt to any processor until the active status is cleared. （如果中断是active且pending 状态，GIC 不会触发此中断给任何processor 直到active 状态清除）</p>
<h5 id="3-2-3-Interrupt-handling-state-machine"><a href="#3-2-3-Interrupt-handling-state-machine" class="headerlink" title="3.2.3 Interrupt handling state machine"></a>3.2.3 Interrupt handling state machine</h5><p>Fixme 【中断状态机】</p>
<p><strong>Transition A1 or A2, add pending state</strong><br>For an SGI, occurs if either:<br>• Software writes to a GICD_SGIR that specifies the processor as a target.<br>• Software on the target processor writes to the GICD_SPENDSGIRn bit that corresponds to<br>the required source processor and interrupt ID</p>
<p>For an SPI or PPI, occurs if either:<br>• a peripheral asserts an interrupt request signal<br>• software writes to an GICD_ISPENDRn</p>
<p><strong>Transition B1 or B2, remove pending state</strong><br>For an SGI, occurs if software on the target processor writes to the relevant bit of the<br>GICD_CPENDSGIRn.</p>
<p>物理中断</p>
<ul>
<li>电平触发，pending 会一直拉高直到处理</li>
<li>边缘触发，写GICD_ICPENDRn 寄存器清pending 状态</li>
</ul>
<p>For an SPI or PPI, occurs if either:<br>• the level-sensitive interrupt is pending only because of the assertion of an input signal, and<br>that signal is deasserted<br>• the interrupt is pending only because of the assertion of an edge-triggered interrupt signal, or<br>a write to an GICD_ISPENDRn, and software writes to the corresponding<br>GICD_ICPENDRn.</p>
<p><strong>Transition C, pending to active</strong><br>If the interrupt is enabled and of Sufficient priority to be signaled to the processor, occurs when<br>software reads from the GICC_IAR.</p>
<p><strong>Transition D, pending to active and pending</strong><br>For an SGI, this transition occurs in either of the following circumstances:<br>• If a write to set the SGI state to pending occurs at approximately the same time as a read of<br>GICC_IAR.<br>• When two or more pending SGIs with the same interrupt ID originate from the same source<br>processor and target the same processor. If one of the SGIs follows transition C, the other<br>SGIs follow transition D</p>
<p>For an SPI or PPI this transition occurs if all the following apply:<br>• The interrupt is enabled.<br>• Software reads from the GICC_IAR. This read adds the active state to the interrupt.<br>• In addition, one of the following conditions applies:<br>    — For a level-sensitive interrupt, the interrupt signal remains asserted. This is usually the<br>    case, because the peripheral does not deassert the interrupt until the processor has<br>    serviced the interrupt.<br>    — For an edge-triggered interrupt, whether this transition occurs depends on the timing<br>    of the read of the GICC_IAR relative to the detection of the reassertion of the interrupt.<br>    Otherwise the read of the GICC_IAR causes transition C, possibly followed by<br>    transition A2.</p>
<p><strong>Transition E1 or E2, remove active state</strong><br>Occurs when software deactivates an interrupt by writing to either GICC_EOIR or GICC_DIR.In a GIC<br>implementation the includes the Virtualization Extensions, also occurs if the virtual CPU interface<br>signals that the corresponding physical interrupt has been deactivated    </p>
<h4 id="3-3-Interrupt-prioritization"><a href="#3-3-Interrupt-prioritization" class="headerlink" title="3.3 Interrupt prioritization"></a>3.3 Interrupt prioritization</h4><p>Software configures interrupt prioritization in the GIC by assigning a priority value to each interrupt source. Priority<br>values are 8-bit unsigned binary.A GIC supports a minimum of 16 and a maximum of 256 priority levels. If the<br>GIC implements fewer than 256 priority levels, low-order bits of the priority fields are RAZ/WI.<br>In the GIC prioritization scheme, lower numbers have higher priority,</p>
<table>
<thead>
<tr>
<th style="text-align:center">Implemented priority bits</th>
<th style="text-align:center">Possible priority field values</th>
<th style="text-align:center">Number of priority levels</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[7:0]</td>
<td style="text-align:center">0x00-0xFF (0-255), all values</td>
<td style="text-align:center">256</td>
</tr>
<tr>
<td style="text-align:center">[7:1]</td>
<td style="text-align:center">0x00-0xFE, (0-254), even values only</td>
<td style="text-align:center">128</td>
</tr>
<tr>
<td style="text-align:center">[7:2]</td>
<td style="text-align:center">0x00-0xFC (0-252), in steps of 4</td>
<td style="text-align:center">64</td>
</tr>
<tr>
<td style="text-align:center">[7:3]</td>
<td style="text-align:center">0x00-0xF8 (0-248), in steps of 8</td>
<td style="text-align:center">32</td>
</tr>
<tr>
<td style="text-align:center">[7:4]</td>
<td style="text-align:center">0x00-0xF0 (0-240), in steps of 16</td>
<td style="text-align:center">16</td>
</tr>
</tbody>
</table>
<p><strong>The GICD_IPRIORITYRn registers hold the priority value for each supported interrupt.</strong></p>
<p>To determine the number of priority bits implemented, software can write 0xFF to a writable GICD_IPRIORITYRn<br>priority field, and read back the value stored.<br>Note:<br>ARM recommends that, before checking the priority range in this way:<br>• for a peripheral interrupt, software first disables the interrupt<br>• for an SGI, software first checks that the interrupt is inactive</p>
<h5 id="3-3-1-Preemption"><a href="#3-3-1-Preemption" class="headerlink" title="3.3.1 Preemption"></a>3.3.1 Preemption</h5><p>A CPU interface supports signaling of higher priority pending interrupts to a target processor before an active<br>interrupt completes. A pending interrupt is only signaled if both:<br>• Its priority is higher than the priority mask for that CPU interface, see [Priority masking].<br>• Its group priority is higher than that of the Running priority on the CPU interface, see [Priority grouping] and[<br>Running Priority Register, GICC_RPR]</p>
<p>For a processor that complies with the ARM architecture:<br>    — The value of the I or F bit in the CPSR determines whether the processor responds to the signaled<br>    interrupt by starting the interrupt acknowledge procedure.<br>    — When processing a preempting interrupt, the processor must save and later restore the context of the<br>    previously active ISR.</p>
<h5 id="3-3-2-Priority-masking"><a href="#3-3-2-Priority-masking" class="headerlink" title="3.3.2 Priority masking"></a>3.3.2 Priority masking</h5><p>CPU Interface 选择高于中断阀门优先级的中断給处理器。<br>The GICC_PMR for a CPU interface defines a priority threshold.The GIC only signals<br>pending interrupts with a higher priority than this threshold value to the target processor. A value of zero, the register<br>reset value, masks all interrupts from being signaled to the associated processor. The GIC does not use priority<br>grouping when comparing the priority of a pending interrupt with the priority threshold.</p>
<h5 id="3-3-3-Priority-grouping"><a href="#3-3-3-Priority-grouping" class="headerlink" title="3.3.3 Priority grouping"></a>3.3.3 Priority grouping</h5><p>一组相同优先级的中断。<br>Priority grouping uses the Binary Point Register, GICC_BPR, to split a priority value into two fields, the group<br>priority and the subpriority.When determining preemption, all interrupts with the same group priority are<br>considered to have equal priority, regardless of the subpriority. This means that there can only be one interrupt active<br>at each group priority. The active group priority is also known as the <strong>Preemption level.</strong></p>
<p>主要是用过GICC_BPR 0~2 划分出 GICC_PMR 两个部分：Group priority field 和Subpriority field<br>FixME [Table 3-2 Priority grouping by binary point] 图片page 46</p>
<h4 id="3-4-The-effect-of-interrupt-grouping-on-interrupt-handling"><a href="#3-4-The-effect-of-interrupt-grouping-on-interrupt-handling" class="headerlink" title="3.4 The effect of interrupt grouping on interrupt handling"></a>3.4 The effect of interrupt grouping on interrupt handling</h4><p>A GICv1 implementation that includes the GIC Security Extensions, or any GICv2 implementation, provides two<br>interrupt output signals for IRQ and FIQ exception requests:<br>• The CPU interface always uses the IRQ exception request for Group 1 interrupts<br>• Software can configure the CPU interface to use either IRQ or FIQ exception requests for Group 0 interrupts</p>
<h5 id="3-4-1-GIC-interrupt-grouping-support"><a href="#3-4-1-GIC-interrupt-grouping-support" class="headerlink" title="3.4.1 GIC interrupt grouping support"></a>3.4.1 GIC interrupt grouping support</h5><p>The GICD_IGROUPRn registers configure each interrupt as Group 0 or Group 1.</p>
<p>FixMe [CPU interface control of Group 0 and Group 1 interrupts, GICv2] 图片 Page48</p>
<p>In an implementation that includes the GIC Security Extensions, the alias registers:<br>• typically <strong>represent aliases of the Non-secure copy of the Group 0 registers</strong>, for example GICC_ABPR is an<br>alias of the Non-Secure copy of GICC_BPR<br>• are <strong>accessible only by Secure accesses.</strong></p>
<p>In an implementation that supports interrupt grouping, GICC_CTLR contains additional fields, including fields to<br>control the handling of the grouped interrupts:<br>• Separate enable bits to control the signaling of Group 0 and Group 1 interrupts to the connected processor: （是否支持组中断）<br>    — bit[0], the Enable bit in a GIC that does not support interrupt grouping, becomes the EnableGrp0 bit,<br>    and controls whether Group 0 interrupts are signaled to the processor<br>    — the EnableGrp1 bit is added, to control whether Group 1 interrupts are signaled to the processor.<br>• The FIQEn bit, that controls whether the interface signals Group 0 interrupts to the processor using the IRQ<br>or FIQ interrupt request. （Group0 是否支持FIQ）<br>• The CBPR bit, that controls whether GICC_BPR or GICC_ABPR is used when determining possible<br>interrupt preemption by Group 1 interrupts, see [Control of preemption by Group 1 interrupts] （是否支持抢占）<br>• The AckCtl bit, that controls whether a read of the GICC_IAR, or the Secure GICC_IAR if the GIC<br>implements the Security Extensions, can acknowledge a Group 1 interrupt.（是否支持Group1 能从GICC_IAR 读取中断ID，value 0 读到1022保留中断号，否则真实值）</p>
<h5 id="3-4-2-Special-interrupt-numbers-when-a-GIC-supports-interrupt-grouping"><a href="#3-4-2-Special-interrupt-numbers-when-a-GIC-supports-interrupt-grouping" class="headerlink" title="3.4.2 Special interrupt numbers when a GIC supports interrupt grouping"></a>3.4.2 Special interrupt numbers when a GIC supports interrupt grouping</h5><p>1020-1021 Reserved.</p>
<p>1022 Used only if the GIC supports interrupt grouping.<br>The GIC returns this value to a processor in response to an interrupt acknowledge only when all of<br>the following apply:<br>• the interrupt acknowledge is a read of GICC_IAR<br>• the highest priority pending interrupt is a Group 1 interrupt<br>• GICC_CTLR.AckCtl is set to 0<br>• the priority of the interrupt is sufficient for it to be signaled to the processor.<br>    Note:<br>    • Interrupt ID 1022 indicates that there is a Group 1 interrupt of sufficient priority to be<br>    signaled to the processor, that must be acknowledged by a read of the GICC_AIAR, or in an<br>    implementation that includes the GIC Security Extensions, by a read of the Non-secure<br>    GICC_IAR.</p>
<p>1023 This value is returned to a processor, in response to an interrupt acknowledge, if there is no pending<br>interrupt with sufficient priority for it to be signaled to the processor.<br>On a processor that supports interrupt grouping, values of 1022 and 1023 are spurious interrupt IDs.</p>
<h5 id="3-4-3-The-effect-of-interrupt-grouping-on-interrupt-acknowledgement"><a href="#3-4-3-The-effect-of-interrupt-grouping-on-interrupt-acknowledgement" class="headerlink" title="3.4.3 The effect of interrupt grouping on interrupt acknowledgement"></a>3.4.3 The effect of interrupt grouping on interrupt acknowledgement</h5><p><strong>When the GICC_CTLR.AckCtl bit is set to 0, to ensure system correctness, every Group 0 interrupt must have a higher priority than any Group 1 interrupt.</strong></p>
<p>When the GICC_CTLR.AckCtl bit is set to 1, a read of GICC_IAR acknowledges the highest-priority pending<br>interrupt on the CPU interface, regardless of whether it is a Group 0 or a Group 1 interrupt. （ARM 极不推荐GICC_CTLR.AckCtl 设定为1）</p>
<p>In a GIC implementation that supports interrupt grouping, ARM strongly recommends setting GICC_CTLR.AckCtl<br>to 0, meaning:<br>• for a GICv2 implementation:<br>    — a group 0 interrupt is acknowledged by a read of GICC_IAR, or a Secure read of GICC_IAR if the<br>    implementation includes the GIC Security Extensions<br>    — a group 1 interrupt is acknowledged by a read of GICC_AIAR, or a Non-secure read of GICC_IAR if<br>    the implementation includes the GIC Security Extensions<br>• for a GICv1 implementation:<br>    — a group 0 interrupt must be acknowledged by a read of the Secure GICC_IAR<br>    — a group 1 interrupt must be acknowledged by a read of Non-secure GICC_IAR.</p>
<p>If the Interrupt Acknowledge register access does not correspond to the highest-priority pending interrupt on the CPU interface then:<br>• a read of GICC_IAR when the highest-priority pending interrupt is a Group 1 interrupt returns the spurious<br>interrupt value 1022<br>• a read of GICC_AIAR when the highest-priority pending interrupt is a Group 0 interrupt returns the spurious<br>interrupt value 1023.</p>
<h5 id="3-4-4-GIC-power-on-or-reset-configuration"><a href="#3-4-4-GIC-power-on-or-reset-configuration" class="headerlink" title="3.4.4 GIC power on or reset configuration"></a>3.4.4 GIC power on or reset configuration</h5><p>On power-up, or after a reset, a GIC implementation that supports interrupt grouping is configured with:<br>• all interrupts assigned to Group 0<br>• the FIQ exception request disabled.</p>
<p>FixMe [Reset configuration of a GIC that includes the FIQ exception request]  图片 page52</p>
<h4 id="3-5-Interrupt-grouping-and-interrupt-prioritization"><a href="#3-5-Interrupt-grouping-and-interrupt-prioritization" class="headerlink" title="3.5 Interrupt grouping and interrupt prioritization"></a>3.5 Interrupt grouping and interrupt prioritization</h4><p>ARM strongly recommends that:<br>    • Group 0 interrupts are always assigned priority values in the lower half of the supported priority value range.<br>    These values correspond to the higher-priority interrupts<br>    • Group 1 interrupts are always assigned priority values in the upper half of the supported priority value range.<br>    These values correspond to the lower-priority interrupts.</p>
<p>This ensures that every Group 1 interrupt is of lower priority than any Group 0 interrupt.</p>
<h5 id="3-5-1-Software-views-of-interrupt-priority-in-a-GIC-that-includes-the-Security-Extensions"><a href="#3-5-1-Software-views-of-interrupt-priority-in-a-GIC-that-includes-the-Security-Extensions" class="headerlink" title="3.5.1 Software views of interrupt priority in a GIC that includes the Security Extensions"></a>3.5.1 Software views of interrupt priority in a GIC that includes the Security Extensions</h5><p>When a processor reads the priority value of a Group 1 interrupt, the GIC returns either the Secure or the Non-secure<br>view of that value, depending on whether the access is Secure or Non-secure.</p>
<p>This is for a GIC that implements the maximum range of priority values.<br>FixMe [Figure 3-7 Software views of the priorities of Group 1 and Group 0 interrupts]图片 Page55</p>
<p>FixMe [Table 3-6 Effect of not implementing some priority field bits, with GIC Security Extensions]图片 Page56</p>
<p><strong>Recommendations for managing priority values</strong><br>ARM strongly recommends that:<br>• for a Group 0 interrupt, software sets bit [7] of the priority value field to 0<br>• if using a Secure write to set the priority of a Group 1 interrupt, software sets bit [7] of the priority value field<br>to 1.</p>
<h5 id="3-5-2-Control-of-preemption-by-Group-1-interrupts"><a href="#3-5-2-Control-of-preemption-by-Group-1-interrupts" class="headerlink" title="3.5.2 Control of preemption by Group 1 interrupts"></a>3.5.2 Control of preemption by Group 1 interrupts</h5><p>When a GIC implementation supports interrupt grouping, the GICC_BPR is always used to determine whether a<br>Group 0 interrupt is signaled to the processor, for possible preemption.<br>By default, the GICC_ABPR is used to<br>determine whether a Group 1 interrupt is signaled for possible preemption.</p>
<p>However, when GICC_CTLR.CBPR is set to 1, GICC_BPR is used for determining possible preemption, for both Group 0 and Group 1 interrupts.</p>
<p>Priority grouping for Group 1 interrupts when GICC_CTLR.CBPR==0 情况与 [Priority grouping] 类似</p>
<h4 id="3-6-Additional-features-of-the-GIC-Security-Extensions"><a href="#3-6-Additional-features-of-the-GIC-Security-Extensions" class="headerlink" title="3.6 Additional features of the GIC Security Extensions"></a>3.6 Additional features of the GIC Security Extensions</h4><p>Software can detect support for the GIC Security Extensions by reading the GICD_TYPER.SecurityExtn bit, see<br>Interrupt Controller Type Register, GICD_TYPER on page 4-88.</p>
<h5 id="3-6-1-Access-from-processors-not-implementing-the-ARM-Security-Extensions"><a href="#3-6-1-Access-from-processors-not-implementing-the-ARM-Security-Extensions" class="headerlink" title="3.6.1 Access from processors not implementing the ARM Security Extensions"></a>3.6.1 Access from processors not implementing the ARM Security Extensions</h5><p>When connecting a processor that does not support the ARM Security Extensions to a GIC that implements the GIC<br>Security Extensions, typically all processor accesses to the GIC are assigned as either Secure or Non-secure:<br>• For a processor making Secure accesses:<br>    — <strong>The processor can control all aspects of the GIC, and therefore can make configuration changes that might affect Secure software running on other processors.</strong><br>    — In a GICv2 implementation, the processor <strong>uses Secure accesses to aliased registers, such as the GICC_AIAR, to process Group 1 interrupts.</strong><br>    — Because GICv1 implementations do not include the aliased registers, if the implementation uses<br>    interrupt grouping the processor might have to use the deprecated GICC_CTLR.AckCtl bit to enable<br>    Group 1 interrupts to be processed using the standard CPU interface registers.</p>
<p>• For a processor making Non-secure accesses:<br>    — The processor cannot control Group 0 interrupts. For the GIC to be programmed, <strong>the system implementation must include at least one processor that can make Secure accesses.</strong><br>    A system might use a Secure processor to perform Secure accesses on behalf of a Non-secure<br>    processor. This usage model is possible if the GIC or the system provides a method for the Secure<br>    processor to access processor-banked copies of registers that belong to the Non-secure processor.<br>    — To <strong>permit a Non-secure processor to control its own Group 0 interrupts, a GICv2 implementation can implement the GICD_NSACRn registers.</strong> An implementation of these registers might permit a Secure<br>    processor to permit the use of Non-secure accesses from a particular processor to control some aspects<br>    of the operation of some Group 0 SGIs and SPIs.<br>    — A GIC implementation can configure the GICD_IGROUPRn reset value so that interrupts are Group<br>    1 on reset. see GICD_IGROUPR0 reset value on page 4-92 for more information</p>
<h4 id="3-7-Pseudocode-details-of-interrupt-handling-and-prioritization"><a href="#3-7-Pseudocode-details-of-interrupt-handling-and-prioritization" class="headerlink" title="3.7 Pseudocode details of interrupt handling and prioritization"></a>3.7 Pseudocode details of interrupt handling and prioritization</h4><p>skip, see spec</p>
<h4 id="3-8-The-effect-of-the-Virtualization-Extensions-on-interrupt-handling"><a href="#3-8-The-effect-of-the-Virtualization-Extensions-on-interrupt-handling" class="headerlink" title="3.8 The effect of the Virtualization Extensions on interrupt handling"></a>3.8 The effect of the Virtualization Extensions on interrupt handling</h4><p>see Chapter 5 GIC Support for Virtualization</p>
<h4 id="3-9-Example-GIC-usage-models"><a href="#3-9-Example-GIC-usage-models" class="headerlink" title="3.9 Example GIC usage models"></a>3.9 Example GIC usage models</h4><p>FixMe [Figure 3-8 Generic GIC usage model]图片page 68</p>
<h5 id="3-9-1-Using-IRQs-and-FIQs-to-provide-Non-secure-and-Secure-interrupts"><a href="#3-9-1-Using-IRQs-and-FIQs-to-provide-Non-secure-and-Secure-interrupts" class="headerlink" title="3.9.1 Using IRQs and FIQs to provide Non-secure and Secure interrupts"></a>3.9.1 Using IRQs and FIQs to provide Non-secure and Secure interrupts</h5><p>FixMe [Figure 3-9 Using the GIC to route Secure and Non-secure interrupts]图片page 69</p>
<p>shows a system that implements the GIC Security Extensions, connected to a processor that<br>implements the ARM processor Security Extensions. This implementation:<br>• uses Group 0 interrupts as Secure interrupts, signaled as FIQs<br>• uses Group 1 interrupts as Non-secure interrupts, signaled as IRQs.<br>This means that, on the processor, FIQ interrupts are never routed to Non-secure software, and IRQ interrupts are<br>never routed to Secure software.</p>
<p>Note：<br>The use of Group 0 and Group 1 interrupts to signal Secure interrupts as FIQs, and Non-secure interrupts as IRQs,<br>requires the processor to:<br>• <strong>route FIQs to be taken in Secure Monitor mode</strong><br>• <strong>prevent Non-secure software from masking FIQs</strong><br>• <strong>ensure that IRQs are masked whenever it is operating in Secure state.</strong></p>
<p>On a GIC reset, all interrupts are assigned to Group 0, making them Secure interrupts. Secure software on the<br>processor:<br>• programs the GICD_IGROUPRn registers to indicate which interrupts are Group 1, Non-secure<br>• sets the Secure GICC_CTLR.FIQEn bit to 1 to configure the CPU interface to use FIQ for Group 0 interrupts.<br>• must enable Group 0 interrupts and Group 1 interrupts, independently, in the Distributor: （配置GIC）<br>    — GICD_CTLR.EnableGrp0 enables Group 0 interrupts<br>    — GICD_CTLR.EnableGrp1 enables Group 1 interrupts.<br>• must enable Group 0 interrupts and Group 1 interrupts, independently, in the CPU interface: （配置CPU Interface）<br>    — GICC_CTLR.EnableGrp0 enables Group 0 interrupts<br>    — GICC_CTLR.EnableGrp1 enables Group 1 interrupts.</p>
<h5 id="3-9-2-Supporting-IRQs-and-FIQs-when-not-using-the-processor-Security-Extensions"><a href="#3-9-2-Supporting-IRQs-and-FIQs-when-not-using-the-processor-Security-Extensions" class="headerlink" title="3.9.2 Supporting IRQs and FIQs when not using the processor Security Extensions"></a>3.9.2 Supporting IRQs and FIQs when not using the processor Security Extensions</h5><p>FixMe [Figure 3-10 Using interrupt grouping to route IRQs and FIQs] Page70</p>
<p>On a GIC reset, for a GIC implementation that supports interrupt grouping, all interrupts are assigned to Group 0.<br>Therefore, to use this configuration, software executing on the processor must:<br>• Program the GICD_IGROUPRn registers to assign IRQ interrupts to Group 1.<br>• Set GICC_CTLR.FIQEn to 1, to assign Group 0 interrupts to FIQ.<br>• Set GICC_CTLR.AckCtl to 0, so that both FIQ and IRQ interrupts are acknowledged from the single address<br>space, using:<br>    — the GICC_IAR to acknowledge a Group 0 interrupt<br>    — the GICC_AIAR to acknowledge a Group 1 interrupt<br>    — the GICC_EOIR to indicate completion of a Group 0 interrupt<br>    — the GICC_AEOIR to indicate completion of a Group 1 interrupt.<br>However, GICC_AIAR and GICC_AEOIR are implemented only in a GICv2 implementation. A processor<br>operating with a GICv1 implementation might have to use the deprecated mode of operation with<br>GICC_CTLR.AckCtl set to 1(意味着GRP0 GRP1 都是用GICC_IAR, GICC_EOIR).<br>• Configure the required binary point support model, by either:<br>    — setting GICC_CTLR.CBPR to 0, so that Group 0 uses GICC_BPR, and Group 1 uses GICC_ABPR<br>    — setting GICC_CTLR.CBPR to 1, so that Group 0 and Group 1 use a common binary point register,<br>    GICC_BPR.</p>
<p>由于没有security, 我们只是人为的将IRQ 分配到GRP1中，将FIQ 分配到GRP0中。因此，并不需要使能GICD_CTLR.EnableGrp0/1 GICC_CTLR.EnableGrp0/1 来让GIC与CPU 支持真正的Group 即security，我们只是使用不同的寄存器</p>
<ul>
<li>GICC_IAR &amp;&amp; GICC_AIAR获知ID</li>
<li>GICC_EOIR &amp;&amp; GICC_AEOIR 结束中断</li>
<li>GICC_CTLR.CBPR &amp;&amp; GICC_CTLR.ABPR </li>
</ul>
<h5 id="3-9-3-Supporting-IRQs-and-FIQs-in-a-virtualized-processor-environment"><a href="#3-9-3-Supporting-IRQs-and-FIQs-in-a-virtualized-processor-environment" class="headerlink" title="3.9.3 Supporting IRQs and FIQs in a virtualized processor environment"></a>3.9.3 Supporting IRQs and FIQs in a virtualized processor environment</h5><p>Fixme [Figure 3-11 Using the GIC in a virtualized system] page72</p>
<p>• Secure software assigns:<br>    — Secure interrupts to Group 0, signaled to the processor as FIQs<br>    — Non-secure interrupts to Group 1, signaled to the processor as IRQs</p>
<p>• A hypervisor:<br>    — Implements a virtual distributor, using features of the Virtualization Extension on the GIC. This<br>    virtual distributor can virtualize IRQ interrupts from the GIC as Virtual IRQ and Virtual FIQ<br>    interrupts, that it routes to an appropriate virtual machine.<br>    — Routes physical IRQs to Hyp mode, so they can be serviced by the virtual distributor</p>
<p>• A Guest OS running on a virtual machine assigns interrupts to Group 0 or Group 1, to assign them as FIQs<br>or IRQs, using the model described in [Supporting IRQs and FIQs when not using the processor Security<br>Extensions]</p>
<p>When the GIC signals an IRQ to the processor, the interrupt is routed to Hyp mode. The hypervisor determines<br>whether the interrupt is for itself, or for a Guest OS. If it is for a Guest OS it determines:<br>• which Guest OS must handle the interrupt<br>• whether that Guest OS has configured the interrupt as an FIQ or as an IRQ<br>• the interrupt priority, based on the priority configuration by the target Guest OS.</p>
<p>Note:  (<strong>Guest OS 可能不止一个</strong>)<br>• On receiving an IRQ that cannot be handled by the current Guest OS, the hypervisor can either:<br>— transfer control to a Guest OS that can handle the interrupt<br>— mark the interrupt as pending, as part of the saved context of the appropriate Guest OS.<br>• A system can have some interrupts that can be handled by more that one Guest OS, and other interrupts that<br>must be routed to a specific Guest OS.</p>
<p>A Guest OS handles a virtual interrupt exactly as it would handle the corresponding physical interrupt. <strong>The Guest OS cannot detect that it is handling a virtual interrupt rather than a physical interrupt.</strong></p>
<p>Guest OS 并不知道处理的是虚拟中断。</p>
<h3 id="4-Programmers’-Model"><a href="#4-Programmers’-Model" class="headerlink" title="4. Programmers’ Model"></a>4. Programmers’ Model</h3><h4 id="4-1-1-GIC-register-names"><a href="#4-1-1-GIC-register-names" class="headerlink" title="4.1.1 GIC register names"></a>4.1.1 GIC register names</h4><p>All of the GIC registers have names that provide a short mnemonic for the function of the register. In these names:<br>• the first three letters are GIC, indicating a GIC register<br>• the fourth letter is one of:<br>    — D, indicating a Distributor register<br>    — C, indicating a CPU interface register<br>    — H, indicating a virtual interface control register, typically accessed by a hypervisor<br>    — V, indicating a virtual CPU interface register.</p>
<p>Note：<br>Chapter 5 GIC Support for Virtualization describes the GICH_<em> and GICV_</em> registers.</p>
<h4 id="4-1-2-Distributor-register-map"><a href="#4-1-2-Distributor-register-map" class="headerlink" title="4.1.2 Distributor register map"></a>4.1.2 Distributor register map</h4><p>Fixme [Table 4-1 Distributor register map] page74</p>
<h4 id="4-1-3-CPU-interface-register-map"><a href="#4-1-3-CPU-interface-register-map" class="headerlink" title="4.1.3 CPU interface register map"></a>4.1.3 CPU interface register map</h4><p>For a multiprocessor implementation, the GIC implements a set of CPU interface registers for each CPU interface.<br><strong>ARM strongly recommends that each processor has the same CPU interface base address for the CPU interface that connects it to the GIC. This is the private CPU interface base address for that processor.</strong></p>
<p>Fixme [Table 4-2 CPU interface register map] page76</p>
<h4 id="4-1-4-GIC-register-access"><a href="#4-1-4-GIC-register-access" class="headerlink" title="4.1.4 GIC register access"></a>4.1.4 GIC register access</h4><p>Note:<br>In the GIC architecture, all registers that are halfword-accessible or byte-accessible use a little endian memory order model.</p>
<p>If the GIC implements the GIC Security Extensions these affect register accesses as follows:<br>• some registers are banked, see Register banking<br>• some registers are accessible only using Secure accesses<br>• optionally, the GIC supports lockdown of the values of some registers</p>
<p><strong>Register banking</strong><br>Register banking refers to providing multiple copies of a register at the same address.</p>
<p>The GIC banks registers in the following cases:<br>• If the GIC implements the Security Extensions, some registers are banked to provide separate Secure and<br>Non-secure copies of the registers. The Secure and Non-secure register bit assignments can differ. A Secure<br>access to the register address accesses the Secure copy of the register, and a Non-secure access accesses the<br>Non-secure copy. </p>
<p>• If the GIC is implemented as part of a multiprocessor system:<br>    — Some registers are banked to provide a separate copy for each connected processor. These <strong>include the registers associated with PPIs and SGIs, and the GICD_NSACRn, when implemented.</strong><br>    — The GIC implements the CPU interface registers <strong>independently for each CPU interface</strong>, and each<br>    connected processor accesses these registers for the interface it connects to.</p>
<h4 id="4-1-5-Enabling-and-disabling-the-Distributor-and-CPU-interfaces"><a href="#4-1-5-Enabling-and-disabling-the-Distributor-and-CPU-interfaces" class="headerlink" title="4.1.5 Enabling and disabling the Distributor and CPU interfaces"></a>4.1.5 Enabling and disabling the Distributor and CPU interfaces</h4><p><strong>Implementations that support interrupt grouping</strong><br>In a GIC that supports interrupt grouping:<br>• the GICD_CTLR.EnableGrp0 bit<br>• the GICD_CTLR.EnableGrp1 bit<br>• the GICC_CTLR.EnableGrp0 bit<br>• the GICC_CTLR.EnableGrp1 bit </p>
<p>For the Distributor:<br>• If the GICD_CTLR.EnableGrp0 and GICD_CTLR.EnableGrp1 bits are both 0:<br>    — <strong>the Distributor does not forward pending interrupts to the CPU interfaces</strong><br>    — it is IMPLEMENTATION DEFINED whether an edge-triggered interrupt signal sets the interrupt to the<br>    pending state.<br>    — <strong>reads of GICC_IAR, GICC_AIAR, GICC_HPPIR, or GICC_AHPPIR return a spurious interrupt ID</strong><br>    — software can read or write the Distributor registers<br>    — it is IMPLEMENTATION DEFINED whether SGIs can be set pending using GICD_SGIR</p>
<p>• If either, but not both, of the GICD_CTLR.EnableGrp0 and GICD_CTLR.EnableGrp1 bits is set to<br>    — GICD_CTLR.EnableGrp0 set to 0 and GICD_CTLR.EnableGrp1 set to 1, and the highest priority<br>    pending interrupt is in group 0<br>    — GICD_CTLR.EnableGrp0 set to 1 and GICD_CTLR.EnableGrp1 set to 0, and the highest priority<br>    pending interrupt is in group 1. (ARM 强烈不推荐这样，这样GRP0 优先级是小于GRP1)</p>
<p><strong>ARM strongly recommends that all Group 0 interrupts are assigned a higher priority than all Group 1 interrupts.</strong></p>
<p>For a CPU interface, when GICC_CTLR.AckCtl == 0:<br>• When GICC_CTLR.EnableGrp0 == 0<br>    — Group 0 interrupts forwarded from the Distributor are not signaled to the processor<br>    — any read of GICC_IAR returns a spurious interrupt ID<br>• When GICC_CTLR.EnableGrp0 == 1, Group 0 interrupts forwarded from the Distributor are signaled to the<br>processor.<br>• When GICC_CTLR.EnableGrp1 == 0<br>    — Group 1 interrupts forwarded from the Distributor are not signaled to the processor<br>    — any read of GICC_AIAR returns a spurious interrupt ID<br>• When GICC_CTLR.EnableGrp1 == 1, Group 1 interrupts forwarded from the Distributor are signaled to the<br>processor<br>• if either GICC_CTLR.EnableGrp0 or GICC_CTLR.EnableGrp1 is set to 0, and there is a pending interrupt<br>of sufficient priority in the disabled group, it is IMPLEMENTATION DEFINED whether a read of GICC_HPPIR<br>returns the ID of that interrupt, or a spurious interrupt ID</p>
<p>For a CPU interface, when GICC_CTLR.AckCtl == 1:<br>• When GICC_CTLR.EnableGrp1 == 0, any Non-secure read of GICC_IAR returns a spurious interrupt ID<br>• When GICC_CTLR.EnableGrp0 == 0:<br>— if GICC_CTLR.EnableGrp1 == 0, any Secure read of GICC_AIAR returns a spurious interrupt ID<br>— if GICC_CTLR.EnableGrp1 == 1, Group 0 interrupts are ignored and GICC_IAR behaves as<br>GICC_AIAR<br>• When GICC_CTLR.EnableGrp1 == 0, a Secure read of GICC_AIAR always returns a spurious interrupt ID<br>• if either GICC_CTLR.EnableGrp0 or GICC_CTLR.EnableGrp1 is set to 0, and there is a pending interrupt<br>of sufficient priority in the disabled group, it is IMPLEMENTATION DEFINED whether a read of GICC_HPPIR<br>returns the ID of that interrupt, or a spurious interrupt ID.</p>
<p>Note:<br><strong>ARM deprecates use of GICC_CTLR.AckCtl, and strongly recommends using a software model where GICC_CTLR.AckCtl is set to 0.</strong></p>
<hr>
<p><strong>Implementations that do not support interrupt grouping</strong><br>In a GIC that does not support interrupt grouping:<br>• the GICD_CTLR.Enable bit controls the forwarding of interrupts from the Distributor to the CPU interfaces<br>• the GICC_CTLR.Enable bit controls the signaling of interrupts by the CPU interface to the connected processor.</p>
<p>For the Distributor:<br>• When GICD_CTLR.Enable is set to 1, the Distributor forwards the highest priority pending interrupt for each<br>CPU interface, subject to the prioritization rules.<br>• When GICD_CTLR.Enable is set to 0:<br>    — the Distributor does not forward pending interrupts to the CPU interfaces<br>    — it is IMPLEMENTATION DEFINED whether an edge-triggered interrupt signal sets the interrupt to the<br>    pending state.<br>    — reads of GICC_IAR, GICC_AIAR, GICC_HPPIR, or GICC_AHPPIR return a spurious interrupt ID<br>    — software can read or write the Distributor registers<br>    — it is IMPLEMENTATION DEFINED whether SGIs can be set pending using GICD_SGIR.</p>
<p>For a CPU interface:<br>• When GICC_CTLR.Enable is set to 1, the highest priority pending interrupt forwarded from the Distributor<br>to the CPU interface is signaled to the connected processor<br>• When GICC_CTLR.Enable is set to 0:<br>    — any pending interrupts forwarded from the Distributor are not signaled to the processor<br>    — software can read or write the CPU interface registers<br>    — any read of the GICC_IAR returns a spurious interrupt ID<br>    — if the Distributor is forwarding an interrupt to the CPU interface, that the interface cannot signal<br>    because GICC_CTLR.Enable is set to 0, it is IMPLEMENTATION DEFINED whether a read of<br>    GICC_HPPIR returns the ID of that interrupt, or a spurious interrupt ID.</p>
<h3 id="4-2-Effect-of-the-GIC-Security-Extensions-on-the-programmers’-model"><a href="#4-2-Effect-of-the-GIC-Security-Extensions-on-the-programmers’-model" class="headerlink" title="4.2 Effect of the GIC Security Extensions on the programmers’ model"></a>4.2 Effect of the GIC Security Extensions on the programmers’ model</h3><p>If the GIC implements the Security Extensions, <strong>the GICD_TYPER.SecurityExtn bit is RAO.</strong>.</p>
<p>The GIC Security Extensions provide the following features:<br>• The GIC must support interrupt grouping.<br>• Register implementations that are consistent with those on a processor that implements the ARM Security<br>Extensions, with banked.</p>
<p>The ARM Architecture Reference Manual, ARMv7-A and ARMv7-R edition defines the following ARM Security<br>Extensions register types:</p>
<ul>
<li><strong>Banked</strong><br>  The device implements Secure and Non-secure copies of the register. The register bit assignments<br>  can differ in the Secure and Non-secure copies of a register. A Secure access always accesses the<br>  Secure copy of the register, and a Non-secure access always accesses the Non-secure copy.<pre><code>Note
The GIC can also bank registers when implemented as part of a multiprocessor system, where
registers associated with PPIs or SGIs are banked to provide a separate copy for each connected
processor.
</code></pre></li>
<li><strong>Secure</strong><br>  The register is accessible only from a Secure access. The address of a Secure register is RAZ/WI to<br>  any Non-secure access.</li>
<li><strong>Common</strong><br>  The register is accessible from both Secure and Non-secure accesses. The access permissions of<br>  some or all fields in the register might depend on whether the access is Secure or Non-secure.</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">Register</th>
<th style="text-align:center">Type</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GICD_CTLR</td>
<td style="text-align:center">Banked</td>
<td style="text-align:center">Distributor Control Register</td>
</tr>
<tr>
<td style="text-align:center">GICD_TYPER</td>
<td style="text-align:center">Common</td>
<td style="text-align:center">Interrupt Controller Type Register</td>
</tr>
<tr>
<td style="text-align:center">GICD_IGROUPRn</td>
<td style="text-align:center">Secure</td>
<td style="text-align:center">Interrupt Group Registers</td>
</tr>
<tr>
<td style="text-align:center">GICD_SGIR</td>
<td style="text-align:center">Common</td>
<td style="text-align:center">Software Generated Interrupt Register</td>
</tr>
<tr>
<td style="text-align:center">GICC_CTLR</td>
<td style="text-align:center">Banked</td>
<td style="text-align:center">CPU Interface Control Register</td>
</tr>
<tr>
<td style="text-align:center">GICC_BPR</td>
<td style="text-align:center">Banked</td>
<td style="text-align:center">Binary Point Register</td>
</tr>
<tr>
<td style="text-align:center">GICC_ABPR</td>
<td style="text-align:center">Secure</td>
<td style="text-align:center">Aliased Binary Point Register</td>
</tr>
<tr>
<td style="text-align:center">GICC_AIAR</td>
<td style="text-align:center">Secure</td>
<td style="text-align:center">Aliased Interrupt Acknowledge Register</td>
</tr>
<tr>
<td style="text-align:center">GICC_AEOIR</td>
<td style="text-align:center">Secure</td>
<td style="text-align:center">Aliased End of Interrupt Register</td>
</tr>
<tr>
<td style="text-align:center">GICC_AHPPIR</td>
<td style="text-align:center">Secure</td>
<td style="text-align:center">Aliased Highest Priority Pending Interrupt Register</td>
</tr>
<tr>
<td style="text-align:center">GICC_NSAPRn</td>
<td style="text-align:center">Secure</td>
<td style="text-align:center">Non-secure Active Priorities Registers</td>
</tr>
</tbody>
</table>
<h4 id="4-2-1-Non-secure-access-to-register-fields-for-Group-0-interrupt-priorities"><a href="#4-2-1-Non-secure-access-to-register-fields-for-Group-0-interrupt-priorities" class="headerlink" title="4.2.1 Non-secure access to register fields for Group 0 interrupt priorities"></a>4.2.1 Non-secure access to register fields for Group 0 interrupt priorities</h4><p>Non-secure access to a priority field in the GICD_IPRIORITYRn<br>If the priority field corresponds to a Group 1 interrupt, the access operates as defined by the<br>Non-secure view of interrupt priority, see[Software views of interrupt priority in a GIC that includes<br>the Security Extensions]</p>
<p>Non-secure access to the GICC_PMR and GICC_RPR<br>• If the current priority mask value is in the range 0x00-0x7F:<br>    — a read access returns the value 0x00<br>    — the GIC ignores a write access to the GICC_PMR.<br>• If the current priority mask value is in the range 0x80-0xFF:<br>    — A read access returns the Non-secure view of the current value.<br>    — A write access to the GICC_PMR succeeds, based on the Non-secure view of the<br>    priority mask value written to the register. This means a Non-secure write cannot set<br>    a priority mask value in the rage 0x00-0x7F.</p>
<h4 id="4-2-2-Configuration-lockdown"><a href="#4-2-2-Configuration-lockdown" class="headerlink" title="4.2.2 Configuration lockdown"></a>4.2.2 Configuration lockdown</h4><p>This provides a control signal that the system can assert to prevent write access to:<br>• the register fields controlling a configured range of SPIs, when those SPIs are configured as Group 0<br>interrupts<br>• some configuration registers.</p>
<p>When the control signal is asserted, the affected register fields and registers are described as being locked down.<br><strong>Lockdown is controlled by an active HIGH disable signal, CFGSDISABLE</strong>. That is, the system asserts<br>CFGSDISABLE HIGH to disable write access to the register fields and registers.</p>
<p>The SPIs that can be locked down are called lockable SPIs (LSPIs).<br>• The GICD_TYPER.LSPI field defines the maximum number of LSPIs. If GICD_TYPER.LSPI is greater<br>than 0 then the possible LSPIs have interrupt IDs 32 to (31+(GICD_TYPER.LSPI)).<br>    Note:<br>    GICD_TYPER.LSPI only defines the range of possible LSPIs. The GIC might not support all the interrupts<br>    in this range.</p>
<p>If GICD_TYPER.LSPI is 0 lockdown is not supported.</p>
<p>When the SPI control fields and configuration registers are locked down, the GIC prevents write accesses to:<br>• The EnableGrp0 bit of the Secure copy of GICD_CTLR.<br>• The following bits in the Secure copy of GICC_CTLR:<br>    — EOImodeS<br>    — IRQBypDisGrp0<br>    — FIQBypDisGrp0<br>    — CBPR<br>    — FIQEn<br>    — AckCtl<br>    — EnableGrp0<br>• Fields in the GICD_ISENABLERn, GICD_ICENABLERn, GICD_ISPENDRn, GICD_ICPENDRn,<br>GICD_ISACTIVERn, GICD_ICACTIVERn, GICD_IPRIORITYRn, GICD_ITARGETSRn, and<br>GICD_ICFGRn registers that correspond to Lockable SPIs that are configured as Group 0:<br>• Fields in the GICD_IGROUPRn registers that correspond to lockable SPIs that are configured as Group 0. If<br>a lockable SPI is reconfigured from Group 1 to Group 0 while CFGSDISABLE remains HIGH, the GIC<br>prevents any more writes to GICD_IGROUPRn fields that correspond to that SPI, and the SPI becomes<br>locked.    </p>
<h4 id="4-3-Distributor-register-descriptions"><a href="#4-3-Distributor-register-descriptions" class="headerlink" title="4.3 Distributor register descriptions"></a>4.3 Distributor register descriptions</h4><p>The following sections describe the Distributor registers:<br>• Distributor Control Register, GICD_CTLR on page 4-85<br>• Interrupt Controller Type Register, GICD_TYPER on page 4-88<br>• Distributor Implementer Identification Register, GICD_IIDR on page 4-90<br>• Interrupt Group Registers, GICD_IGROUPRn on page 4-91<br>• Interrupt Set-Enable Registers, GICD_ISENABLERn on page 4-93<br>• Interrupt Clear-Enable Registers, GICD_ICENABLERn on page 4-95<br>• Interrupt Set-Pending Registers, GICD_ISPENDRn on page 4-97<br>• Interrupt Clear-Pending Registers, GICD_ICPENDRn on page 4-99<br>• Interrupt Set-Active Registers, GICD_ISACTIVERn on page 4-102<br>• Interrupt Clear-Active Registers, GICD_ICACTIVERn on page 4-103<br>• Interrupt Priority Registers, GICD_IPRIORITYRn on page 4-104<br>• Interrupt Processor Targets Registers, GICD_ITARGETSRn on page 4-106<br>• Interrupt Configuration Registers, GICD_ICFGRn on page 4-109<br>• Non-secure Access Control Registers, GICD_NSACRn on page 4-111<br>• Software Generated Interrupt Register, GICD_SGIR on page 4-113<br>• SGI Clear-Pending Registers, GICD_CPENDSGIRn on page 4-115<br>• SGI Set-Pending Registers, GICD_SPENDSGIRn on page 4-117<br>• Identification registers on page 4-119.</p>
<h5 id="4-3-1-Distributor-Control-Register-GICD-CTLR"><a href="#4-3-1-Distributor-Control-Register-GICD-CTLR" class="headerlink" title="4.3.1 Distributor Control Register, GICD_CTLR"></a>4.3.1 Distributor Control Register, GICD_CTLR</h5><p>Enables the forwarding of pending interrupts from the Distributor to the CPU interfaces.</p>
<p>Fixme [Figure 4-1 GICD_CTLR bit assignments, GICv1 without Security Extensions or Non-secure]图片 Page85</p>
<p>Fixme [Figure 4-2 GICD_CTLR bit assignments, GICv2, and GICv1 Secure copy]图片 Page85</p>
<h5 id="4-3-2-Interrupt-Controller-Type-Register-GICD-TYPER"><a href="#4-3-2-Interrupt-Controller-Type-Register-GICD-TYPER" class="headerlink" title="4.3.2 Interrupt Controller Type Register, GICD_TYPER"></a>4.3.2 Interrupt Controller Type Register, GICD_TYPER</h5><p>Provides information about the configuration of the GIC. It indicates:<br>• whether the GIC implements the <strong>Security Extensions</strong><br>• the <strong>maximum number of interrupt IDs</strong> that the GIC supports<br>• the <strong>number of CPU interfaces</strong> implemented<br>• if the GIC implements the Security Extensions, the <strong>maximum number of implemented Lockable Shared Peripheral Interrupts (LSPIs)</strong>.</p>
<p>Fixme [Figure 4-3 GICD_TYPER bit assignments] 图片Page88</p>
<p>[15:11]  LSPI             If the GIC implements the Security Extensions, the value of this field is the maximum number of<br>                        implemented lockable SPIs, from 0 (0b00000) to 31 (0b11111). If this field is 0b00000 then the GIC does not implement configuration lockdown. If the GIC does not implement the Security Extensions, this field is reserved.</p>
<p>[10]      SecurityExtn     Indicates whether the GIC implements the Security Extensions.<br>                            0  Security Extensions not implemented.<br>                            1  Security Extensions implemented.                    </p>
<p>[7:5]   CPUNumber         Indicates the number of implemented CPU interfaces. The number of implemented CPU interfaces is<br>                        one more than the value of this field, for example if this field is 0b011, there are four CPU interfaces. If<br>                        the GIC implements the Virtualization Extensions, this is also the number of virtual CPU interfaces    </p>
<p>[4:0]  ITLinesNumber     Indicates the maximum number of interrupts that the GIC supports.If ITLinesNumber=N, the<br>                        maximum number of interrupts is 32 * (N+1). interrupt IDs 1020-1023 are reserved for<br>                        special purposes</p>
<p>The ITLinesNumber field only indicates the maximum number of SPIs that the GIC might support. This value<br>determines the number of implemented interrupt registers, that is, the number of instances of the following registers:<br>• GICD_IGROUPRn<br>• GICD_ISENABLERn<br>• GICD_ICENABLERn<br>• GICD_ISPENDRn<br>• GICD_ICPENDRn<br>• GICD_ISACTIVERn<br>• GICD_IPRIORITYRn<br>• GICD_ITARGETSRn<br>• GICD_ICFGRn.</p>
<h5 id="4-3-3-Distributor-Implementer-Identification-Register-GICD-IIDR"><a href="#4-3-3-Distributor-Implementer-Identification-Register-GICD-IIDR" class="headerlink" title="4.3.3 Distributor Implementer Identification Register, GICD_IIDR"></a>4.3.3 Distributor Implementer Identification Register, GICD_IIDR</h5><p>Provides information about the implementer and revision of the Distributor.<br>主要用于记录GIC 的产品ID， 变体ID， 实现公司ID<br>Fixme [Figure 4-4 GICD_IIDR bit assignments] 图片Page90</p>
<h5 id="4-3-4-Interrupt-Group-Registers-GICD-IGROUPRn"><a href="#4-3-4-Interrupt-Group-Registers-GICD-IGROUPRn" class="headerlink" title="4.3.4 Interrupt Group Registers, GICD_IGROUPRn"></a>4.3.4 Interrupt Group Registers, GICD_IGROUPRn</h5><p>The GICD_IGROUPR registers provide a status bit for each interrupt supported by the GIC.<br>Each bit controls whether the corresponding interrupt is in Group 0 or Group 1.<br>Fixme [Figure 4-5 GICD_IGROUPR bit assignments] 图片Page91</p>
<p>[31:0] Group status bits， For each bit:<br>    0 The corresponding interrupt is Group 0.<br>    1 The corresponding interrupt is Group 1.</p>
<p><strong>Reset Value</strong><br>On start-up or reset, each interrupt with ID32 or higher resets as Group 0 and therefore all SPIs are Group 0.</p>
<h5 id="4-3-5-Interrupt-Set-Enable-Registers-GICD-ISENABLERn"><a href="#4-3-5-Interrupt-Set-Enable-Registers-GICD-ISENABLERn" class="headerlink" title="4.3.5 Interrupt Set-Enable Registers, GICD_ISENABLERn"></a>4.3.5 Interrupt Set-Enable Registers, GICD_ISENABLERn</h5><p>The GICD_ISENABLERs provide a Set-enable bit for each interrupt supported by the GIC.<br>Writing 1 to a Set-enable bit enables forwarding of the corresponding interrupt from the<br>Distributor to the CPU interfaces. Reading a bit identifies whether the interrupt is enabled.</p>
<p>These registers are available in all configurations of the GIC. If the GIC implements the<br>Security Extensions these registers are Common</p>
<p>In a multiprocessor implementation, GICD_ISENABLER0 is banked for each connected<br>processor. This register holds the Set-enable bits for interrupts 0-31.</p>
<h5 id="4-3-6-Interrupt-Clear-Enable-Registers-GICD-ICENABLERn"><a href="#4-3-6-Interrupt-Clear-Enable-Registers-GICD-ICENABLERn" class="headerlink" title="4.3.6 Interrupt Clear-Enable Registers, GICD_ICENABLERn"></a>4.3.6 Interrupt Clear-Enable Registers, GICD_ICENABLERn</h5><p>The GICD_ICENABLERs provide a Clear-enable bit for each interrupt supported by the<br>GIC. Writing 1 to a Clear-enable bit disables forwarding of the corresponding interrupt from<br>the Distributor to the CPU interfaces.</p>
<p>In a multiprocessor implementation, GICD_ICENABLER0 is banked for each connected<br>processor. This register holds the Clear-enable bits for interrupts 0-31.</p>
<h5 id="4-3-7-Interrupt-Set-Pending-Registers-GICD-ISPENDRn"><a href="#4-3-7-Interrupt-Set-Pending-Registers-GICD-ISPENDRn" class="headerlink" title="4.3.7 Interrupt Set-Pending Registers, GICD_ISPENDRn"></a>4.3.7 Interrupt Set-Pending Registers, GICD_ISPENDRn</h5><p>The GICD_ISPENDRs provide a Set-pending bit for each interrupt supported by the GIC.<br>Writing 1 to a Set-pending bit sets the status of the corresponding peripheral interrupt to<br>pending. Reading a bit identifies whether the interrupt is pending.</p>
<p>In a multiprocessor implementation, GICD_ISPENDR0 is banked for each connected<br>processor. This register holds the Set-pending bits for interrupts 0-31.</p>
<p>For SPIs and PPIs<br>Writes<br>0         Has no effect.<br>1         The effect depends on whether the interrupt is edge-triggered or<br>        level-sensitive.</p>
<p><strong>Edge-triggered</strong><br>Changes the status of the corresponding interrupt to:<br>• pending if it was previously inactive<br>• active and pending if it was previously active.<br>Has no effect if the interrupt is already pendinga.</p>
<p><strong>Level sensitive</strong><br>If the corresponding interrupt is not pendinga, changes the status<br>of the corresponding interrupt to:<br>• pending if it was previously inactive<br>• active and pending if it was previously active.</p>
<p>If the interrupt is already pendinga:<br>• because of a write to the GICD_ISPENDR, the write has<br>no effect<br>• because the corresponding interrupt signal is asserted, the<br>write has no effect on the status of the interrupt, but the<br>interrupt remains pendinga if the interrupt signal is<br>deasserted.</p>
<h5 id="4-3-8-Interrupt-Clear-Pending-Registers-GICD-ICPENDRn"><a href="#4-3-8-Interrupt-Clear-Pending-Registers-GICD-ICPENDRn" class="headerlink" title="4.3.8 Interrupt Clear-Pending Registers, GICD_ICPENDRn"></a>4.3.8 Interrupt Clear-Pending Registers, GICD_ICPENDRn</h5><p>The GICD_ICPENDRs provide a Clear-pending bit for each interrupt supported by the GIC.<br>Writing 1 to a Clear-pending bit clears the pending state of the corresponding peripheral<br>interrupt. Reading a bit identifies whether the interrupt is pending</p>
<p>In a multiprocessor implementation, GICD_ICPENDR0 is banked for each connected<br>processor. This register holds the Clear-pending bits for interrupts 0-31.</p>
<h5 id="4-3-9-Interrupt-Set-Active-Registers-GICD-ISACTIVERn"><a href="#4-3-9-Interrupt-Set-Active-Registers-GICD-ISACTIVERn" class="headerlink" title="4.3.9 Interrupt Set-Active Registers, GICD_ISACTIVERn"></a>4.3.9 Interrupt Set-Active Registers, GICD_ISACTIVERn</h5><p>The GICD_ISACTIVERs provide a Set-active bit for each interrupt that the GIC supports.<br>Writing to a Set-active bit Activates the corresponding interrupt. <strong>These registers are used when preserving and restoring GIC state</strong></p>
<p>In a multiprocessor implementation, GICD_ISACTIVER0 is banked for each connected<br>processor. This register holds the Set-active bits for interrupts 0-31.</p>
<h5 id="4-3-10-Interrupt-Clear-Active-Registers-GICD-ICACTIVERn"><a href="#4-3-10-Interrupt-Clear-Active-Registers-GICD-ICACTIVERn" class="headerlink" title="4.3.10 Interrupt Clear-Active Registers, GICD_ICACTIVERn"></a>4.3.10 Interrupt Clear-Active Registers, GICD_ICACTIVERn</h5><p>The GICD_ICACTIVERs provide a Clear-active bit for each interrupt that the GIC<br>supports. Writing to a Clear-active bit Deactivates the corresponding interrupt. These<br>registers are used when preserving and restoring GIC state.</p>
<p>In a multiprocessor implementation, GICD_ICACTIVER0 is banked for each connected<br>processor. This register holds the Clear-active bits for interrupts 0-31.</p>
<h5 id="4-3-11-Interrupt-Priority-Registers-GICD-IPRIORITYRn"><a href="#4-3-11-Interrupt-Priority-Registers-GICD-IPRIORITYRn" class="headerlink" title="4.3.11 Interrupt Priority Registers, GICD_IPRIORITYRn"></a>4.3.11 Interrupt Priority Registers, GICD_IPRIORITYRn</h5><p>The GICD_IPRIORITYRs <strong>provide an 8-bit priority field for each interrupt</strong> supported by the<br>GIC. This field stores the priority of the corresponding interrupt.</p>
<p>A GIC might implement fewer than eight priority bits, but must implement at least bits [7:4]<br>of each field. In each field, unimplemented bits are RAZ/WI. see [3.3 Interrupt prioritization]<br>我们可以实现CPU Interface 的Group level.</p>
<p>In a multiprocessor implementation, GICD_IPRIORITYR0 to GICD_IPRIORITYR7 are<br>banked for each connected processor. These registers hold the Priority fields for interrupts<br>0-31.</p>
<p>Fixme [Figure 4-13 GICD_IPRIORITYR bit assignments] 图片Page104</p>
<h5 id="4-3-12-Interrupt-Processor-Targets-Registers-GICD-ITARGETSRn"><a href="#4-3-12-Interrupt-Processor-Targets-Registers-GICD-ITARGETSRn" class="headerlink" title="4.3.12 Interrupt Processor Targets Registers, GICD_ITARGETSRn"></a>4.3.12 Interrupt Processor Targets Registers, GICD_ITARGETSRn</h5><p>The GICD_ITARGETSRs <strong>provide an 8-bit CPU targets field for each interrupt supported</strong><br>by the GIC. <strong>This field stores the list of target processors for the interrupt.</strong> That is, it holds<br>the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and<br>has sufficient priority.</p>
<p>In a multiprocessor implementation, GICD_ITARGETSR0 to GICD_ITARGETSR7 are<br>banked for each connected processor. These registers hold the CPU targets fields for<br>interrupts 0-31.</p>
<p>Fixme [Figure 4-14 GICD_ITARGETSR bit assignments] 图片Page106</p>
<p>Table 4-17 shows how each bit of a CPU targets field targets the interrupt at one of the CPU interfaces.<br>Fixme [Table 4-17 Meaning of CPU targets field bit values] 图片Page107</p>
<p>Software can write to an GICD_ITARGETSR at any time.  （对Active无效，对pending 的有效）<br>Any change to a CPU targets field value:<br>• Has no effect on any active interrupt. This means that removing a CPU interface from a targets list does not<br>cancel an active state for that interrupt on that CPU interface.<br>• Has an effect on any pending interrupts. This means:<br>    — adding a CPU interface to the target list of a pending interrupt makes that interrupt pending on that<br>    CPU interface<br>    — removing a CPU interface from the target list of a pending interrupt removes the pending state of that<br>    interrupt on that CPU interface<br>• If it applies to an interrupt that is active and pending, does not change the interrupt targets until the active<br>status is cleared.    </p>
<h5 id="4-3-13-Interrupt-Configuration-Registers-GICD-ICFGRn"><a href="#4-3-13-Interrupt-Configuration-Registers-GICD-ICFGRn" class="headerlink" title="4.3.13 Interrupt Configuration Registers, GICD_ICFGRn"></a>4.3.13 Interrupt Configuration Registers, GICD_ICFGRn</h5><p><strong>The GICD_ICFGRs provide a 2-bit Int_config field for each interrupt supported by the GIC</strong>.<br>This field identifies whether the corresponding interrupt is <strong>edge-triggered or level-sensitive.</strong></p>
<p>Fixme [Figure 4-15 GICD_ICFGR bit assignments] 图片Page109</p>
<p>For SGIs, Int_config fields are read-only, meaning that GICD_ICFGR0 is read-only.<br>Before changing the value of a programmable Int_config field, software must disable the<br>corresponding interrupt, otherwise GIC behavior is UNPREDICTABLE.</p>
<p>These registers are available in all configurations of the GIC. If the GIC implements the<br>Security Extensions these registers are Common.<br>In a multiprocessor implementation, if bit[1] of the Int_config field for any PPI is<br>programmable then GICD_ICFGR1 is banked for each connected processor. This register<br>holds the Int_config fields for the PPIs, interrupts 16-31.</p>
<p>BITS        Name                        Function<br>[2F+1:2F]     Int_config, field F         For Int_config[1], the most significant bit, bit [2F+1], the encoding is:<br>                                        0 Corresponding interrupt is level-sensitive.<br>                                        1 Corresponding interrupt is edge-triggered.<br>                                        Int_config[0], the least significant bit, bit [2F], is reserved, but see Table 4-19 for the encoding of<br>                                        this bit on some early implementations of this GIC architecture.</p>
<pre><code>For SGIs:
Int_config[1] Not programmable, RAO/WI.

For PPIs and SPIs:
Int_config[1] For SPIs, this bit is programmable.a For PPIs it is IMPLEMENTATION DEFINED
whether this bit is programmable. A read of this bit always returns the correct value
to indicate whether the corresponding interrupt is level-sensitive or edge-triggered.
</code></pre><h5 id="4-3-14-Non-secure-Access-Control-Registers-GICD-NSACRn"><a href="#4-3-14-Non-secure-Access-Control-Registers-GICD-NSACRn" class="headerlink" title="4.3.14 Non-secure Access Control Registers, GICD_NSACRn"></a>4.3.14 Non-secure Access Control Registers, GICD_NSACRn</h5><p>The GICD_NSACRs enable Secure software to permit Non-secure software on a particular<br>processor to create and manage Group 0 interrupts. They provide an access control for each<br>implemented interrupt.</p>
<p>The GICD_NSACRn registers do not support PPI accesses, meaning that GICD_NSACR0 bits [31:16] are<br>RAZ/WI.</p>
<p>Fixme [Figure 4-16 GICD_NSACR bit assignments] 图片Page111</p>
<p>BITS            Name                    Function<br>[2F+1:2F]         NS_access, Field F         If the corresponding interrupt does not support configurable Non-secure access, the field is<br>                                        RAZ/WI. Otherwise, the field is RW and configures the level of Non-secure access permitted<br>                                        when the interrupt is in Group 0. If the interrupt is in Group 1, this field is ignored. The possible<br>                                        values of the field are:</p>
<pre><code>0b00 No Non-secure access is permitted to fields associated with the corresponding
interrupt.

0b01 Non-secure write access is permitted to fields associated with the corresponding
interrupt in the GICD_ISPENDRn registers. A Non-secure write access to
GICD_SGIR is permitted to generate a Group 0 SGI for the corresponding
interrupt.

0b10 Adds Non-secure write access permission to fields associated with the
corresponding interrupt in the GICD_ICPENDRn registers. Also adds
Non-secure read access permission to fields associated with the corresponding
interrupt in the GICD_ISACTIVERn and GICD_ICACTIVERn registers.

0b11 Adds Non-secure read and write access permission to fields associated with the
corresponding interrupt in the GICD_ITARGETSRn registers
</code></pre><h5 id="4-3-15-Software-Generated-Interrupt-Register-GICD-SGIR"><a href="#4-3-15-Software-Generated-Interrupt-Register-GICD-SGIR" class="headerlink" title="4.3.15 Software Generated Interrupt Register, GICD_SGIR"></a>4.3.15 Software Generated Interrupt Register, GICD_SGIR</h5><p>This register is available in all configurations of the GIC. If the GIC implements the<br>Security Extensions(read GICD_TYPER) this register is Common.<br>The NSATT field, bit [15], is implemented only if the GIC implements the Security<br>Extensions.</p>
<p>Fixme [Figure 4-17 GICD_SGIR bit assignments] 图片Page113</p>
<p>Bits         Name                 Function<br>[31:26]     -                     reserved.<br>[25:24]     TargetListFilter     Determines how the distributor must process the requested SGI:<br>                                0b00 Forward the interrupt to the CPU interfaces specified in the CPUTargetList fielda.<br>                                0b01 Forward the interrupt to all CPU interfaces except that of the processor that requested the<br>                                interrupt.<br>                                0b10 Forward the interrupt only to the CPU interface of the processor that requested the<br>                                interrupt.<br>                                0b11 Reserved.<br>[23:16]     CPUTargetList         When TargetList Filter = 0b00, defines the CPU interfaces to which the Distributor must forward the<br>                                interrupt.<br>                                Each bit of CPUTargetList[7:0] refers to the corresponding CPU interface, for example<br>                                CPUTargetList[0] corresponds to CPU interface 0. Setting a bit to 1 indicates that the interrupt must be<br>                                forwarded to the corresponding interface.<br>                                If this field is 0x00 when TargetListFilter is 0b00, the Distributor does not forward the interrupt to any<br>                                CPU interface.<br>[15]         NSATT                 Implemented only if the GIC includes the Security Extensions.<br>                                Specifies the required security value of the SGI:<br>                                0 Forward the SGI specified in the SGIINTID field to a specified CPU interface only if the<br>                                SGI is configured as Group 0 on that interface.<br>                                1 Forward the SGI specified in the SGIINTID field to a specified CPU interfaces only if<br>                                the SGI is configured as Group 1 on that interface.<br>                                This field is writable only by a Secure access. Any Non-secure write to the GICD_SGIR generates an<br>                                SGI only if the specified SGI is programmed as Group 1, regardless of the value of bit[15] of the write.<br>                                See SGI generation when the GIC implements the Security Extensions for more information.<br>                                Note<br>                                If GIC does not implement the Security Extensions, this field is reserved.<br>[3:0]         SGIINTID             The Interrupt ID of the SGI to forward to the specified CPU interfaces. The value of this field is the<br>                                Interrupt ID, in the range 0-15, for example a value of 0b0011 specifies Interrupt ID 3.                        </p>
<p><strong>SGI generation when the GIC implements the Security Extensions</strong><br>If the GIC implements the Security Extensions, whether an SGI is forwarded to a processor specified in the write<br>to the GICD_SGIR depends on:<br>• whether the write to the GICD_SGIR is Group 0 (Secure) or Group 1 (Non-secure)<br>• for a Secure write to the GICD_SGIR, the value of the GICD_SGIR.NSATT bit<br>• whether the specified SGI is configured as Group 0 (Secure) or Group 1 (Non-secure) on the targeted<br>processor.</p>
<p>Fixme [Table 4-22 Truth table for sending an SGI to a target processor] Page 114</p>
<h5 id="4-3-16-SGI-Clear-Pending-Registers-GICD-CPENDSGIRn"><a href="#4-3-16-SGI-Clear-Pending-Registers-GICD-CPENDSGIRn" class="headerlink" title="4.3.16 SGI Clear-Pending Registers, GICD_CPENDSGIRn"></a>4.3.16 SGI Clear-Pending Registers, GICD_CPENDSGIRn</h5><p>The GICD_CPENDSGIRs provide a clear-pending bit for each supported SGI and source<br>processor combination. When a processor writes a 1 to a clear-pending bit, the pending state<br>of the corresponding SGI for the corresponding source processor is removed, and no longer<br>targets the processor performing the write.</p>
<p>Note<br>• <strong>In a multiprocessor implementation, the processor accessing the register can change the SGI pending status only on the corresponding interface. Changing the pending status of an SGI for one target processor does not affect the status of that SGI on any other processor.</strong><br>• PPIs and SPIs both use the Interrupt Clear-Pending registers, GICD_ICPENDRn</p>
<p>These registers are present only in GICv2. The register locations are reserved in GICv1.In a multiprocessor implementation, the GICD_CPENDSGIRn registers are banked for each connected processor.</p>
<p>Four SGI Clear-Pending registers are implemented.each register contains eight clear-pending bits for each of four SGIs.<br>In a multiprocessor implementation, the GICD_CPENDSGIRn registers are banked for each connected processor.</p>
<p>一共四个 GICD_CPENDSGIR寄存器，每个寄存器含有四个8 bits，分别代表了四个SGIs。</p>
<p>Fixme [Figure 4-18 GICD_CPENDSGIR bit assignments] Page 115</p>
<p>Bits                         Name                         Function<br>[8y+7:8y], for y=0 to 3     SGI x Clear-pending bits      For each bit:<br>                                                        Reads     0 SGI x from the corresponding processor is not pendinga.<br>                                                                1 SGI x from the corresponding processor is pendinga.<br>                                                        Writes     0 Has no effect.<br>                                                                1 Removes the pending state of SGI x for the corresponding processor<br>                                                        Note<br>                                                        All accesses relate only to SGIs that target the processor making the access.</p>
<h5 id="4-3-17-SGI-Set-Pending-Registers-GICD-SPENDSGIRn"><a href="#4-3-17-SGI-Set-Pending-Registers-GICD-SPENDSGIRn" class="headerlink" title="4.3.17 SGI Set-Pending Registers, GICD_SPENDSGIRn"></a>4.3.17 SGI Set-Pending Registers, GICD_SPENDSGIRn</h5><p>The GICD_SPENDSGIRn registers provide a set-pending bit for each supported SGI and<br>source processor combination. When a processor writes a 1 to a set-pending bit, the pending<br>state is applied to the corresponding SGI for the corresponding source processor.</p>
<p>Fixme [Figure 4-19 GICD_SPENDSGIR bit assignments] page 117</p>
<p>Bits Name Function<br>[8y+7:8y], for y=0 to 3   SGI x Set-pending bits    For each bit:<br>                                                    Reads     0 SGI x for the corresponding processor is not pendinga.<br>                                                              1 SGI x for the corresponding processor is pendinga.<br>                                                    Writes     0 Has no effect.<br>                                                            1 Adds the pending state of SGI x for the corresponding processor,<br>                                                            if it is not already pending. If SGI x is already pending for the<br>                                                            corresponding processor then the write has no effect.</p>
<pre><code>Note
All accesses relate only to SGIs that target the processor making the access.
</code></pre><h5 id="4-3-18-Identification-registers"><a href="#4-3-18-Identification-registers" class="headerlink" title="4.3.18 Identification registers"></a>4.3.18 Identification registers</h5><p>This architecture specification defines offsets 0xFD0-0xFFC in the Distributor register map as a read-only<br>identification register space.</p>
<p>Fixme [Table 4-25 The GIC identification register space] page119</p>
<p><strong>Peripheral ID2 Register, ICPIDR2</strong><br>Fixme [Figure 4-20 ICPIDR2 bit assignments] page119</p>
<p>Bits     Name         Function<br>[7:4]     ArchRev     Revision field for the GIC architecture. The value of this field depends on the GIC architecture version:<br>                    • 0x1 for GICv1<br>                    • 0x2 for GICv2.</p>
<h4 id="4-4-CPU-interface-register-descriptions"><a href="#4-4-CPU-interface-register-descriptions" class="headerlink" title="4.4 CPU interface register descriptions"></a>4.4 CPU interface register descriptions</h4><h5 id="4-4-1-CPU-Interface-Control-Register-GICC-CTLR"><a href="#4-4-1-CPU-Interface-Control-Register-GICC-CTLR" class="headerlink" title="4.4.1 CPU Interface Control Register, GICC_CTLR"></a>4.4.1 CPU Interface Control Register, GICC_CTLR</h5><p>Enables the signaling of interrupts by the CPU interface to the connected processor, and<br>provides additional top-level control of the CPU interface. In a GICv2 implementation, this<br>includes control of the end of interrupt (EOI) behavior.</p>
<p>有几种类型的结构：<br><strong>for a GICv1 implementation, for</strong><br>• an implementation that does not include the Security Extensions<br>• the Non-secure copy of the register, in an implementation that includes the Security Extensions.<br>Fixme [Figure 4-22 GICC_CTLR bit assignments, GICv1 without Security Extensions or Non-secure] page 126</p>
<p><strong>a GIC v2 implementation that includes the Security Extensions, for the Non-secure copy of the register</strong><br>Fixme [Figure 4-23 GICC_CTLR bit assignments, GICv2 with Security Extensions, Non-secure copy] page 126</p>
<p>Bits         Name             Function<br>[9]         EOImodeNS         Controls the behavior of Non-secure accesses to the GICC_EOIR and GICC_DIR registers:<br>                            0     GICC_EOIR has both priority drop and deactivate interrupt functionality.<br>                                Accesses to the GICC_DIR are UNPREDICTABLE.<br>                            1     GICC_EOIR has priority drop functionality only. The GICC_DIR register has<br>                                deactivate interrupt functionality.</p>
<p>[6]         IRQBypDisGrp1     When the signaling of IRQs by the CPU interface is disabled, this bit partly controls whether the<br>                            bypass IRQ signal is signaled to the processor:<br>                            0     Bypass IRQ signal is signaled to the processor<br>                            1     Bypass IRQ signal is not signaled to the processor.</p>
<p>[5]         FIQBypDisGrp1     When the signaling of FIQs by the CPU interface is disabled, this bit partly controls whether the<br>                            bypass FIQ signal is signaled to the processor:<br>                            0     Bypass FIQ signal is signaled to the processor<br>                            1     Bypass FIQ signal is not signaled to the processor.</p>
<p>[0]         EnableGrp1         Enable for the signaling of Group 1 interrupts by the CPU interface to the connected processor.<br>                            0 Disable signaling of interrupts<br>                            1 Enable signaling of interrupts.<br>                            Note<br>                            When this bit is set to 0, the CPU interface ignores any pending Group 1 interrupt forwarded to<br>                            it. When this bit is set to 1, the CPU interface starts to process pending Group 1 interrupts that are<br>                            forwarded to it. There is a small but finite time required for a change to take effect.</p>
<p><strong>Security Extensions, for the Secure copy of the register</strong><br>• a GICv2 implementation, for:<br>— an implementation that does not include the Security Extensions<br>— the Secure copy of the register, in an implementation that includes the Security Extensions<br>• a GICv1 implementation that includes the Security Extensions, for the Secure copy of the register</p>
<p>Fixme [Figure 4-24 GICC_CTLR bit assignments, GICv2 without Security Extensions or Secure] page 128</p>
<p>Bits         Name             Function<br>[10]         EOImodeNS         Alias of EOImodeNS from the Non-secure copy of this register, see Table 4-30 on page 4-126.<br>                            In a GICv2 implementation that does not include the Security Extensions, and in a GICv1<br>                            implementation, this bit is reserved.</p>
<p>[9]         EOImodeS         Controls the behavior of accesses to GICC_EOIR and GICC_DIR registers. In a GIC implementation<br>                            that includes the Security Extensions, this control applies only to Secure accesses, and the EOImodeNS<br>                            bit controls the behavior of Non-secure accesses to these registers:<br>                            0         GICC_EOIR has both priority drop and deactivate interrupt functionality. Accesses to<br>                                    the GICC_DIR are UNPREDICTABLE.<br>                            1         GICC_EOIR has priority drop functionality only. GICC_DIR has deactivate interrupt<br>                                    functionality.<br>                            Note<br>                            This bit is called EOImode in a GIC implementation that does not include the Security Extensions.<br>                            In a GICv1 implementation, this bit is reserved.</p>
<p>[8]         IRQBypDisGrp1     Alias of IRQBypDisGrp1 from the Non-secure copy of this register, see Table 4-30 on page 4-126.<br>                            In a GICv1 implementation, this bit is reserved</p>
<p>[7]         FIQBypDisGrp1    Alias of FIQBypDisGrp1 from the Non-secure copy of this register, see Table 4-30 on page 4-126.<br>                            In a GICv1 implementation, this bit is reserved.                            </p>
<p>[6]         IRQBypDisGrp0     When the signaling of IRQs by the CPU interface is disabled, this bit partly controls whether the bypass<br>                            IRQ signal is signaled to the processor:<br>                            0         Bypass IRQ signal is signaled to the processor<br>                            1         Bypass IRQ signal is not signaled to the processor.<br>                            In a GICv1 implementation, this bit is reserved.</p>
<p>[5]         FIQBypDisGrp0    When the signaling of FIQs by the CPU interface is disabled, this bit partly controls whether the bypass<br>                            FIQ signal is signaled to the processor:<br>                            0         Bypass FIQ signal is signaled to the processor<br>                            1         Bypass FIQ signal is not signaled to the processor.<br>                            In a GICv1 implementation, this bit is reserved.</p>
<p>[4]         CBPR             Controls whether the GICC_BPR provides common control to Group 0 and Group 1 interrupts.<br>                            0         To determine any preemption, use:<br>                                    • the GICC_BPR for Group 0 interrupts<br>                                    • the GICC_ABPR for Group 1 interrupts.<br>                            1         To determine any preemption use the GICC_BPR for both Group 0 and Group 1<br>                                    interrupts.</p>
<p>[3]         FIQEn             Controls whether the CPU interface signals Group 0 interrupts to a target processor using the FIQ or<br>                            the IRQ signal.<br>                            0         Signal Group 0 interrupts using the IRQ signal.<br>                            1         Signal Group 0 interrupts using the FIQ signal.<br>                            The GIC always signals Group 1 interrupts using the IRQ signal.</p>
<p>[2]         AckCtl             When the highest priority pending interrupt is a Group 1 interrupt, determines both:<br>                            • whether a read of GICC_IAR acknowledges the interrupt, or returns a spurious interrupt ID<br>                            • whether a read of GICC_HPPIR returns the ID of the highest priority pending interrupt, or<br>                                returns a spurious interrupt ID.</p>
<pre><code>0         If the highest priority pending interrupt is a Group 1 interrupt, a read of the GICC_IAR
        or the GICC_HPPIR returns an Interrupt ID of 1022. A read of the GICC_IAR does
        not acknowledge the interrupt, and has no effect on the pending status of the interrupt.
1         If the highest priority pending interrupt is a Group 1 interrupt, a read of the GICC_IAR
        or the GICC_HPPIR returns the Interrupt ID of the Group 1 interrupt. A read of
        GICC_IAR acknowledges and Activates the interrupt.
In a GIC implementation that includes the Security Extensions, this control affects only the behavior
of Secure register accesses.
For more information, see:
• The effect of interrupt grouping on interrupt acknowledgement on page 3-50
• Interrupt grouping and interrupt prioritization on page 3-53
• Behavior of writes to GICC_EOIR, GICv1 with Security Extensions on page 4-139
• Effect of interrupt grouping and the Security Extensions on reads of the GICC_HPPIR on
page 4-143.
Note
ARM deprecates use of GICC_CTLR.AckCtl, and strongly recommends using a software model where
GICC_CTLR.AckCtl is set to 0. See Enabling and disabling the Distributor and CPU interfaces on
page 4-77 for more information about the effects of setting this bit.
</code></pre><p>[1]         EnableGrp1         Enable for the signaling of Group 1 interrupts by the CPU interface to the connected processor:<br>                            0         Disable signaling of Group 1 interrupts.<br>                            1         Enable signaling of Group 1 interrupts.</p>
<p>[0]         EnableGrp0         Enable for the signaling of Group 0 interrupts by the CPU interface to the connected processor:<br>                            0         Disable signaling of Group 0 interrupts.<br>                            1         Enable signaling of Group 0 interrupts.</p>
<h5 id="4-4-2-Interrupt-Priority-Mask-Register-GICC-PMR"><a href="#4-4-2-Interrupt-Priority-Mask-Register-GICC-PMR" class="headerlink" title="4.4.2 Interrupt Priority Mask Register, GICC_PMR"></a>4.4.2 Interrupt Priority Mask Register, GICC_PMR</h5><p><strong>Provides an interrupt priority filter. Only interrupts with higher priority than the value in this register are signaled to the processor</strong></p>
<p>Fixme [Figure 4-25 GICC_PMR bit assignments] page131</p>
<h5 id="4-4-3-Binary-Point-Register-GICC-BPR"><a href="#4-4-3-Binary-Point-Register-GICC-BPR" class="headerlink" title="4.4.3 Binary Point Register, GICC_BPR"></a>4.4.3 Binary Point Register, GICC_BPR</h5><p>The register defines the point at which the priority value fields split into two parts, the group priority field and the subpriority field. The group priority field is used to determine <strong>interrupt preemption.</strong></p>
<p>Fixme [Figure 4-26 GICC_BPR bit assignments] page133</p>
<p>see:<br>Table 3-2 Priority grouping by binary point<br>Table 3-7 Priority grouping for Group 1 interrupts when GICC_CTLR.CBPR==0</p>
<h5 id="4-4-4-Interrupt-Acknowledge-Register-GICC-IAR"><a href="#4-4-4-Interrupt-Acknowledge-Register-GICC-IAR" class="headerlink" title="4.4.4 Interrupt Acknowledge Register, GICC_IAR"></a>4.4.4 Interrupt Acknowledge Register, GICC_IAR</h5><p>The processor reads this register to obtain the interrupt ID of the signaled interrupt. This<br>read acts as an acknowledge for the interrupt.</p>
<p>When GICC_CTLR.AckCtl is set to 0 in a GICv2 implementation that does not include the<br>Security Extensions, if the highest priority pending interrupt is in Group 1, the interrupt ID<br>1022 is returned.</p>
<p>Fixme [Figure 4-27 GICC_IAR bit assignments] page135.</p>
<p>Bit         Name             Function<br>[31:13]     -                 Reserved.<br>[12:10]     CPUID             <strong>For SGIs in a multiprocessor implementation</strong>, this field identifies the processor that<br>                            requested the interrupt. It returns the number of the CPU interface that made the<br>                            request, for example a value of 3 means the request was generated by a write to the<br>                            GICD_SGIR on CPU interface 3.<br>                            For all other interrupts this field is RAZ.<br>[9:0]         Interrupt ID     The interrupt ID.</p>
<p>The read returns a spurious interrupt ID of 1023 if any of the following apply:<br>• forwarding of interrupts by the Distributor to the CPU interface is disabled<br>• signaling of interrupts by the CPU interface to the connected processor is disabled<br>• no pending interrupt on the CPU interface has sufficient priority for the interface to signal it to the processor</p>
<p>A non-spurious interrupt ID returned by a read of the GICC_IAR is called a valid interrupt ID.<br><strong>When the GIC returns a valid interrupt ID to a read of the GICC_IAR it treats the read as an acknowledge of that interrupt and, as a side-effect of the read, changes the interrupt status from pending to active, or to active and pending if the pending state of the interrupt persists.</strong></p>
<p>Note<br>• For compatibility with possible extensions to the GIC architecture specification, ARM recommends that<br>software preserves the entire register value read from the GICC_IAR, and writes that value back to the<br>GICC_EOIR when it has completed its processing of the interrupt.<br>• Although multiple target processors might attempt to read the GICC_IAR at any time, in GICv2 only one<br>processor can obtain a valid interrupt ID, see Implications of the 1-N model on page 3-41 for more<br>information.</p>
<p>Fixme [Table 4-35 Effect of interrupt grouping and the Security Extensions on reads of GICC_IAR]Page136</p>
<h5 id="4-4-5-End-of-Interrupt-Register-GICC-EOIR"><a href="#4-4-5-End-of-Interrupt-Register-GICC-EOIR" class="headerlink" title="4.4.5 End of Interrupt Register, GICC_EOIR"></a>4.4.5 End of Interrupt Register, GICC_EOIR</h5><p>A processor writes to this register to inform the CPU interface either:<br>• that it has completed the processing of the specified interrupt<br>• in a GICv2 implementation, when the appropriate GICC_CTLR.EOImode bit is set<br>to 1, to indicate that the interface should perform priority drop for the specified<br>interrupt. See Priority drop and interrupt deactivation on page 3-38 for more information.</p>
<p>Fixme [Figure 4-28 GICC_EOIR bit assignments]Page138</p>
<p>Fixme [Table 4-36 GICC_EOIR bit assignments]Page138</p>
<p>For every read of a valid Interrupt ID from the GICC_IAR, the connected processor must perform a matching write<br>to the GICC_EOIR. The value written to the GICC_EOIR must be the interrupt ID read from the GICC_IAR.<br>If a read of the GICC_IAR returns the ID of a spurious interrupt, software does not have to make a corresponding<br>write to the GICC_EOIR. If software writes the ID of a spurious interrupt to the GICC_EOIR, the GIC ignores that<br>write.</p>
<p><strong>Behavior of writes to GICC_EOIR, GICv2</strong><br>In a GICv2 implementation, when GICC_CTLR.AckCtl is set to 0:<br>• GICC_EOIR is used for processing Group 0 interrupts<br>• GICC_AEOIR is used for processing Group 1 interrupts.</p>
<p>In a GICv2 implementation that includes the GIC Security Extensions:<br>• GICC_CTLR.EOImodeS controls the behavior of Secure accesses to GICC_EOIR and GICC_AEOIR<br>• GICC_CTLR.EOImodeNS controls the behavior of Non-secure accesses to GICC_EOIR<br>• when GICC_CTLR.AckCtl is set to 0:<br>    — a Non-secure write to GICC_EOIR must correspond to the most recent Non-secure read of GICC_IAR<br>    — a Secure write to the GICC_AEOIR must correspond to the most recent Secure read of the<br>    GICC_AIAR.</p>
<h5 id="4-4-6-Running-Priority-Register-GICC-RPR"><a href="#4-4-6-Running-Priority-Register-GICC-RPR" class="headerlink" title="4.4.6 Running Priority Register, GICC_RPR"></a>4.4.6 Running Priority Register, GICC_RPR</h5><p>Indicates the Running priority of the CPU interface</p>
<p>Fixme [Figure 4-29 GICC_RPR bit assignments] page142</p>
<h5 id="4-4-7-Highest-Priority-Pending-Interrupt-Register-GICC-HPPIR"><a href="#4-4-7-Highest-Priority-Pending-Interrupt-Register-GICC-HPPIR" class="headerlink" title="4.4.7 Highest Priority Pending Interrupt Register, GICC_HPPIR"></a>4.4.7 Highest Priority Pending Interrupt Register, GICC_HPPIR</h5><p>Indicates the Interrupt ID, and processor ID if appropriate, of the <strong>highest priority pending</strong><br>interrupt on the CPU interface.</p>
<p>Fixme [Figure 4-30 GICC_HPPIR bit assignments] Page143</p>
<p>Bit            Name         Description<br>[31:13]     -             Reserved.<br>[12:10]     CPUID         On a multiprocessor implementation, if the PENDINTID field returns the ID of an<br>                        SGI, this field contains the CPUID value for that interrupt. This identifies the<br>                        processor that generated the interrupt.<br>[9:0]         PENDINTID     The interrupt ID of the highest priority pending interrupt. See Table 4-42 on<br>                        page 4-144 for more information about the result of Non-secure reads of the<br>                        GICC_HPPIR when the GIC implements the Security Extensions.</p>
<h5 id="4-4-8-Aliased-Binary-Point-Register-GICC-ABPR"><a href="#4-4-8-Aliased-Binary-Point-Register-GICC-ABPR" class="headerlink" title="4.4.8 Aliased Binary Point Register, GICC_ABPR"></a>4.4.8 Aliased Binary Point Register, GICC_ABPR</h5><h5 id="4-4-9-Aliased-Interrupt-Acknowledge-Register-GICC-AIAR"><a href="#4-4-9-Aliased-Interrupt-Acknowledge-Register-GICC-AIAR" class="headerlink" title="4.4.9 Aliased Interrupt Acknowledge Register, GICC_AIAR"></a>4.4.9 Aliased Interrupt Acknowledge Register, GICC_AIAR</h5><h5 id="4-4-10-Aliased-End-of-Interrupt-Register-GICC-AEOIR"><a href="#4-4-10-Aliased-End-of-Interrupt-Register-GICC-AEOIR" class="headerlink" title="4.4.10 Aliased End of Interrupt Register, GICC_AEOIR"></a>4.4.10 Aliased End of Interrupt Register, GICC_AEOIR</h5><h5 id="4-4-11-Aliased-Highest-Priority-Pending-Interrupt-Register-GICC-AHPPIR"><a href="#4-4-11-Aliased-Highest-Priority-Pending-Interrupt-Register-GICC-AHPPIR" class="headerlink" title="4.4.11 Aliased Highest Priority Pending Interrupt Register, GICC_AHPPIR"></a>4.4.11 Aliased Highest Priority Pending Interrupt Register, GICC_AHPPIR</h5><p>与前面对应相似</p>
<h5 id="4-4-12-Active-Priorities-Registers-GICC-APRn"><a href="#4-4-12-Active-Priorities-Registers-GICC-APRn" class="headerlink" title="4.4.12 Active Priorities Registers, GICC_APRn"></a>4.4.12 Active Priorities Registers, GICC_APRn</h5><p>主要用于做电源管理时，保存与恢复。<br>provide support for preserving and restoring the active priority in power-management implementations.</p>
<p>Although the format of these registers is IMPLEMENTATION DEFINED:<br>• because GICv2 guarantees the ability to save and restore all GIC state, the<br>GICC_APRn registers must be present in all GIC implementations<br>• in an implementation that includes the GIC Security Extensions, Non-secure<br>accesses must not affect Secure operation, and the architecture requires that these<br>registers are banked, to provide Secure and Non-secure copies of the registers.</p>
<h5 id="4-4-13-Non-secure-Active-Priorities-Registers-GICC-NSAPRn"><a href="#4-4-13-Non-secure-Active-Priorities-Registers-GICC-NSAPRn" class="headerlink" title="4.4.13 Non-secure Active Priorities Registers, GICC_NSAPRn"></a>4.4.13 Non-secure Active Priorities Registers, GICC_NSAPRn</h5><p>provide support for preserving and restoring the active priority in power-management implementation. These are separate registers for Group 1 interrupts.</p>
<h5 id="4-4-14-CPU-Interface-Identification-Register-GICC-IIDR"><a href="#4-4-14-CPU-Interface-Identification-Register-GICC-IIDR" class="headerlink" title="4.4.14 CPU Interface Identification Register, GICC_IIDR"></a>4.4.14 CPU Interface Identification Register, GICC_IIDR</h5><p>Provides information about the implementer and revision of the CPU interface.</p>
<p>Fixme [Figure 4-35 GICC_IIDR bit assignments] Page 152</p>
<p>Fixme [Table 4-48 GICC_IIDR bit assignments] Page 152</p>
<h5 id="4-4-15-Deactivate-Interrupt-Register-GICC-DIR"><a href="#4-4-15-Deactivate-Interrupt-Register-GICC-DIR" class="headerlink" title="4.4.15 Deactivate Interrupt Register, GICC_DIR"></a>4.4.15 Deactivate Interrupt Register, GICC_DIR</h5><p>When interrupt priority drop is separated from interrupt deactivation, as described in<br>Priority drop and interrupt deactivation on page 3-38, a write to this register <strong>deactivates the specified interrupt.</strong></p>
<p>Fixme [Figure 4-36 GICC_DIR bit assignments] Page 153</p>
<p>Fixme [Table 4-49 GICC_DIR bit assignments] Page 153</p>
<p>Fixme [Table 4-50 Behavior of GICC_DIR writes] Page 154</p>
<h3 id="5-GIC-Support-for-Virtualization"><a href="#5-GIC-Support-for-Virtualization" class="headerlink" title="5 GIC Support for Virtualization"></a>5 GIC Support for Virtualization</h3><h4 id="5-1-About-implementing-a-GIC-in-a-system-with-processor-virtualization"><a href="#5-1-About-implementing-a-GIC-in-a-system-with-processor-virtualization" class="headerlink" title="5.1 About implementing a GIC in a system with processor virtualization"></a>5.1 About implementing a GIC in a system with processor virtualization</h4><p><strong>Any ARM processor implementation that includes the Virtualization Extensions must also include the Security Extensions.</strong></p>
<p>Fixme [Figure 5-1 Implementing the GIC with an ARM processor that supports virtualization] Page159</p>
<h4 id="5-2-Managing-the-GIC-virtual-CPU-interface"><a href="#5-2-Managing-the-GIC-virtual-CPU-interface" class="headerlink" title="5.2 Managing the GIC virtual CPU interface"></a>5.2 Managing the GIC virtual CPU interface</h4><p>The hypervisor, or similar software, manages the GIC virtual interface control registers, consisting of:<br><strong>List registers</strong><br>Used to define the active and pending virtual interrupts for the virtual CPU interface. The current<br>virtual machine accesses these interrupts indirectly, using the virtual CPU interface.</p>
<p><strong>Management registers</strong><br>Used to manage the virtual CPU interface, and to save and restore settings when switching between<br>virtual machines.</p>
<p>The hypervisor runs as Non-secure software in Hyp mode. To maintain the 1-N interrupt handling model, a hypervisor might have to migrate an interrupt from one virtual machine to another.</p>
<p>When it receives a physical IRQ, the hypervisor determines the required destination of the interrupt and then either:<br>• Processes the interrupt itself, for example if the IRQ is <strong>a maintenance interrupt</strong> from the virtual CPU<br>interface. It then deactivates the physical interrupt.<br>• Generates a virtual interrupt. Depending on the interrupt priority and the targeted virtual machine, the<br>hypervisor takes one of the following actions:<br>    — If the interrupt is for the current virtual machine, updates the List registers with details of the interrupt,<br>    redefining the interrupts that are visible to the current virtual machine. If there is no space in the List<br>    registers, it saves the context to memory so the details can be added at a later stage<br>    — Records that the interrupt is for a different virtual machine by saving details of the interrupt as part of<br>    the hypervisor state associated with that virtual machine.<br>    — Switches to a different virtual machine that can handle the interrupt. In doing so it must save the<br>    interrupt state for the current virtual machine, using the information in the List registers, and<br>    reprogram the List registers, to indicate the interrupt state for the new virtual machine, including the<br>    state for the interrupt that has arrived.</p>
<p>The virtual machine accesses the GIC virtual CPU interface registers. These registers have the same general format<br>as the physical CPU interface registers, and, in a typical implementation the virtual machine believes it is accessing<br>a physical CPU interface.</p>
<p>When the virtual machine handles a virtual interrupt, it writes to the virtual CPU interface to indicate when it has<br>finished this processing. The virtual CPU interface signals this completion to the physical Distributor and the<br>physical Distributor then deactivates the interrupt.</p>
<h5 id="5-2-1-List-registers-and-virtual-interrupt-handling"><a href="#5-2-1-List-registers-and-virtual-interrupt-handling" class="headerlink" title="5.2.1 List registers and virtual interrupt handling"></a>5.2.1 List registers and virtual interrupt handling</h5><p>a hypervisor uses List registers to maintain the list of highest priority virtual interrupts.</p>
<p>记录的数据可以超过List registers数量，多余的数据存储在MEM 中。<br><strong>The total number of interrupts that are either pending, active, or active and pending, can exceed the number of List registers available.</strong><br>If this happens, the hypervisor can save one or more active interrupt entries to memory, and later restore them to the List registers，based on their priority。Therefore:<br>• The List registers might not include all active, or active and pending, interrupts. Virtual CPU interface<br>accesses by the virtual machine update the List registers, and normally an EOI request from the virtual<br>machine deactivates an interrupt in the list. However, the virtual machine can issue an EOI request for an<br>interrupt before the hypervisor restores the associated active interrupt entry into a List register. In this case,<br>the EOI request cannot update the List registers.</p>
<p>• Although the List registers might include only active interrupts, with the hypervisor maintaining any pending<br>interrupts in memory, a pending interrupt cannot be signaled to the virtual machine until the hypervisor adds<br>it to the List registers. Therefore, to minimize interrupt latency and ensure efficient virtual machine operation,<br><strong>ARM strongly recommends that the List registers contain at least one pending interrupt, provided a List register is available for this interrupt.</strong></p>
<h5 id="5-2-2-Completion-of-virtualized-physical-interrupts"><a href="#5-2-2-Completion-of-virtualized-physical-interrupts" class="headerlink" title="5.2.2 Completion of virtualized physical interrupts"></a>5.2.2 Completion of virtualized physical interrupts</h5><p>ARM recommends that, for each CPU interface that corresponds to a<br>processor running virtual machines, the GICC_CTLR.EOImodeNS bit is set to 1. This means that hypervisor<br>accesses to the GICC_AEOIR register drops the running priority of the CPU interface but does not deactivate the<br>interrupt. After writing to the EOI register, the running priority level on the CPU interface is lower, so that<br>subsequent interrupts can be signaled to the processor.</p>
<p>ARM recommends that physical interrupt completion consists of the following separate steps:</p>
<ol>
<li>EOI</li>
<li>interrupt deactivation.</li>
</ol>
<p>These steps are explained in more detail as follows:</p>
<ol>
<li><p>After receiving a physical interrupt, the hypervisor performs an EOI request for the physical interrupt by<br>writing to the GICC_EOIR or GICC_AEOIR register. After EOI, although the virtual machine has not<br>processed the virtual interrupt, the lower running priority of the CPU interface means that the hypervisor can<br>still receive new physical interrupts.<br> Note<br> The only interrupts that are not signaled to the hypervisor are the physical interrupts most recently subject to<br> EOI. This is because the interrupts have not been deactivated. This prevents the interrupts from being<br> re-signaled to the hypervisor before being processed by the virtual machine.</p>
</li>
<li><p>After the virtual machine completes processing the corresponding virtual interrupt, it writes to the<br>GICV_EOIR or GICV_AEOIR to deactivate the interrupt. This deactivates both the virtual interrupt and the<br>corresponding physical interrupt, provided that both of the following conditions are true:<br>• the GICV_CTLR.EOImode bit is set to 0<br>• the GICH_LRn.HW bit is set to 1.</p>
</li>
</ol>
<p>Alternatively, if the GICV_CTLR.EOImode bit is set to 1, the virtual machine writes to the GICV_DIR<br>register to deactivate the interrupt.<br>If the GICH_LRn.HW bit is set to 0, the hypervisor must deactivate the physical interrupt itself. ARM<br>recommends one of the following methods for deactivating physical SGIs that are routed to a virtual machine:<br>• the hypervisor deactivates the SGI by writing to the GICC_DIR register after the virtual machine<br>writes to GICC_EOIR<br>• the hypervisor uses an EOI maintenance interrupt to write to the GICC_DIR register after the virtual<br>machine writes to GICV_EOIR, see Maintenance interrupts on page 5-164 for more information.</p>
<p>处理大致流程：</p>
<ol>
<li>hypervisor 写GICC_AEOIR，让此IRQ 丢掉优先级，能让其他低优先级的中断能被处理</li>
<li>virtual machine 处理完后，virtual cpu 写GICV_EOIR 或 GICV_AEOIR，再写GICV_DIR （依赖GICV_CTLR.EOImode 设定是否自动完成后一步）</li>
<li>在virtual machine 写 GICV_EOIR 后，hypervisor 用 EOI maintenance interrupt 写 GICC_DIR （GICH_LRn.HW 设定为1，自动完成此步）</li>
</ol>
<h5 id="5-2-3-Acknowledgement-and-completion-of-virtual-interrupts"><a href="#5-2-3-Acknowledgement-and-completion-of-virtual-interrupts" class="headerlink" title="5.2.3 Acknowledgement and completion of virtual interrupts"></a>5.2.3 Acknowledgement and completion of virtual interrupts</h5><p>To ensure system correctness when handling virtual interrupts, one of the following conditions must be true:<br>• All Group 0 interrupts must have a higher priority than any Group 1 interrupt. That is, there is no overlap in<br>the priorities allocated to Group 0 and Group 1 interrupts.<br>• The GICV_CTLR.AckCtl bit must be set to 0.</p>
<p><strong>ARM deprecates the use of GICC_CTLR.AckCtl and GICV_CTLR.AckCtl, and strongly recommends using a software model where GICC_CTLR.AckCtl and GICV_CTLR.AckCtl are set to 0.</strong></p>
<h5 id="5-2-4-GIC-virtual-interface-control-interface-requirements"><a href="#5-2-4-GIC-virtual-interface-control-interface-requirements" class="headerlink" title="5.2.4 GIC virtual interface control interface requirements"></a>5.2.4 GIC virtual interface control interface requirements</h5><p>skip</p>
<h5 id="5-2-5-Maintenance-interrupts"><a href="#5-2-5-Maintenance-interrupts" class="headerlink" title="5.2.5 Maintenance interrupts"></a>5.2.5 Maintenance interrupts</h5><p><strong>Maintenance interrupts can signal key events in the operation of a GIC that implements the Virtualization Extensions. Typically, these events are processed by the hypervisor.</strong></p>
<p>Note<br>• Maintenance interrupts are generated only when the global interrupt enable bit, GICH_HCR.En, is set to 1.</p>
<p>Maintenance interrupts are level-sensitive interrupts. Configuration bits in the GICH_HCR can be set to 1 to enable<br>maintenance interrupt generation when:<br>• Group 0 virtual interrupts are enabled/disabled<br>• Group 1 virtual interrupts are enabled/disabled<br>• There are no pending interrupts in the List registers.<br>• At least one EOI request occurs with no valid List register entry for the corresponding interrupt.<br>• There are no valid entries, or only one valid entry, in the List registers. This is an underflow condition.<br>• At least one List register entry has received an EOI request.</p>
<h5 id="5-2-6-Software-generated-interrupts"><a href="#5-2-6-Software-generated-interrupts" class="headerlink" title="5.2.6 Software-generated interrupts"></a>5.2.6 Software-generated interrupts</h5><p><strong>Hypervisor-generated interrupts</strong><br>A hypervisor can generate virtual interrupts that do not have a corresponding physical interrupt, by<br>creating an entry in the List registers with the GICH_LRn.HW bit cleared to 0. The hypervisor can<br>control how the interrupt appears to a virtual machine reading the GICV_IAR or GICV_AIAR<br>register to acknowledge the interrupt, by presenting the interrupt as:<br>• an SGI, with a CPUID value provided in addition to the interrupt ID<br>• a PPI or SPI, with the CPUID value set to 0.</p>
<p>The hypervisor can virtualize the CPUID value, but it must be consistent with the type of interrupt<br>indicated by the GICH_LRn.VirtualID field. When the EOI notification is sent to the virtual CPU<br>interface, only the List registers are affected, and no notification is sent to the Distributor. See List<br>Registers, GICH_LRn on page 5-176 for more information.</p>
<p>hypervisor 可以产生与硬件中断号不一致的虚拟中断，并且可以控制中断在虚拟机中呈现的形式：SGI，PPI，SPI。</p>
<p><strong>Distributor-generated interrupts</strong><br>Because the hardware interrupt deactivation mechanism does not support SGIs, the hypervisor must<br>virtualize SGIs originating from the Distributor in the same way as hypervisor-generated interrupts.<br>The hypervisor can virtualize the GICH_LRn.CPUID field, because this field is not required to be<br>the same as that of the original SGI. See Completion of virtualized physical interrupts on page 5-161<br>for more information about deactivating virtualized SGIs.</p>
<p>虚拟中断分发器 产生的虚拟机之间的SGIs。</p>
<h5 id="5-2-7-GIC-Virtualization-Extensions-register-mapping"><a href="#5-2-7-GIC-Virtualization-Extensions-register-mapping" class="headerlink" title="5.2.7 GIC Virtualization Extensions register mapping"></a>5.2.7 GIC Virtualization Extensions register mapping</h5><p>The GIC must make these virtual interface control registers accessible in the following ways:<br><strong>Redirection through a common base address</strong><br>The memory map includes a common base address for the virtual interface control registers. Each<br>processor in the system can access its own GIC virtual interface control registers through this base<br>address. The CPUID of the processor requesting access redirects the access to the GIC virtual<br>interface control registers for that processor.</p>
<p><strong>Processor-specific base addresses</strong><br>In addition to the common base address, the memory map contains, for each processor in the system,<br>a processor-specific base address for the GIC virtual interface control registers. Any processor can<br>use these addresses to access its own GIC virtual interface control registers, or to access the GIC<br>virtual interface control registers of any other processor in the system.</p>
<p>Fixme [Figure 5-2 GIC virtual interface control register mappings] page166</p>
<h4 id="5-3-GIC-virtual-interface-control-registers"><a href="#5-3-GIC-virtual-interface-control-registers" class="headerlink" title="5.3 GIC virtual interface control registers"></a>5.3 GIC virtual interface control registers</h4><p>Fixme [Table 5-1 GIC virtual interface control register map] page167</p>
<h5 id="5-3-1-Hypervisor-Control-Register-GICH-HCR"><a href="#5-3-1-Hypervisor-Control-Register-GICH-HCR" class="headerlink" title="5.3.1 Hypervisor Control Register, GICH_HCR"></a>5.3.1 Hypervisor Control Register, GICH_HCR</h5><p>This register contains control bits for the virtual CPU interface.</p>
<p>Fixme [Figure 5-3 GICH_HCR bit assignments] page168</p>
<p>Fixme [Table 5-2 GICH_HCR bit assignments] page168</p>
<p>Fixme [Table 5-2 GICH_HCR bit assignments] page169</p>
<h5 id="5-3-2-VGIC-Type-Register-GICH-VTR"><a href="#5-3-2-VGIC-Type-Register-GICH-VTR" class="headerlink" title="5.3.2 VGIC Type Register, GICH_VTR"></a>5.3.2 VGIC Type Register, GICH_VTR</h5><p>This is a read-only register that provides the following information about the<br>implementation of the GIC Virtualization Extensions:<br>• number of priority levels supported<br>• number of preemption levels supported<br>• number of implemented List registers.</p>
<p>Fixme [Figure 5-4 GICH_VTR bit assignments] page170</p>
<p>Fixme [Table 5-3 GICH_VTR bit assignments] page170</p>
<h5 id="5-3-3-Virtual-Machine-Control-Register-GICH-VMCR"><a href="#5-3-3-Virtual-Machine-Control-Register-GICH-VMCR" class="headerlink" title="5.3.3 Virtual Machine Control Register, GICH_VMCR"></a>5.3.3 Virtual Machine Control Register, GICH_VMCR</h5><p>Enables the hypervisor to save and restore the virtual machine view of the GIC state.</p>
<p>Fixme [Figure 5-5 GICH_VMCR bit assignments] page171</p>
<p>The GICH_VMCR is a control register that contains read and write aliases of architecture state in the virtual<br>machine view, enabling the hypervisor to save and restore this state with a single read or write, without accessing<br>the GIC virtual CPU interface registers individually.</p>
<h5 id="5-3-4-Maintenance-Interrupt-Status-Register-GICH-MISR"><a href="#5-3-4-Maintenance-Interrupt-Status-Register-GICH-MISR" class="headerlink" title="5.3.4 Maintenance Interrupt Status Register, GICH_MISR"></a>5.3.4 Maintenance Interrupt Status Register, GICH_MISR</h5><p>Indicates which maintenance interrupts are asserted.</p>
<p>Fixme [Figure 5-6 GICH_MISR bit assignments] page172</p>
<p>Fixme [Table 5-5 GICH_MISR bit assignments] page172</p>
<h5 id="5-3-5-End-of-Interrupt-Status-Registers-GICH-EISR0-and-GICH-EISR1"><a href="#5-3-5-End-of-Interrupt-Status-Registers-GICH-EISR0-and-GICH-EISR1" class="headerlink" title="5.3.5 End of Interrupt Status Registers, GICH_EISR0 and GICH_EISR1"></a>5.3.5 End of Interrupt Status Registers, GICH_EISR0 and GICH_EISR1</h5><p>When a maintenance interrupt is received, these registers help determine which List<br>registers have outstanding EOI interrupts that require servicing.</p>
<p>Fixme [Figure 5-7 GICH_EISR0 bit assignments] page173</p>
<p>Fixme [Table 5-6 GICH_EISR0 bit assignments] page173</p>
<h5 id="5-3-6-Empty-List-Register-Status-Registers-GICH-ELRSR0-and-GICH-ELRSR1"><a href="#5-3-6-Empty-List-Register-Status-Registers-GICH-ELRSR0-and-GICH-ELRSR1" class="headerlink" title="5.3.6 Empty List Register Status Registers, GICH_ELRSR0 and GICH_ELRSR1"></a>5.3.6 Empty List Register Status Registers, GICH_ELRSR0 and GICH_ELRSR1</h5><p>These registers can be used to locate a usable List register when the hypervisor is delivering<br>an interrupt to a Guest OS.</p>
<p>Fixme [Figure 5-8 GICH_ELRSR0 bit assignments] page173</p>
<p>Fixme [Table 5-7 GICH_ELRSR0 bit assignments] page173</p>
<h5 id="5-3-7-Active-Priorities-Register-GICH-APR"><a href="#5-3-7-Active-Priorities-Register-GICH-APR" class="headerlink" title="5.3.7 Active Priorities Register, GICH_APR"></a>5.3.7 Active Priorities Register, GICH_APR</h5><p>This register tracks which preemption levels are active in the virtual CPU interface, and is<br>used to determine the current active priority. Corresponding bits are set in this register when<br>an interrupt is acknowledged, based on GICH_LRn.Priority, and the least significant set bit<br>is cleared on EOI.</p>
<p>Fixme [Figure 5-9 GICH_APR bit assignments] page175</p>
<p>Fixme [Table 5-8 GICH_APR bit assignments] page175</p>
<h5 id="5-3-8-List-Registers-GICH-LRn"><a href="#5-3-8-List-Registers-GICH-LRn" class="headerlink" title="5.3.8 List Registers, GICH_LRn"></a>5.3.8 List Registers, GICH_LRn</h5><p>Provides interrupt context information for the virtual CPU interface. <strong>A maximum of 64 List registers can be provided. The GICH_VTR.ListRegs bit defines the actual number implemented.</strong></p>
<p>Fixme [Figure 5-10 GICH_LR bit assignments] page176</p>
<p>Fixme [Table 5-9 GICH_LR bit assignments] page176</p>
<h4 id="5-4-The-virtual-CPU-interface"><a href="#5-4-The-virtual-CPU-interface" class="headerlink" title="5.4 The virtual CPU interface"></a>5.4 The virtual CPU interface</h4><p>A GIC virtual CPU interface signals virtual interrupts to a connected processor, The GIC virtual CPU interface registers have the same general format as the GIC physical CPU interface registers and expected behavior is that a virtual machine cannot distinguish between them.</p>
<p><strong>In particular, the virtual CPU interface uses the contents of the List registers to determine when to signal virtual interrupts.</strong></p>
<p>When a processor accesses the virtual CPU interface the List registers are updated.<br>• Virtual interrupts are always handled through the virtual CPU interfaces.<br>• On the connected processor, if the processor is in a Non-secure PL1 or PL0 mode, virtual interrupts are<br>signaled to the current virtual machine.<br>• In addition, a virtual machine can receive virtual IRQs and virtual FIQs signaled directly by the hypervisor.<br>These exceptions are outside the scope of this specification. A virtual machine cannot distinguish:<br>    — A virtual exception signaled by the GIC from a corresponding virtual exception signaled directly by the hypervisor.<br>    — A virtual exception from the corresponding physical exception.<br>• A virtual CPU interface does not require power management support, and therefore GICV_CTLR does not<br>implement the IRQBypDisGrp1, FIQBypDisGrp1, IRQBypDisGrp0, and FIQBypDisGrp0 bits that are<br>supported by GICC_CTLR</p>
<h4 id="5-5-GIC-virtual-CPU-interface-registers"><a href="#5-5-GIC-virtual-CPU-interface-registers" class="headerlink" title="5.5 GIC virtual CPU interface registers"></a>5.5 GIC virtual CPU interface registers</h4><p>Typically, a virtual machine is unaware of any difference between virtual interrupts and physical interrupts.</p>
<p><strong>In general, these registers have the same format as the GIC physical CPU interface registers, but they operate on the interrupt view defined primarily by the List registers.</strong></p>
<p>These registers are memory-mapped, The offset of each GICV_* register is the same as the offset of the corresponding register for the physical CPU interface.</p>
<p>Fixme [Table 5-10 GIC virtual CPU interface register map] page179</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/arm/" rel="tag"># arm</a>
          
            <a href="/tags/spec/" rel="tag"># spec</a>
          
            <a href="/tags/GICv2/" rel="tag"># GICv2</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/16/史蒂夫-乔布斯传/" rel="next" title="史蒂夫.乔布斯传">
                <i class="fa fa-chevron-left"></i> 史蒂夫.乔布斯传
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/24/财务自由之路/" rel="prev" title="财务自由之路">
                财务自由之路 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="JShell07" />
            
              <p class="site-author-name" itemprop="name">JShell07</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">46</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">35</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/JShell07" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:jshell07@163.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Security-Extensions-support"><span class="nav-text">1.2. Security Extensions support</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Virtualization-support"><span class="nav-text">1.3. Virtualization support</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-Terminology-（专用名词）"><span class="nav-text">1.4. Terminology （专用名词）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-Interrupt-states"><span class="nav-text">1.4.1. Interrupt states</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-2-Interrupt-types"><span class="nav-text">1.4.2. Interrupt types</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-3-Models-for-handling-interrupts"><span class="nav-text">1.4.3. Models for handling interrupts</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-4-Spurious-interrupts-（假的中断）"><span class="nav-text">1.4.4. Spurious interrupts （假的中断）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-GIC-Partitioning"><span class="nav-text">2. GIC Partitioning</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-About-GIC-partitioning"><span class="nav-text">2.1 About GIC partitioning</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-The-Distributor"><span class="nav-text">2.2. The Distributor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-Interrupt-IDs"><span class="nav-text">2.2.1 Interrupt IDs</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-CPU-interfaces"><span class="nav-text">2.3. CPU interfaces</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-Interrupt-signal-bypass-and-GICv2-bypass-disable"><span class="nav-text">2.3.1 Interrupt signal bypass, and GICv2 bypass disable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-Power-management-GIC-v2"><span class="nav-text">2.3.2 Power management, GIC v2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Interrupt-Handling-and-Prioritization"><span class="nav-text">3 Interrupt Handling and Prioritization</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-About-interrupt-handling-and-prioritization"><span class="nav-text">3.1 About interrupt handling and prioritization</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-1-About-interrupt-handling-and-prioritization"><span class="nav-text">3.1.1 About interrupt handling and prioritization</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-2-Identifying-the-supported-interrupts"><span class="nav-text">3.1.2 Identifying the supported interrupts</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-General-handling-of-interrupts"><span class="nav-text">3.2 General handling of interrupts</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-Priority-drop-and-interrupt-deactivation"><span class="nav-text">3.2.1 Priority drop and interrupt deactivation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-Interrupt-controls-in-the-GIC"><span class="nav-text">3.2.2 Interrupt controls in the GIC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-3-Implications-of-the-1-N-model"><span class="nav-text">3.2.3 Implications of the 1-N model</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-3-Interrupt-handling-state-machine"><span class="nav-text">3.2.3 Interrupt handling state machine</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-Interrupt-prioritization"><span class="nav-text">3.3 Interrupt prioritization</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-1-Preemption"><span class="nav-text">3.3.1 Preemption</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-Priority-masking"><span class="nav-text">3.3.2 Priority masking</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-Priority-grouping"><span class="nav-text">3.3.3 Priority grouping</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-The-effect-of-interrupt-grouping-on-interrupt-handling"><span class="nav-text">3.4 The effect of interrupt grouping on interrupt handling</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-1-GIC-interrupt-grouping-support"><span class="nav-text">3.4.1 GIC interrupt grouping support</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-2-Special-interrupt-numbers-when-a-GIC-supports-interrupt-grouping"><span class="nav-text">3.4.2 Special interrupt numbers when a GIC supports interrupt grouping</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-3-The-effect-of-interrupt-grouping-on-interrupt-acknowledgement"><span class="nav-text">3.4.3 The effect of interrupt grouping on interrupt acknowledgement</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-4-GIC-power-on-or-reset-configuration"><span class="nav-text">3.4.4 GIC power on or reset configuration</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-Interrupt-grouping-and-interrupt-prioritization"><span class="nav-text">3.5 Interrupt grouping and interrupt prioritization</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-1-Software-views-of-interrupt-priority-in-a-GIC-that-includes-the-Security-Extensions"><span class="nav-text">3.5.1 Software views of interrupt priority in a GIC that includes the Security Extensions</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-2-Control-of-preemption-by-Group-1-interrupts"><span class="nav-text">3.5.2 Control of preemption by Group 1 interrupts</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-Additional-features-of-the-GIC-Security-Extensions"><span class="nav-text">3.6 Additional features of the GIC Security Extensions</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-1-Access-from-processors-not-implementing-the-ARM-Security-Extensions"><span class="nav-text">3.6.1 Access from processors not implementing the ARM Security Extensions</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-Pseudocode-details-of-interrupt-handling-and-prioritization"><span class="nav-text">3.7 Pseudocode details of interrupt handling and prioritization</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-The-effect-of-the-Virtualization-Extensions-on-interrupt-handling"><span class="nav-text">3.8 The effect of the Virtualization Extensions on interrupt handling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-Example-GIC-usage-models"><span class="nav-text">3.9 Example GIC usage models</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-9-1-Using-IRQs-and-FIQs-to-provide-Non-secure-and-Secure-interrupts"><span class="nav-text">3.9.1 Using IRQs and FIQs to provide Non-secure and Secure interrupts</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-9-2-Supporting-IRQs-and-FIQs-when-not-using-the-processor-Security-Extensions"><span class="nav-text">3.9.2 Supporting IRQs and FIQs when not using the processor Security Extensions</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-9-3-Supporting-IRQs-and-FIQs-in-a-virtualized-processor-environment"><span class="nav-text">3.9.3 Supporting IRQs and FIQs in a virtualized processor environment</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Programmers’-Model"><span class="nav-text">4. Programmers’ Model</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-GIC-register-names"><span class="nav-text">4.1.1 GIC register names</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-Distributor-register-map"><span class="nav-text">4.1.2 Distributor register map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3-CPU-interface-register-map"><span class="nav-text">4.1.3 CPU interface register map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-4-GIC-register-access"><span class="nav-text">4.1.4 GIC register access</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-5-Enabling-and-disabling-the-Distributor-and-CPU-interfaces"><span class="nav-text">4.1.5 Enabling and disabling the Distributor and CPU interfaces</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Effect-of-the-GIC-Security-Extensions-on-the-programmers’-model"><span class="nav-text">4.2 Effect of the GIC Security Extensions on the programmers’ model</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-Non-secure-access-to-register-fields-for-Group-0-interrupt-priorities"><span class="nav-text">4.2.1 Non-secure access to register fields for Group 0 interrupt priorities</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-Configuration-lockdown"><span class="nav-text">4.2.2 Configuration lockdown</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-Distributor-register-descriptions"><span class="nav-text">4.3 Distributor register descriptions</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-1-Distributor-Control-Register-GICD-CTLR"><span class="nav-text">4.3.1 Distributor Control Register, GICD_CTLR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-2-Interrupt-Controller-Type-Register-GICD-TYPER"><span class="nav-text">4.3.2 Interrupt Controller Type Register, GICD_TYPER</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-3-Distributor-Implementer-Identification-Register-GICD-IIDR"><span class="nav-text">4.3.3 Distributor Implementer Identification Register, GICD_IIDR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-4-Interrupt-Group-Registers-GICD-IGROUPRn"><span class="nav-text">4.3.4 Interrupt Group Registers, GICD_IGROUPRn</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-5-Interrupt-Set-Enable-Registers-GICD-ISENABLERn"><span class="nav-text">4.3.5 Interrupt Set-Enable Registers, GICD_ISENABLERn</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-6-Interrupt-Clear-Enable-Registers-GICD-ICENABLERn"><span class="nav-text">4.3.6 Interrupt Clear-Enable Registers, GICD_ICENABLERn</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-7-Interrupt-Set-Pending-Registers-GICD-ISPENDRn"><span class="nav-text">4.3.7 Interrupt Set-Pending Registers, GICD_ISPENDRn</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-8-Interrupt-Clear-Pending-Registers-GICD-ICPENDRn"><span class="nav-text">4.3.8 Interrupt Clear-Pending Registers, GICD_ICPENDRn</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-9-Interrupt-Set-Active-Registers-GICD-ISACTIVERn"><span class="nav-text">4.3.9 Interrupt Set-Active Registers, GICD_ISACTIVERn</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-10-Interrupt-Clear-Active-Registers-GICD-ICACTIVERn"><span class="nav-text">4.3.10 Interrupt Clear-Active Registers, GICD_ICACTIVERn</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-11-Interrupt-Priority-Registers-GICD-IPRIORITYRn"><span class="nav-text">4.3.11 Interrupt Priority Registers, GICD_IPRIORITYRn</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-12-Interrupt-Processor-Targets-Registers-GICD-ITARGETSRn"><span class="nav-text">4.3.12 Interrupt Processor Targets Registers, GICD_ITARGETSRn</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-13-Interrupt-Configuration-Registers-GICD-ICFGRn"><span class="nav-text">4.3.13 Interrupt Configuration Registers, GICD_ICFGRn</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-14-Non-secure-Access-Control-Registers-GICD-NSACRn"><span class="nav-text">4.3.14 Non-secure Access Control Registers, GICD_NSACRn</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-15-Software-Generated-Interrupt-Register-GICD-SGIR"><span class="nav-text">4.3.15 Software Generated Interrupt Register, GICD_SGIR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-16-SGI-Clear-Pending-Registers-GICD-CPENDSGIRn"><span class="nav-text">4.3.16 SGI Clear-Pending Registers, GICD_CPENDSGIRn</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-17-SGI-Set-Pending-Registers-GICD-SPENDSGIRn"><span class="nav-text">4.3.17 SGI Set-Pending Registers, GICD_SPENDSGIRn</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-18-Identification-registers"><span class="nav-text">4.3.18 Identification registers</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-CPU-interface-register-descriptions"><span class="nav-text">4.4 CPU interface register descriptions</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-1-CPU-Interface-Control-Register-GICC-CTLR"><span class="nav-text">4.4.1 CPU Interface Control Register, GICC_CTLR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-2-Interrupt-Priority-Mask-Register-GICC-PMR"><span class="nav-text">4.4.2 Interrupt Priority Mask Register, GICC_PMR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-3-Binary-Point-Register-GICC-BPR"><span class="nav-text">4.4.3 Binary Point Register, GICC_BPR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-4-Interrupt-Acknowledge-Register-GICC-IAR"><span class="nav-text">4.4.4 Interrupt Acknowledge Register, GICC_IAR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-5-End-of-Interrupt-Register-GICC-EOIR"><span class="nav-text">4.4.5 End of Interrupt Register, GICC_EOIR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-6-Running-Priority-Register-GICC-RPR"><span class="nav-text">4.4.6 Running Priority Register, GICC_RPR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-7-Highest-Priority-Pending-Interrupt-Register-GICC-HPPIR"><span class="nav-text">4.4.7 Highest Priority Pending Interrupt Register, GICC_HPPIR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-8-Aliased-Binary-Point-Register-GICC-ABPR"><span class="nav-text">4.4.8 Aliased Binary Point Register, GICC_ABPR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-9-Aliased-Interrupt-Acknowledge-Register-GICC-AIAR"><span class="nav-text">4.4.9 Aliased Interrupt Acknowledge Register, GICC_AIAR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-10-Aliased-End-of-Interrupt-Register-GICC-AEOIR"><span class="nav-text">4.4.10 Aliased End of Interrupt Register, GICC_AEOIR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-11-Aliased-Highest-Priority-Pending-Interrupt-Register-GICC-AHPPIR"><span class="nav-text">4.4.11 Aliased Highest Priority Pending Interrupt Register, GICC_AHPPIR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-12-Active-Priorities-Registers-GICC-APRn"><span class="nav-text">4.4.12 Active Priorities Registers, GICC_APRn</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-13-Non-secure-Active-Priorities-Registers-GICC-NSAPRn"><span class="nav-text">4.4.13 Non-secure Active Priorities Registers, GICC_NSAPRn</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-14-CPU-Interface-Identification-Register-GICC-IIDR"><span class="nav-text">4.4.14 CPU Interface Identification Register, GICC_IIDR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-15-Deactivate-Interrupt-Register-GICC-DIR"><span class="nav-text">4.4.15 Deactivate Interrupt Register, GICC_DIR</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-GIC-Support-for-Virtualization"><span class="nav-text">5 GIC Support for Virtualization</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-About-implementing-a-GIC-in-a-system-with-processor-virtualization"><span class="nav-text">5.1 About implementing a GIC in a system with processor virtualization</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-Managing-the-GIC-virtual-CPU-interface"><span class="nav-text">5.2 Managing the GIC virtual CPU interface</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-1-List-registers-and-virtual-interrupt-handling"><span class="nav-text">5.2.1 List registers and virtual interrupt handling</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-2-Completion-of-virtualized-physical-interrupts"><span class="nav-text">5.2.2 Completion of virtualized physical interrupts</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-3-Acknowledgement-and-completion-of-virtual-interrupts"><span class="nav-text">5.2.3 Acknowledgement and completion of virtual interrupts</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-4-GIC-virtual-interface-control-interface-requirements"><span class="nav-text">5.2.4 GIC virtual interface control interface requirements</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-5-Maintenance-interrupts"><span class="nav-text">5.2.5 Maintenance interrupts</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-6-Software-generated-interrupts"><span class="nav-text">5.2.6 Software-generated interrupts</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-7-GIC-Virtualization-Extensions-register-mapping"><span class="nav-text">5.2.7 GIC Virtualization Extensions register mapping</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-GIC-virtual-interface-control-registers"><span class="nav-text">5.3 GIC virtual interface control registers</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-1-Hypervisor-Control-Register-GICH-HCR"><span class="nav-text">5.3.1 Hypervisor Control Register, GICH_HCR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-2-VGIC-Type-Register-GICH-VTR"><span class="nav-text">5.3.2 VGIC Type Register, GICH_VTR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-3-Virtual-Machine-Control-Register-GICH-VMCR"><span class="nav-text">5.3.3 Virtual Machine Control Register, GICH_VMCR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-4-Maintenance-Interrupt-Status-Register-GICH-MISR"><span class="nav-text">5.3.4 Maintenance Interrupt Status Register, GICH_MISR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-5-End-of-Interrupt-Status-Registers-GICH-EISR0-and-GICH-EISR1"><span class="nav-text">5.3.5 End of Interrupt Status Registers, GICH_EISR0 and GICH_EISR1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-6-Empty-List-Register-Status-Registers-GICH-ELRSR0-and-GICH-ELRSR1"><span class="nav-text">5.3.6 Empty List Register Status Registers, GICH_ELRSR0 and GICH_ELRSR1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-7-Active-Priorities-Register-GICH-APR"><span class="nav-text">5.3.7 Active Priorities Register, GICH_APR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-8-List-Registers-GICH-LRn"><span class="nav-text">5.3.8 List Registers, GICH_LRn</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-The-virtual-CPU-interface"><span class="nav-text">5.4 The virtual CPU interface</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-GIC-virtual-CPU-interface-registers"><span class="nav-text">5.5 GIC virtual CPU interface registers</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JShell07</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  





  
  







  



  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/reading_progress/reading_progress.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
